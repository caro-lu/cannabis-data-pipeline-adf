{
    "$schema": "http://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#",
    "contentVersion": "1.0.0.0",
    "parameters": {
        "factoryName": {
            "type": "string",
            "metadata": "Data Factory name",
            "defaultValue": "Canna-ADF"
        },
        "Canna_ADLS_accountKey": {
            "type": "secureString",
            "metadata": "Secure string for 'accountKey' of 'Canna_ADLS'"
        },
        "Canna_PostgreSQL_Collect_password": {
            "type": "secureString",
            "metadata": "Secure string for 'password' of 'Canna_PostgreSQL_Collect'"
        },
        "Canna_PostgreSQL_Rpt_password": {
            "type": "secureString",
            "metadata": "Secure string for 'password' of 'Canna_PostgreSQL_Rpt'"
        },
        "Canna_Snowflake_Collect_password": {
            "type": "secureString",
            "metadata": "Secure string for 'password' of 'Canna_Snowflake_Collect'"
        },
        "Canna_Snowflake_Rpt_password": {
            "type": "secureString",
            "metadata": "Secure string for 'password' of 'Canna_Snowflake_Rpt'"
        },
        "Canna_ADLS_properties_typeProperties_url": {
            "type": "string",
            "defaultValue": "https://YOUR_STORAGE_ACCOUNT.dfs.core.windows.net/"
        },
        "Canna_PostgreSQL_Collect_properties_typeProperties_server": {
            "type": "string",
            "defaultValue": "YOUR_SERVER_IP"
        },
        "Canna_PostgreSQL_Collect_properties_typeProperties_database": {
            "type": "string",
            "defaultValue": "collect"
        },
        "Canna_PostgreSQL_Collect_properties_typeProperties_username": {
            "type": "string",
            "defaultValue": "rpt"
        },
        "Canna_PostgreSQL_Rpt_properties_typeProperties_server": {
            "type": "string",
            "defaultValue": "YOUR_SERVER_IP"
        },
        "Canna_PostgreSQL_Rpt_properties_typeProperties_database": {
            "type": "string",
            "defaultValue": "rpt"
        },
        "Canna_PostgreSQL_Rpt_properties_typeProperties_username": {
            "type": "string",
            "defaultValue": "rpt"
        },
        "Canna_Snowflake_Collect_properties_typeProperties_database": {
            "type": "string",
            "defaultValue": "SOURCE_DB"
        },
        "Canna_Snowflake_Collect_properties_typeProperties_role": {
            "type": "string",
            "defaultValue": "SERVICE_ROLE"
        },
        "Canna_Snowflake_Collect_properties_typeProperties_host": {
            "type": "string",
            "defaultValue": "YOUR_SNOWFLAKE_ACCOUNT.snowflakecomputing.com"
        },
        "Canna_Snowflake_Rpt_properties_typeProperties_database": {
            "type": "string",
            "defaultValue": "REPORTING_DB"
        },
        "Canna_Snowflake_Rpt_properties_typeProperties_role": {
            "type": "string",
            "defaultValue": "SERVICE_ROLE"
        },
        "Canna_Snowflake_Rpt_properties_typeProperties_host": {
            "type": "string",
            "defaultValue": "YOUR_SNOWFLAKE_ACCOUNT.snowflakecomputing.com"
        }
    },
    "variables": {
        "factoryId": "[concat('Microsoft.DataFactory/factories/', parameters('factoryName'))]"
    },
    "resources": [
        {
            "name": "[concat(parameters('factoryName'), '/Collect_Pipeline_Incremental_JSON')]",
            "type": "Microsoft.DataFactory/factories/pipelines",
            "apiVersion": "2018-06-01",
            "properties": {
                "activities": [
                    {
                        "name": "Set_Pipeline_Start_Time",
                        "description": "Set the start time of when the pipeline runs",
                        "type": "SetVariable",
                        "dependsOn": [],
                        "policy": {
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "variableName": "PipelineStartTime",
                            "value": {
                                "value": "@formatDateTime(utcnow(), 'yyyy-MM-dd')",
                                "type": "Expression"
                            }
                        }
                    },
                    {
                        "name": "ForEach_Incremental_Table",
                        "type": "ForEach",
                        "dependsOn": [
                            {
                                "activity": "Get_Collect_Tables",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "userProperties": [],
                        "typeProperties": {
                            "items": {
                                "value": "@activity('Get_Collect_Tables').output.value",
                                "type": "Expression"
                            },
                            "isSequential": true,
                            "activities": [
                                {
                                    "name": "Execute_Incremental_Load",
                                    "type": "ExecutePipeline",
                                    "dependsOn": [],
                                    "policy": {
                                        "secureInput": false
                                    },
                                    "userProperties": [],
                                    "typeProperties": {
                                        "pipeline": {
                                            "referenceName": "Collect_Table_With_Validation_Incremental_JSON",
                                            "type": "PipelineReference"
                                        },
                                        "waitOnCompletion": true,
                                        "parameters": {
                                            "SourceDatabase": "collect",
                                            "SchemaName": "collect",
                                            "TableName": {
                                                "value": "@item().tablename",
                                                "type": "Expression"
                                            },
                                            "WatermarkColumn": {
                                                "value": "@item().watermark_column",
                                                "type": "Expression"
                                            },
                                            "LastWatermark": {
                                                "value": "@item().last_watermark",
                                                "type": "Expression"
                                            },
                                            "RunDate": {
                                                "value": "@variables('PipelineStartTime')",
                                                "type": "Expression"
                                            }
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    {
                        "name": "Get_Collect_Tables",
                        "description": "Get all tables in collect database",
                        "type": "Lookup",
                        "dependsOn": [
                            {
                                "activity": "Initialize_Watermarks_If_Missing",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "source": {
                                "type": "PostgreSqlV2Source",
                                "query": "SELECT \n    'collect' as schemaname,\n    t.table_name as tablename,\n    'tm' as watermark_column,\n    COALESCE(w.last_watermark, '1900-01-01'::timestamp) as last_watermark\nFROM (\n    VALUES ('cc_io33_t')\n) t(table_name)\nLEFT JOIN collect.watermark_control w \n    ON t.table_name = w.table_name;",
                                "queryTimeout": "02:00:00"
                            },
                            "dataset": {
                                "referenceName": "Canna_PostgreSQL_Collect_Tables",
                                "type": "DatasetReference",
                                "parameters": {
                                    "SchemaName": "@pipeline().parameters.SchemaName",
                                    "TableName": "@pipeline().parameters.TableName"
                                }
                            },
                            "firstRowOnly": false
                        }
                    },
                    {
                        "name": "Initialize_Watermarks_If_Missing",
                        "type": "Lookup",
                        "dependsOn": [
                            {
                                "activity": "Set_Pipeline_Start_Time",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "source": {
                                "type": "PostgreSqlV2Source",
                                "query": "WITH new_watermarks AS (\n    INSERT INTO collect.watermark_control (table_name, last_watermark, updated_at)\n    SELECT \n        t.table_name,\n        CASE \n            WHEN t.table_name = 'cc_io33_t' THEN '2025-11-05 00:00:00'::timestamp\n            WHEN t.strategy = 'ROLLING_30DAY' THEN '2025-11-02 00:00:00'::timestamp\n            WHEN t.strategy = 'FULL_RELOAD' THEN '1900-01-01'::timestamp\n            ELSE '1900-01-01'::timestamp\n        END as last_watermark,\n        CURRENT_TIMESTAMP as updated_at\n    FROM (\n        SELECT 'cc_catalog_avail_t' as table_name, 'ROLLING_30DAY' as strategy, (SELECT MAX(tm) FROM collect.cc_catalog_avail_t) as max_tm\n        UNION ALL\n        SELECT 'cc_io_t' as table_name, 'ROLLING_30DAY' as strategy, (SELECT MAX(tm) FROM collect.cc_io_t) as max_tm\n        UNION ALL\n        SELECT 'cc_po_t' as table_name, 'ROLLING_30DAY' as strategy, (SELECT MAX(tm) FROM collect.cc_po_t) as max_tm\n        UNION ALL\n        SELECT 'cc_po33_t' as table_name, 'ROLLING_30DAY' as strategy, (SELECT MAX(tm) FROM collect.cc_po33_t) as max_tm\n        UNION ALL\n        SELECT 'cc_io33_t' as table_name, 'ROLLING_30DAY' as strategy, (SELECT MAX(tm) FROM collect.cc_io33_t) as max_tm\n        UNION ALL\n        SELECT 'cc_company_t' as table_name, 'FULL_RELOAD' as strategy, NULL as max_tm\n        UNION ALL\n        SELECT 'cc_location_t' as table_name, 'FULL_RELOAD' as strategy, NULL as max_tm\n        UNION ALL\n        SELECT 'cc_integrator_t' as table_name, 'FULL_RELOAD' as strategy, NULL as max_tm\n        UNION ALL\n        SELECT 'cc_catalog_t' as table_name, 'FULL_RELOAD' as strategy, NULL as max_tm\n        UNION ALL\n        SELECT 'products_01_on' as table_name, 'FULL_RELOAD' as strategy, NULL as max_tm\n        UNION ALL\n        SELECT 'cc_zip_t' as table_name, 'FULL_RELOAD' as strategy, NULL as max_tm\n    ) t\n    WHERE NOT EXISTS (\n        SELECT 1 FROM collect.watermark_control w \n        WHERE w.table_name = t.table_name\n    )\n    RETURNING table_name, last_watermark, updated_at\n)\nSELECT \n    COALESCE((SELECT COUNT(*) FROM new_watermarks), 0) as initialized_count,\n    'Watermarks initialized' as status;",
                                "queryTimeout": "02:00:00"
                            },
                            "dataset": {
                                "referenceName": "Canna_PostgreSQL_Collect_Tables",
                                "type": "DatasetReference",
                                "parameters": {
                                    "SchemaName": "collect",
                                    "TableName": "watermark_control"
                                }
                            }
                        }
                    }
                ],
                "policy": {
                    "elapsedTimeMetric": {}
                },
                "parameters": {
                    "SchemaName": {
                        "type": "string"
                    },
                    "TableName": {
                        "type": "string"
                    }
                },
                "variables": {
                    "PipelineStartTime": {
                        "type": "String"
                    },
                    "ValidationErrors": {
                        "type": "String"
                    },
                    "ProcessedTables": {
                        "type": "String"
                    }
                },
                "annotations": [],
                "lastPublishTime": "2025-09-18T14:27:22Z"
            },
            "dependsOn": [
                "[concat(variables('factoryId'), '/datasets/Canna_PostgreSQL_Collect_Tables')]",
                "[concat(variables('factoryId'), '/pipelines/Collect_Table_With_Validation_Incremental_JSON')]"
            ]
        },
        {
            "name": "[concat(parameters('factoryName'), '/Collect_Pipeline_Incremental_JSON_Date')]",
            "type": "Microsoft.DataFactory/factories/pipelines",
            "apiVersion": "2018-06-01",
            "properties": {
                "activities": [
                    {
                        "name": "Set_Pipeline_Start_Time",
                        "description": "Set the start time of when the pipeline runs",
                        "type": "SetVariable",
                        "dependsOn": [],
                        "policy": {
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "variableName": "PipelineStartTime",
                            "value": {
                                "value": "@formatDateTime(utcnow(), 'yyyy-MM-dd')",
                                "type": "Expression"
                            }
                        }
                    },
                    {
                        "name": "ForEach_Incremental_Table",
                        "type": "ForEach",
                        "dependsOn": [
                            {
                                "activity": "Get_Collect_Tables",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "userProperties": [],
                        "typeProperties": {
                            "items": {
                                "value": "@activity('Get_Collect_Tables').output.value",
                                "type": "Expression"
                            },
                            "isSequential": true,
                            "activities": [
                                {
                                    "name": "Execute_Incremental_Load",
                                    "type": "ExecutePipeline",
                                    "dependsOn": [],
                                    "policy": {
                                        "secureInput": false
                                    },
                                    "userProperties": [],
                                    "typeProperties": {
                                        "pipeline": {
                                            "referenceName": "Collect_Table_With_Validation_Incremental_JSON_Date",
                                            "type": "PipelineReference"
                                        },
                                        "waitOnCompletion": true,
                                        "parameters": {
                                            "SourceDatabase": "collect",
                                            "SchemaName": "collect",
                                            "TableName": {
                                                "value": "@item().tablename",
                                                "type": "Expression"
                                            },
                                            "WatermarkColumn": {
                                                "value": "@item().watermark_column",
                                                "type": "Expression"
                                            },
                                            "LastWatermark": {
                                                "value": "@item().last_watermark",
                                                "type": "Expression"
                                            },
                                            "RunDate": {
                                                "value": "@variables('PipelineStartTime')",
                                                "type": "Expression"
                                            }
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    {
                        "name": "Get_Collect_Tables",
                        "description": "Get all tables in collect database",
                        "type": "Lookup",
                        "dependsOn": [
                            {
                                "activity": "Initialize_Watermarks_If_Missing",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "source": {
                                "type": "PostgreSqlV2Source",
                                "query": "SELECT \n    'SOURCE_DB' as schemaname,\n    t.table_name as tablename,\n    'date' as watermark_column,  -- cc_io33_t uses 'date'\n    COALESCE(w.last_watermark, '2000-01-01 00:00:00'::timestamp) as last_watermark\nFROM (\n    VALUES \n    ('cc_io33_t')  -- Changed from cc_io_t\n) t(table_name)\nLEFT JOIN collect.watermark_control w \n    ON t.table_name = w.table_name",
                                "queryTimeout": "02:00:00"
                            },
                            "dataset": {
                                "referenceName": "Canna_PostgreSQL_Collect_Tables",
                                "type": "DatasetReference",
                                "parameters": {
                                    "SchemaName": "@pipeline().parameters.SchemaName",
                                    "TableName": "@pipeline().parameters.TableName"
                                }
                            },
                            "firstRowOnly": false
                        }
                    },
                    {
                        "name": "Initialize_Watermarks_If_Missing",
                        "type": "Lookup",
                        "dependsOn": [
                            {
                                "activity": "Set_Pipeline_Start_Time",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "source": {
                                "type": "PostgreSqlV2Source",
                                "query": "WITH new_watermarks AS (\n    INSERT INTO collect.watermark_control (table_name, last_watermark, updated_at)\n    SELECT \n        t.table_name,\n        CASE \n            WHEN t.strategy = 'ROLLING_30DAY' THEN (CURRENT_DATE - INTERVAL '30 days')::timestamp\n            WHEN t.strategy = 'FULL_RELOAD' THEN '1900-01-01'::timestamp\n            ELSE '1900-01-01'::timestamp\n        END as last_watermark,\n        CURRENT_TIMESTAMP as updated_at\n    FROM (\n        -- Fact tables with ROLLING_30DAY using 'dt'\n        SELECT 'cc_io_t' as table_name, 'ROLLING_30DAY' as strategy\n        UNION ALL\n        -- Fact tables with ROLLING_30DAY using 'date'\n        SELECT 'cc_catalog_avail_t' as table_name, 'ROLLING_30DAY' as strategy\n        UNION ALL\n        SELECT 'cc_io33_t' as table_name, 'ROLLING_30DAY' as strategy\n        UNION ALL\n        SELECT 'cc_po33_t' as table_name, 'ROLLING_30DAY' as strategy\n        UNION ALL\n        SELECT 'cc_po_t' as table_name, 'ROLLING_30DAY' as strategy\n        UNION ALL\n        SELECT 'cc_catalog_t' as table_name, 'FULL_RELOAD' as strategy\n        UNION ALL\n        SELECT 'cc_company_t' as table_name, 'FULL_RELOAD' as strategy\n        UNION ALL\n        SELECT 'cc_integrator_t' as table_name, 'FULL_RELOAD' as strategy\n        UNION ALL\n        SELECT 'cc_location_t' as table_name, 'FULL_RELOAD' as strategy\n        UNION ALL\n        SELECT 'cc_zip_t' as table_name, 'FULL_RELOAD' as strategy\n        UNION ALL\n        SELECT 'products_01_on' as table_name, 'FULL_RELOAD' as strategy\n    ) t\n    WHERE NOT EXISTS (\n        SELECT 1 FROM collect.watermark_control w \n        WHERE w.table_name = t.table_name\n    )\n    RETURNING table_name, last_watermark, updated_at\n)\nSELECT \n    COALESCE((SELECT COUNT(*) FROM new_watermarks), 0) as initialized_count,\n    'Watermarks initialized' as status;",
                                "queryTimeout": "02:00:00"
                            },
                            "dataset": {
                                "referenceName": "Canna_PostgreSQL_Collect_Tables",
                                "type": "DatasetReference",
                                "parameters": {
                                    "SchemaName": "collect",
                                    "TableName": "watermark_control"
                                }
                            }
                        }
                    }
                ],
                "policy": {
                    "elapsedTimeMetric": {}
                },
                "parameters": {
                    "SchemaName": {
                        "type": "string"
                    },
                    "TableName": {
                        "type": "string"
                    }
                },
                "variables": {
                    "PipelineStartTime": {
                        "type": "String"
                    },
                    "ValidationErrors": {
                        "type": "String"
                    },
                    "ProcessedTables": {
                        "type": "String"
                    }
                },
                "folder": {
                    "name": "Archive"
                },
                "annotations": [],
                "lastPublishTime": "2025-09-18T14:27:22Z"
            },
            "dependsOn": [
                "[concat(variables('factoryId'), '/datasets/Canna_PostgreSQL_Collect_Tables')]",
                "[concat(variables('factoryId'), '/pipelines/Collect_Table_With_Validation_Incremental_JSON_Date')]"
            ]
        },
        {
            "name": "[concat(parameters('factoryName'), '/Collect_Pipeline_Incremental_JSON_Increm_Row_Count')]",
            "type": "Microsoft.DataFactory/factories/pipelines",
            "apiVersion": "2018-06-01",
            "properties": {
                "activities": [
                    {
                        "name": "Set_Pipeline_Start_Time",
                        "description": "Set the start time of when the pipeline runs",
                        "type": "SetVariable",
                        "dependsOn": [],
                        "policy": {
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "variableName": "PipelineStartTime",
                            "value": {
                                "value": "@formatDateTime(utcnow(), 'yyyy-MM-dd')",
                                "type": "Expression"
                            }
                        }
                    },
                    {
                        "name": "ForEach_Incremental_Table",
                        "type": "ForEach",
                        "dependsOn": [
                            {
                                "activity": "Get_Collect_Tables",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "userProperties": [],
                        "typeProperties": {
                            "items": {
                                "value": "@activity('Get_Collect_Tables').output.value",
                                "type": "Expression"
                            },
                            "isSequential": true,
                            "activities": [
                                {
                                    "name": "Execute_Incremental_Load",
                                    "type": "ExecutePipeline",
                                    "dependsOn": [],
                                    "policy": {
                                        "secureInput": false
                                    },
                                    "userProperties": [],
                                    "typeProperties": {
                                        "pipeline": {
                                            "referenceName": "Collect_Table_With_Validation_Incremental_JSON_Increm_Row_Count",
                                            "type": "PipelineReference"
                                        },
                                        "waitOnCompletion": true,
                                        "parameters": {
                                            "SourceDatabase": "collect",
                                            "SchemaName": "collect",
                                            "TableName": {
                                                "value": "@item().tablename",
                                                "type": "Expression"
                                            },
                                            "WatermarkColumn": {
                                                "value": "@item().watermark_column",
                                                "type": "Expression"
                                            },
                                            "LastWatermark": {
                                                "value": "@item().last_watermark",
                                                "type": "Expression"
                                            },
                                            "RunDate": {
                                                "value": "@variables('PipelineStartTime')",
                                                "type": "Expression"
                                            }
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    {
                        "name": "Get_Collect_Tables",
                        "description": "Get all tables in collect database",
                        "type": "Lookup",
                        "dependsOn": [
                            {
                                "activity": "Initialize_Watermarks_If_Missing",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "source": {
                                "type": "PostgreSqlV2Source",
                                "query": "SELECT \n    'collect' as schemaname,\n    t.table_name as tablename,\n    'tm' as watermark_column,\n    COALESCE(w.last_watermark, '1900-01-01'::timestamp) as last_watermark\nFROM (\n    VALUES ('cc_po_t')\n) t(table_name)\nLEFT JOIN collect.watermark_control w \n    ON t.table_name = w.table_name;",
                                "queryTimeout": "02:00:00"
                            },
                            "dataset": {
                                "referenceName": "Canna_PostgreSQL_Collect_Tables",
                                "type": "DatasetReference",
                                "parameters": {
                                    "SchemaName": "@pipeline().parameters.SchemaName",
                                    "TableName": "@pipeline().parameters.TableName"
                                }
                            },
                            "firstRowOnly": false
                        }
                    },
                    {
                        "name": "Initialize_Watermarks_If_Missing",
                        "type": "Lookup",
                        "dependsOn": [
                            {
                                "activity": "Set_Pipeline_Start_Time",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "source": {
                                "type": "PostgreSqlV2Source",
                                "query": "WITH new_watermarks AS (\n    INSERT INTO collect.watermark_control (table_name, last_watermark, updated_at)\n    SELECT \n        t.table_name,\n        CASE \n            WHEN t.strategy = 'ROLLING_30DAY' THEN '2025-11-02 00:00:00'::timestamp\n            WHEN t.strategy = 'FULL_RELOAD' THEN '1900-01-01'::timestamp\n            ELSE '1900-01-01'::timestamp\n        END as last_watermark,\n        CURRENT_TIMESTAMP as updated_at\n    FROM (\n        SELECT 'cc_catalog_avail_t' as table_name, 'ROLLING_30DAY' as strategy, (SELECT MAX(tm) FROM collect.cc_catalog_avail_t) as max_tm\n        UNION ALL\n        SELECT 'cc_io_t' as table_name, 'ROLLING_30DAY' as strategy, (SELECT MAX(tm) FROM collect.cc_io_t) as max_tm\n        UNION ALL\n        SELECT 'cc_po_t' as table_name, 'ROLLING_30DAY' as strategy, (SELECT MAX(tm) FROM collect.cc_po_t) as max_tm\n        UNION ALL\n        SELECT 'cc_po33_t' as table_name, 'ROLLING_30DAY' as strategy, (SELECT MAX(tm) FROM collect.cc_po33_t) as max_tm\n        UNION ALL\n        SELECT 'cc_io33_t' as table_name, 'ROLLING_30DAY' as strategy, (SELECT MAX(tm) FROM collect.cc_io33_t) as max_tm\n        UNION ALL\n        SELECT 'cc_company_t' as table_name, 'FULL_RELOAD' as strategy, NULL as max_tm\n        UNION ALL\n        SELECT 'cc_location_t' as table_name, 'FULL_RELOAD' as strategy, NULL as max_tm\n        UNION ALL\n        SELECT 'cc_integrator_t' as table_name, 'FULL_RELOAD' as strategy, NULL as max_tm\n        UNION ALL\n        SELECT 'cc_catalog_t' as table_name, 'FULL_RELOAD' as strategy, NULL as max_tm\n        UNION ALL\n        SELECT 'products_01_on' as table_name, 'FULL_RELOAD' as strategy, NULL as max_tm\n        UNION ALL\n        SELECT 'cc_zip_t' as table_name, 'FULL_RELOAD' as strategy, NULL as max_tm\n    ) t\n    WHERE NOT EXISTS (\n        SELECT 1 FROM collect.watermark_control w \n        WHERE w.table_name = t.table_name\n    )\n    RETURNING table_name, last_watermark, updated_at\n)\nSELECT \n    COALESCE((SELECT COUNT(*) FROM new_watermarks), 0) as initialized_count,\n    'Watermarks initialized' as status;",
                                "queryTimeout": "02:00:00"
                            },
                            "dataset": {
                                "referenceName": "Canna_PostgreSQL_Collect_Tables",
                                "type": "DatasetReference",
                                "parameters": {
                                    "SchemaName": "collect",
                                    "TableName": "watermark_control"
                                }
                            }
                        }
                    }
                ],
                "policy": {
                    "elapsedTimeMetric": {}
                },
                "parameters": {
                    "SchemaName": {
                        "type": "string"
                    },
                    "TableName": {
                        "type": "string"
                    }
                },
                "variables": {
                    "PipelineStartTime": {
                        "type": "String"
                    },
                    "ValidationErrors": {
                        "type": "String"
                    },
                    "ProcessedTables": {
                        "type": "String"
                    }
                },
                "folder": {
                    "name": "Archive"
                },
                "annotations": [],
                "lastPublishTime": "2025-09-18T14:27:22Z"
            },
            "dependsOn": [
                "[concat(variables('factoryId'), '/datasets/Canna_PostgreSQL_Collect_Tables')]",
                "[concat(variables('factoryId'), '/pipelines/Collect_Table_With_Validation_Incremental_JSON_Increm_Row_Count')]"
            ]
        },
        {
            "name": "[concat(parameters('factoryName'), '/Collect_Pipeline_Incremental_JSON_Nov')]",
            "type": "Microsoft.DataFactory/factories/pipelines",
            "apiVersion": "2018-06-01",
            "properties": {
                "activities": [
                    {
                        "name": "Set_Pipeline_Start_Time",
                        "description": "Set the start time of when the pipeline runs",
                        "type": "SetVariable",
                        "dependsOn": [],
                        "policy": {
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "variableName": "PipelineStartTime",
                            "value": {
                                "value": "@formatDateTime(utcnow(), 'yyyy-MM-dd')",
                                "type": "Expression"
                            }
                        }
                    },
                    {
                        "name": "ForEach_Incremental_Table",
                        "type": "ForEach",
                        "dependsOn": [
                            {
                                "activity": "Get_Collect_Tables",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "userProperties": [],
                        "typeProperties": {
                            "items": {
                                "value": "@activity('Get_Collect_Tables').output.value",
                                "type": "Expression"
                            },
                            "isSequential": true,
                            "activities": [
                                {
                                    "name": "Execute_Incremental_Load",
                                    "type": "ExecutePipeline",
                                    "dependsOn": [],
                                    "policy": {
                                        "secureInput": false
                                    },
                                    "userProperties": [],
                                    "typeProperties": {
                                        "pipeline": {
                                            "referenceName": "Collect_Table_With_Validation_Incremental_JSON_Nov",
                                            "type": "PipelineReference"
                                        },
                                        "waitOnCompletion": true,
                                        "parameters": {
                                            "SourceDatabase": "collect",
                                            "SchemaName": "collect",
                                            "TableName": {
                                                "value": "@item().tablename",
                                                "type": "Expression"
                                            },
                                            "WatermarkColumn": {
                                                "value": "@item().watermark_column",
                                                "type": "Expression"
                                            },
                                            "LastWatermark": {
                                                "value": "@item().last_watermark",
                                                "type": "Expression"
                                            },
                                            "RunDate": {
                                                "value": "@variables('PipelineStartTime')",
                                                "type": "Expression"
                                            }
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    {
                        "name": "Get_Collect_Tables",
                        "description": "Get all tables in collect database",
                        "type": "Lookup",
                        "dependsOn": [
                            {
                                "activity": "Initialize_Watermarks_If_Missing",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "source": {
                                "type": "PostgreSqlV2Source",
                                "query": "SELECT \n    'collect' as schemaname,\n    t.table_name as tablename,\n    'tm' as watermark_column,\n    w.last_watermark\nFROM (\n    VALUES \n    ('cc_catalog_avail_t')\n) t(table_name)\nINNER JOIN collect.watermark_control w ON t.table_name = w.table_name",
                                "queryTimeout": "02:00:00"
                            },
                            "dataset": {
                                "referenceName": "Canna_PostgreSQL_Collect_Tables",
                                "type": "DatasetReference",
                                "parameters": {
                                    "SchemaName": "@pipeline().parameters.SchemaName",
                                    "TableName": "@pipeline().parameters.TableName"
                                }
                            },
                            "firstRowOnly": false
                        }
                    },
                    {
                        "name": "Initialize_Watermarks_If_Missing",
                        "type": "Lookup",
                        "dependsOn": [
                            {
                                "activity": "Set_Pipeline_Start_Time",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "source": {
                                "type": "PostgreSqlV2Source",
                                "query": "WITH new_watermarks AS (\n    INSERT INTO collect.watermark_control (table_name, last_watermark, updated_at)\n    SELECT \n        t.table_name,\n        CASE \n            WHEN t.strategy = 'ROLLING_30DAY' THEN '2025-11-02 00:00:00'::timestamp\n            WHEN t.strategy = 'FULL_RELOAD' THEN '1900-01-01'::timestamp\n            ELSE '1900-01-01'::timestamp\n        END as last_watermark,\n        CURRENT_TIMESTAMP as updated_at\n    FROM (\n        SELECT \n            'cc_catalog_avail_t' as table_name,\n            'ROLLING_30DAY' as strategy,\n            (SELECT MAX(tm) FROM collect.cc_catalog_avail_t) as max_tm\n\n    ) t\n    WHERE NOT EXISTS (\n        SELECT 1 FROM collect.watermark_control w \n        WHERE w.table_name = t.table_name\n    )\n    RETURNING table_name, last_watermark, updated_at\n)\nSELECT \n    COALESCE((SELECT COUNT(*) FROM new_watermarks), 0) as initialized_count,\n    'Watermarks initialized' as status;\n",
                                "queryTimeout": "02:00:00"
                            },
                            "dataset": {
                                "referenceName": "Canna_PostgreSQL_Collect_Tables",
                                "type": "DatasetReference",
                                "parameters": {
                                    "SchemaName": "collect",
                                    "TableName": "watermark_control"
                                }
                            }
                        }
                    }
                ],
                "policy": {
                    "elapsedTimeMetric": {}
                },
                "parameters": {
                    "SchemaName": {
                        "type": "string"
                    },
                    "TableName": {
                        "type": "string"
                    }
                },
                "variables": {
                    "PipelineStartTime": {
                        "type": "String"
                    },
                    "ValidationErrors": {
                        "type": "String"
                    },
                    "ProcessedTables": {
                        "type": "String"
                    }
                },
                "folder": {
                    "name": "Archive"
                },
                "annotations": [],
                "lastPublishTime": "2025-09-18T14:27:22Z"
            },
            "dependsOn": [
                "[concat(variables('factoryId'), '/datasets/Canna_PostgreSQL_Collect_Tables')]",
                "[concat(variables('factoryId'), '/pipelines/Collect_Table_With_Validation_Incremental_JSON_Nov')]"
            ]
        },
        {
            "name": "[concat(parameters('factoryName'), '/Collect_Pipeline_Incremental_JSON_TESTING')]",
            "type": "Microsoft.DataFactory/factories/pipelines",
            "apiVersion": "2018-06-01",
            "properties": {
                "activities": [
                    {
                        "name": "Set_Pipeline_Start_Time",
                        "description": "Set the start time of when the pipeline runs",
                        "type": "SetVariable",
                        "dependsOn": [],
                        "policy": {
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "variableName": "PipelineStartTime",
                            "value": {
                                "value": "@formatDateTime(utcnow(), 'yyyy-MM-dd')",
                                "type": "Expression"
                            }
                        }
                    },
                    {
                        "name": "ForEach_Incremental_Table",
                        "type": "ForEach",
                        "dependsOn": [
                            {
                                "activity": "Get_Collect_Tables",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "userProperties": [],
                        "typeProperties": {
                            "items": {
                                "value": "@activity('Get_Collect_Tables').output.value",
                                "type": "Expression"
                            },
                            "isSequential": true,
                            "activities": [
                                {
                                    "name": "Execute_Incremental_Load",
                                    "type": "ExecutePipeline",
                                    "dependsOn": [],
                                    "policy": {
                                        "secureInput": false
                                    },
                                    "userProperties": [],
                                    "typeProperties": {
                                        "pipeline": {
                                            "referenceName": "Collect_Table_With_Validation_Incremental_JSON_TESTING",
                                            "type": "PipelineReference"
                                        },
                                        "waitOnCompletion": true,
                                        "parameters": {
                                            "SourceDatabase": "collect",
                                            "SchemaName": "collect",
                                            "TableName": {
                                                "value": "@item().tablename",
                                                "type": "Expression"
                                            },
                                            "WatermarkColumn": {
                                                "value": "@item().watermark_column",
                                                "type": "Expression"
                                            },
                                            "LastWatermark": {
                                                "value": "@item().last_watermark",
                                                "type": "Expression"
                                            },
                                            "RunDate": {
                                                "value": "@variables('PipelineStartTime')",
                                                "type": "Expression"
                                            }
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    {
                        "name": "Get_Collect_Tables",
                        "description": "Get all tables in collect database",
                        "type": "Lookup",
                        "dependsOn": [
                            {
                                "activity": "Initialize_Watermarks_If_Missing",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "source": {
                                "type": "PostgreSqlV2Source",
                                "query": "SELECT \n    'collect' as schemaname,\n    t.table_name as tablename,\n    'tm' as watermark_column,\n    w.last_watermark\nFROM (\n    VALUES \n    ('cc_po_t')\n) t(table_name)\nINNER JOIN collect.watermark_control w ON t.table_name = w.table_name",
                                "queryTimeout": "02:00:00"
                            },
                            "dataset": {
                                "referenceName": "Canna_PostgreSQL_Collect_Tables",
                                "type": "DatasetReference",
                                "parameters": {
                                    "SchemaName": "@pipeline().parameters.SchemaName",
                                    "TableName": "@pipeline().parameters.TableName"
                                }
                            },
                            "firstRowOnly": false
                        }
                    },
                    {
                        "name": "Initialize_Watermarks_If_Missing",
                        "type": "Lookup",
                        "dependsOn": [
                            {
                                "activity": "Set_Pipeline_Start_Time",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "source": {
                                "type": "PostgreSqlV2Source",
                                "query": "WITH new_watermarks AS (\n    INSERT INTO collect.watermark_control (table_name, last_watermark, updated_at)\n    SELECT \n        t.table_name,\n        CASE \n            WHEN t.strategy = 'ROLLING_30DAY' THEN (CURRENT_DATE - INTERVAL '30 days')::timestamp\n            WHEN t.strategy = 'INCREMENTAL' THEN COALESCE(t.max_tm, '1900-01-01'::timestamp)\n            ELSE '1900-01-01'::timestamp\n        END as last_watermark,\n        CURRENT_TIMESTAMP as updated_at\n    FROM (\n        SELECT \n            'cc_po_t' as table_name,\n            'ROLLING_30DAY' as strategy,\n            (SELECT MAX(tm) FROM collect.cc_po_t) as max_tm\n        UNION ALL\n        SELECT \n            'cc_po33_t' as table_name,\n            'ROLLING_30DAY' as strategy,\n            (SELECT MAX(tm) FROM collect.cc_po33_t) as max_tm\n        UNION ALL\n        SELECT \n            'cc_company_t' as table_name,\n            'FULL_RELOAD' as strategy,\n            NULL as max_tm\n        UNION ALL\n        SELECT \n            'cc_location_t' as table_name,\n            'FULL_RELOAD' as strategy,\n            NULL as max_tm\n        UNION ALL\n        SELECT \n            'cc_integrator_t' as table_name,\n            'FULL_RELOAD' as strategy,\n            NULL as max_tm\n        UNION ALL\n        SELECT \n            'cc_catalog_t' as table_name,\n            'INCREMENTAL' as strategy,\n            (SELECT MAX(tm) FROM collect.cc_catalog_t) as max_tm\n        UNION ALL\n        SELECT \n            'cc_io_t' as table_name,\n            'ROLLING_30DAY' as strategy,\n            (SELECT MAX(tm) FROM collect.cc_io_t) as max_tm\n        UNION ALL\n        SELECT \n            'cc_io33_t' as table_name,\n            'ROLLING_30DAY' as strategy,\n            (SELECT MAX(tm) FROM collect.cc_io33_t) as max_tm\n        UNION ALL\n        SELECT \n            'cc_catalog_avail_t' as table_name,\n            'ROLLING_30DAY' as strategy,\n            (SELECT MAX(tm) FROM collect.cc_catalog_avail_t) as max_tm\n        UNION ALL\n        SELECT \n            'cc_io33_t' as table_name,\n            'ROLLING_30DAY' as strategy,\n            (SELECT MAX(tm) FROM collect.cc_io33_t) as max_tm\n    ) t\n    WHERE NOT EXISTS (\n        SELECT 1 FROM collect.watermark_control w \n        WHERE w.table_name = t.table_name\n    )\n    RETURNING table_name, last_watermark, updated_at\n)\nSELECT \n    COALESCE((SELECT COUNT(*) FROM new_watermarks), 0) as initialized_count,\n    'Watermarks initialized' as status;",
                                "queryTimeout": "02:00:00"
                            },
                            "dataset": {
                                "referenceName": "Canna_PostgreSQL_Collect_Tables",
                                "type": "DatasetReference",
                                "parameters": {
                                    "SchemaName": "collect",
                                    "TableName": "watermark_control"
                                }
                            }
                        }
                    }
                ],
                "policy": {
                    "elapsedTimeMetric": {}
                },
                "parameters": {
                    "SchemaName": {
                        "type": "string"
                    },
                    "TableName": {
                        "type": "string"
                    }
                },
                "variables": {
                    "PipelineStartTime": {
                        "type": "String"
                    },
                    "ValidationErrors": {
                        "type": "String"
                    },
                    "ProcessedTables": {
                        "type": "String"
                    }
                },
                "folder": {
                    "name": "Archive"
                },
                "annotations": [],
                "lastPublishTime": "2025-09-18T14:27:22Z"
            },
            "dependsOn": [
                "[concat(variables('factoryId'), '/datasets/Canna_PostgreSQL_Collect_Tables')]",
                "[concat(variables('factoryId'), '/pipelines/Collect_Table_With_Validation_Incremental_JSON_TESTING')]"
            ]
        },
        {
            "name": "[concat(parameters('factoryName'), '/Collect_Pipeline_Incremental_JSON_TM')]",
            "type": "Microsoft.DataFactory/factories/pipelines",
            "apiVersion": "2018-06-01",
            "properties": {
                "activities": [
                    {
                        "name": "Set_Pipeline_Start_Time",
                        "description": "Set the start time of when the pipeline runs",
                        "type": "SetVariable",
                        "dependsOn": [],
                        "policy": {
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "variableName": "PipelineStartTime",
                            "value": {
                                "value": "@formatDateTime(utcnow(), 'yyyy-MM-dd')",
                                "type": "Expression"
                            }
                        }
                    },
                    {
                        "name": "ForEach_Incremental_Table",
                        "type": "ForEach",
                        "dependsOn": [
                            {
                                "activity": "Get_Collect_Tables",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "userProperties": [],
                        "typeProperties": {
                            "items": {
                                "value": "@activity('Get_Collect_Tables').output.value",
                                "type": "Expression"
                            },
                            "isSequential": true,
                            "activities": [
                                {
                                    "name": "Execute_Incremental_Load",
                                    "type": "ExecutePipeline",
                                    "dependsOn": [],
                                    "policy": {
                                        "secureInput": false
                                    },
                                    "userProperties": [],
                                    "typeProperties": {
                                        "pipeline": {
                                            "referenceName": "Collect_Table_With_Validation_Incremental_JSON_TM",
                                            "type": "PipelineReference"
                                        },
                                        "waitOnCompletion": true,
                                        "parameters": {
                                            "SourceDatabase": "collect",
                                            "SchemaName": "collect",
                                            "TableName": {
                                                "value": "@item().tablename",
                                                "type": "Expression"
                                            },
                                            "WatermarkColumn": {
                                                "value": "@item().watermark_column",
                                                "type": "Expression"
                                            },
                                            "LastWatermark": {
                                                "value": "@item().last_watermark",
                                                "type": "Expression"
                                            },
                                            "RunDate": {
                                                "value": "@variables('PipelineStartTime')",
                                                "type": "Expression"
                                            }
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    {
                        "name": "Get_Collect_Tables",
                        "description": "Get all tables in collect database",
                        "type": "Lookup",
                        "dependsOn": [
                            {
                                "activity": "Initialize_Watermarks_If_Missing",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "source": {
                                "type": "PostgreSqlV2Source",
                                "query": "SELECT \n    'collect' as schemaname,\n    t.table_name as tablename,\n    'tm' as watermark_column,\n    w.last_watermark\nFROM (\n    VALUES \n    ('cc_po_t')\n) t(table_name)\nINNER JOIN collect.watermark_control w ON t.table_name = w.table_name",
                                "queryTimeout": "02:00:00"
                            },
                            "dataset": {
                                "referenceName": "Canna_PostgreSQL_Collect_Tables",
                                "type": "DatasetReference",
                                "parameters": {
                                    "SchemaName": "@pipeline().parameters.SchemaName",
                                    "TableName": "@pipeline().parameters.TableName"
                                }
                            },
                            "firstRowOnly": false
                        }
                    },
                    {
                        "name": "Initialize_Watermarks_If_Missing",
                        "type": "Lookup",
                        "dependsOn": [
                            {
                                "activity": "Set_Pipeline_Start_Time",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "source": {
                                "type": "PostgreSqlV2Source",
                                "query": "WITH new_watermarks AS (\n    INSERT INTO collect.watermark_control (table_name, last_watermark, updated_at)\n    SELECT \n        t.table_name,\n        CASE \n            WHEN t.strategy = 'ROLLING_30DAY' THEN (CURRENT_DATE - INTERVAL '30 days')::timestamp\n            WHEN t.strategy = 'INCREMENTAL' THEN t.max_tm\n            ELSE '1900-01-01'::timestamp\n        END as last_watermark,\n        CURRENT_TIMESTAMP as updated_at\n    FROM (\n        SELECT \n            'cc_po_t' as table_name,\n            'ROLLING_30DAY' as strategy,\n            (SELECT MAX(tm) FROM collect.cc_po_t) as max_tm\n--        UNION ALL\n--        SELECT \n--            'cc_po33_t' as table_name,\n--            'ROLLING_30DAY' as strategy,\n--            (SELECT MAX(tm) FROM collect.cc_po33_t) as max_tm\n--        UNION ALL\n--        SELECT \n--           'cc_catalog_t' as table_name,\n--           'INCREMENTAL' as strategy,\n--            (SELECT MAX(tm) FROM collect.cc_catalog_t) as max_tm\n--        SELECT \n--            'cc_catalog_avail_t' as table_name,\n--            'ROLLING_30DAY' as strategy,\n--            (SELECT MAX(tm) FROM collect.cc_catalog_avail_t) as max_tm\n    ) t\n    WHERE NOT EXISTS (\n        SELECT 1 FROM collect.watermark_control w \n        WHERE w.table_name = t.table_name\n    )\n    RETURNING table_name, last_watermark, updated_at\n)\nSELECT \n    COALESCE((SELECT COUNT(*) FROM new_watermarks), 0) as initialized_count,\n    'Watermarks initialized' as status;",
                                "queryTimeout": "02:00:00"
                            },
                            "dataset": {
                                "referenceName": "Canna_PostgreSQL_Collect_Tables",
                                "type": "DatasetReference",
                                "parameters": {
                                    "SchemaName": "collect",
                                    "TableName": "watermark_control"
                                }
                            }
                        }
                    }
                ],
                "policy": {
                    "elapsedTimeMetric": {}
                },
                "parameters": {
                    "SchemaName": {
                        "type": "string"
                    },
                    "TableName": {
                        "type": "string"
                    }
                },
                "variables": {
                    "PipelineStartTime": {
                        "type": "String"
                    },
                    "ValidationErrors": {
                        "type": "String"
                    },
                    "ProcessedTables": {
                        "type": "String"
                    }
                },
                "folder": {
                    "name": "Archive"
                },
                "annotations": [],
                "lastPublishTime": "2025-09-18T14:27:22Z"
            },
            "dependsOn": [
                "[concat(variables('factoryId'), '/datasets/Canna_PostgreSQL_Collect_Tables')]",
                "[concat(variables('factoryId'), '/pipelines/Collect_Table_With_Validation_Incremental_JSON_TM')]"
            ]
        },
        {
            "name": "[concat(parameters('factoryName'), '/Collect_Pipeline_JSON')]",
            "type": "Microsoft.DataFactory/factories/pipelines",
            "apiVersion": "2018-06-01",
            "properties": {
                "activities": [
                    {
                        "name": "Set_Pipeline_Start_Time",
                        "description": "Set the start time of when the pipeline runs",
                        "type": "SetVariable",
                        "dependsOn": [],
                        "policy": {
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "variableName": "PipelineStartTime",
                            "value": {
                                "value": "@utcnow()",
                                "type": "Expression"
                            }
                        }
                    },
                    {
                        "name": "Get_Collect_Tables",
                        "description": "Get all tables in collect database",
                        "type": "Lookup",
                        "dependsOn": [
                            {
                                "activity": "Set_Pipeline_Start_Time",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "source": {
                                "type": "PostgreSqlV2Source",
                                "query": "SELECT \n    schemaname,\n    tablename\nFROM pg_tables \nWHERE schemaname = 'collect'\n--    AND (tablename LIKE 'cc_%' OR tablename = 'products_01_on')\n    AND (tablename = 'cc_io33_t')\nORDER BY tablename;",
                                "queryTimeout": "04:00:00"
                            },
                            "dataset": {
                                "referenceName": "Canna_PostgreSQL_Collect_Tables",
                                "type": "DatasetReference",
                                "parameters": {
                                    "SchemaName": "@pipeline().parameters.SchemaName",
                                    "TableName": "@pipeline().parameters.TableName"
                                }
                            },
                            "firstRowOnly": false
                        }
                    },
                    {
                        "name": "ForEach_Collect_Table",
                        "description": "Iterate through each Collect table",
                        "type": "ForEach",
                        "dependsOn": [
                            {
                                "activity": "Get_Collect_Tables",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "userProperties": [],
                        "typeProperties": {
                            "items": {
                                "value": "@activity('Get_Collect_Tables').output.value",
                                "type": "Expression"
                            },
                            "isSequential": false,
                            "batchCount": 1,
                            "activities": [
                                {
                                    "name": "Execute_Table_Validation_Pipeline",
                                    "description": "Processes individual tables with full validation pipeline",
                                    "type": "ExecutePipeline",
                                    "dependsOn": [],
                                    "policy": {
                                        "secureInput": false
                                    },
                                    "userProperties": [],
                                    "typeProperties": {
                                        "pipeline": {
                                            "referenceName": "Collect_Table_With_Validation_JSON",
                                            "type": "PipelineReference"
                                        },
                                        "waitOnCompletion": true,
                                        "parameters": {
                                            "SourceDatabase": "collect",
                                            "SchemaName": {
                                                "value": "@item().schemaname",
                                                "type": "Expression"
                                            },
                                            "TableName": {
                                                "value": "@item().tablename",
                                                "type": "Expression"
                                            }
                                        }
                                    }
                                }
                            ]
                        }
                    }
                ],
                "policy": {
                    "elapsedTimeMetric": {}
                },
                "parameters": {
                    "SchemaName": {
                        "type": "string"
                    },
                    "TableName": {
                        "type": "string"
                    }
                },
                "variables": {
                    "PipelineStartTime": {
                        "type": "String"
                    },
                    "ValidationErrors": {
                        "type": "String"
                    },
                    "ProcessedTables": {
                        "type": "String"
                    }
                },
                "annotations": [],
                "lastPublishTime": "2025-09-18T14:27:22Z"
            },
            "dependsOn": [
                "[concat(variables('factoryId'), '/datasets/Canna_PostgreSQL_Collect_Tables')]",
                "[concat(variables('factoryId'), '/pipelines/Collect_Table_With_Validation_JSON')]"
            ]
        },
        {
            "name": "[concat(parameters('factoryName'), '/Collect_Pipeline_JSON_Incremental')]",
            "type": "Microsoft.DataFactory/factories/pipelines",
            "apiVersion": "2018-06-01",
            "properties": {
                "activities": [
                    {
                        "name": "Set_Pipeline_Start_Time",
                        "description": "Set the start time of when the pipeline runs",
                        "type": "SetVariable",
                        "dependsOn": [
                            {
                                "activity": "Initialize_Watermark_Table",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "variableName": "PipelineStartTime",
                            "value": {
                                "value": "@formatDateTime(utcnow(), 'yyyy-MM-dd')",
                                "type": "Expression"
                            }
                        }
                    },
                    {
                        "name": "Get_Tables_With_Watermarks",
                        "type": "Lookup",
                        "dependsOn": [
                            {
                                "activity": "Set_Pipeline_Start_Time",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "source": {
                                "type": "SnowflakeV2Source",
                                "query": "SELECT \n    table_name as table_name,\n    watermark_column as watermark_column,\n    COALESCE(last_watermark, '2000-01-01 00:00:00') as last_watermark,\n    'collect' as schemaname  -- Add this since you need it\nFROM CANNACOLLECTIVE_COLLECT.UTILITY.WATERMARK_CONTROL",
                                "exportSettings": {
                                    "type": "SnowflakeExportCopyCommand"
                                }
                            },
                            "dataset": {
                                "referenceName": "Snowflake_Collect_Bronze",
                                "type": "DatasetReference",
                                "parameters": {}
                            },
                            "firstRowOnly": false
                        }
                    },
                    {
                        "name": "ForEach_Incremental_Table",
                        "type": "ForEach",
                        "dependsOn": [
                            {
                                "activity": "Get_Tables_With_Watermarks",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "userProperties": [],
                        "typeProperties": {
                            "items": {
                                "value": "@activity('Get_Tables_With_Watermarks').output.value",
                                "type": "Expression"
                            },
                            "isSequential": true,
                            "activities": [
                                {
                                    "name": "Collect_Table_With_Validation_Incremental_JSON",
                                    "type": "ExecutePipeline",
                                    "dependsOn": [],
                                    "policy": {
                                        "secureInput": false
                                    },
                                    "userProperties": [],
                                    "typeProperties": {
                                        "pipeline": {
                                            "referenceName": "Collect_Table_With_Validation_Incremental_JSON",
                                            "type": "PipelineReference"
                                        },
                                        "waitOnCompletion": true,
                                        "parameters": {}
                                    }
                                }
                            ]
                        }
                    },
                    {
                        "name": "Initialize_Watermark_Table",
                        "type": "Script",
                        "dependsOn": [],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "linkedServiceName": {
                            "referenceName": "Canna_Snowflake_Collect",
                            "type": "LinkedServiceReference"
                        },
                        "typeProperties": {
                            "scripts": [
                                {
                                    "type": "Query",
                                    "text": "CREATE TABLE IF NOT EXISTS CANNACOLLECTIVE_COLLECT.UTILITY.WATERMARK_CONTROL (\n    table_name STRING,\n    watermark_column STRING,\n    last_watermark TIMESTAMP_NTZ,\n    updated_at TIMESTAMP_NTZ DEFAULT CURRENT_TIMESTAMP()\n);\n\n-- Insert initial records if they don't exist\nINSERT INTO CANNACOLLECTIVE_COLLECT.UTILITY.WATERMARK_CONTROL (table_name, watermark_column, last_watermark)\nSELECT table_name, watermark_column, last_watermark FROM (\n    SELECT 'cc_integrator_t' as table_name, 'tm' as watermark_column, '2000-01-01 00:00:00'::TIMESTAMP_NTZ as last_watermark\n    UNION ALL\n    SELECT 'cc_location_t' as table_name, 'tm' as watermark_column, '2000-01-01 00:00:00'::TIMESTAMP_NTZ as last_watermark\n    UNION ALL\n    SELECT 'cc_po33_t' as table_name, 'tm' as watermark_column, '2000-01-01 00:00:00'::TIMESTAMP_NTZ as last_watermark\n\n) source\nWHERE NOT EXISTS (\n    SELECT 1 FROM CANNACOLLECTIVE_COLLECT.UTILITY.WATERMARK_CONTROL wc \n    WHERE wc.table_name = source.table_name\n);"
                                }
                            ],
                            "scriptBlockExecutionTimeout": "02:00:00"
                        }
                    }
                ],
                "policy": {
                    "elapsedTimeMetric": {}
                },
                "parameters": {
                    "SchemaName": {
                        "type": "string"
                    },
                    "TableName": {
                        "type": "string"
                    }
                },
                "variables": {
                    "PipelineStartTime": {
                        "type": "String"
                    },
                    "ValidationErrors": {
                        "type": "String"
                    },
                    "ProcessedTables": {
                        "type": "String"
                    }
                },
                "folder": {
                    "name": "Archive"
                },
                "annotations": [],
                "lastPublishTime": "2025-09-18T14:27:22Z"
            },
            "dependsOn": [
                "[concat(variables('factoryId'), '/datasets/Snowflake_Collect_Bronze')]",
                "[concat(variables('factoryId'), '/linkedServices/Canna_Snowflake_Collect')]",
                "[concat(variables('factoryId'), '/pipelines/Collect_Table_With_Validation_Incremental_JSON')]"
            ]
        },
        {
            "name": "[concat(parameters('factoryName'), '/Collect_Pipeline_JSON_Incremental_V4')]",
            "type": "Microsoft.DataFactory/factories/pipelines",
            "apiVersion": "2018-06-01",
            "properties": {
                "activities": [
                    {
                        "name": "Set_Pipeline_Start_Time",
                        "description": "Set the start time of when the pipeline runs",
                        "type": "SetVariable",
                        "dependsOn": [],
                        "policy": {
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "variableName": "PipelineStartTime",
                            "value": {
                                "value": "@formatDateTime(utcnow(), 'yyyy-MM-dd')",
                                "type": "Expression"
                            }
                        }
                    },
                    {
                        "name": "ForEach_Incremental_Table",
                        "type": "ForEach",
                        "dependsOn": [
                            {
                                "activity": "Get_Collect_Tables",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "userProperties": [],
                        "typeProperties": {
                            "items": {
                                "value": "@activity('Get_Collect_Tables').output.value",
                                "type": "Expression"
                            },
                            "isSequential": true,
                            "activities": [
                                {
                                    "name": "Execute_Incremental_Load",
                                    "type": "ExecutePipeline",
                                    "dependsOn": [],
                                    "policy": {
                                        "secureInput": false
                                    },
                                    "userProperties": [],
                                    "typeProperties": {
                                        "pipeline": {
                                            "referenceName": "Collect_Table_With_Validation__Incremental_JSON_V4",
                                            "type": "PipelineReference"
                                        },
                                        "waitOnCompletion": true,
                                        "parameters": {
                                            "SourceDatabase": "collect",
                                            "SchemaName": "collect",
                                            "TableName": {
                                                "value": "@item().tablename",
                                                "type": "Expression"
                                            },
                                            "WatermarkColumn": {
                                                "value": "@item().watermark_column",
                                                "type": "Expression"
                                            },
                                            "LastWatermark": {
                                                "value": "@item().last_watermark",
                                                "type": "Expression"
                                            },
                                            "RunDate": {
                                                "value": "@variables('PipelineStartTime')",
                                                "type": "Expression"
                                            }
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    {
                        "name": "Get_Collect_Tables",
                        "description": "Get all tables in collect database",
                        "type": "Lookup",
                        "dependsOn": [
                            {
                                "activity": "Set_Pipeline_Start_Time",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "source": {
                                "type": "PostgreSqlV2Source",
                                "query": "SELECT \n    'collect' as schemaname,\n    t.table_name as tablename,\n    'tm' as watermark_column,\n    COALESCE(w.last_watermark, '2000-01-01 00:00:00'::timestamp) as last_watermark\nFROM (\n    -- List the tables you want to process this run\n    VALUES \n    ('cc_integrator_t')\n) t(table_name)\nLEFT JOIN collect.watermark_control w ON t.table_name = w.table_name",
                                "queryTimeout": "02:00:00"
                            },
                            "dataset": {
                                "referenceName": "Canna_PostgreSQL_Collect_Tables",
                                "type": "DatasetReference",
                                "parameters": {
                                    "SchemaName": "@pipeline().parameters.SchemaName",
                                    "TableName": "@pipeline().parameters.TableName"
                                }
                            },
                            "firstRowOnly": false
                        }
                    }
                ],
                "policy": {
                    "elapsedTimeMetric": {}
                },
                "parameters": {
                    "SchemaName": {
                        "type": "string"
                    },
                    "TableName": {
                        "type": "string"
                    }
                },
                "variables": {
                    "PipelineStartTime": {
                        "type": "String"
                    },
                    "ValidationErrors": {
                        "type": "String"
                    },
                    "ProcessedTables": {
                        "type": "String"
                    }
                },
                "folder": {
                    "name": "Archive"
                },
                "annotations": [],
                "lastPublishTime": "2025-09-18T14:27:22Z"
            },
            "dependsOn": [
                "[concat(variables('factoryId'), '/datasets/Canna_PostgreSQL_Collect_Tables')]",
                "[concat(variables('factoryId'), '/pipelines/Collect_Table_With_Validation__Incremental_JSON_V4')]"
            ]
        },
        {
            "name": "[concat(parameters('factoryName'), '/Collect_Pipeline_JSON_Incremental_V4_Test')]",
            "type": "Microsoft.DataFactory/factories/pipelines",
            "apiVersion": "2018-06-01",
            "properties": {
                "activities": [
                    {
                        "name": "Set_Pipeline_Start_Time",
                        "description": "Set the start time of when the pipeline runs",
                        "type": "SetVariable",
                        "dependsOn": [],
                        "policy": {
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "variableName": "PipelineStartTime",
                            "value": {
                                "value": "@formatDateTime(utcnow(), 'yyyy-MM-dd')",
                                "type": "Expression"
                            }
                        }
                    },
                    {
                        "name": "ForEach_Incremental_Table",
                        "type": "ForEach",
                        "dependsOn": [
                            {
                                "activity": "Get_Collect_Tables",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "userProperties": [],
                        "typeProperties": {
                            "items": {
                                "value": "@activity('Get_Collect_Tables').output.value",
                                "type": "Expression"
                            },
                            "isSequential": true,
                            "activities": [
                                {
                                    "name": "Execute_Incremental_Load",
                                    "type": "ExecutePipeline",
                                    "dependsOn": [],
                                    "policy": {
                                        "secureInput": false
                                    },
                                    "userProperties": [],
                                    "typeProperties": {
                                        "pipeline": {
                                            "referenceName": "Collect_Table_With_Validation__Incremental_JSON_V4_Test",
                                            "type": "PipelineReference"
                                        },
                                        "waitOnCompletion": true,
                                        "parameters": {
                                            "SourceDatabase": "collect",
                                            "SchemaName": "collect",
                                            "TableName": {
                                                "value": "@item().tablename",
                                                "type": "Expression"
                                            },
                                            "WatermarkColumn": {
                                                "value": "@item().watermark_column",
                                                "type": "Expression"
                                            },
                                            "LastWatermark": {
                                                "value": "@item().last_watermark",
                                                "type": "Expression"
                                            },
                                            "RunDate": {
                                                "value": "@variables('PipelineStartTime')",
                                                "type": "Expression"
                                            }
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    {
                        "name": "Get_Collect_Tables",
                        "description": "Get all tables in collect database",
                        "type": "Lookup",
                        "dependsOn": [
                            {
                                "activity": "Set_Pipeline_Start_Time",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "source": {
                                "type": "PostgreSqlV2Source",
                                "query": "SELECT \n    'collect' as schemaname,\n    t.table_name as tablename,\n    'tm' as watermark_column,\n    w.last_watermark\nFROM (\n    VALUES \n    ('cc_catalog_t')\n) t(table_name)\nINNER JOIN collect.watermark_control w ON t.table_name = w.table_name",
                                "queryTimeout": "02:00:00"
                            },
                            "dataset": {
                                "referenceName": "Canna_PostgreSQL_Collect_Tables",
                                "type": "DatasetReference",
                                "parameters": {
                                    "SchemaName": "@pipeline().parameters.SchemaName",
                                    "TableName": "@pipeline().parameters.TableName"
                                }
                            },
                            "firstRowOnly": false
                        }
                    }
                ],
                "policy": {
                    "elapsedTimeMetric": {}
                },
                "parameters": {
                    "SchemaName": {
                        "type": "string"
                    },
                    "TableName": {
                        "type": "string"
                    }
                },
                "variables": {
                    "PipelineStartTime": {
                        "type": "String"
                    },
                    "ValidationErrors": {
                        "type": "String"
                    },
                    "ProcessedTables": {
                        "type": "String"
                    }
                },
                "folder": {
                    "name": "Archive"
                },
                "annotations": [],
                "lastPublishTime": "2025-09-18T14:27:22Z"
            },
            "dependsOn": [
                "[concat(variables('factoryId'), '/datasets/Canna_PostgreSQL_Collect_Tables')]",
                "[concat(variables('factoryId'), '/pipelines/Collect_Table_With_Validation__Incremental_JSON_V4_Test')]"
            ]
        },
        {
            "name": "[concat(parameters('factoryName'), '/Collect_Pipeline_JSON_LARGE_TABLE_SETTINGS')]",
            "type": "Microsoft.DataFactory/factories/pipelines",
            "apiVersion": "2018-06-01",
            "properties": {
                "activities": [
                    {
                        "name": "Set_Pipeline_Start_Time",
                        "description": "Set the start time of when the pipeline runs",
                        "type": "SetVariable",
                        "dependsOn": [],
                        "policy": {
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "variableName": "PipelineStartTime",
                            "value": {
                                "value": "@utcnow()",
                                "type": "Expression"
                            }
                        }
                    },
                    {
                        "name": "Get_Collect_Tables",
                        "description": "Get all tables in collect database",
                        "type": "Lookup",
                        "dependsOn": [
                            {
                                "activity": "Set_Pipeline_Start_Time",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "source": {
                                "type": "PostgreSqlV2Source",
                                "query": "SELECT \n    schemaname,\n    tablename\nFROM pg_tables \nWHERE schemaname = 'collect'\n    --AND tablename LIKE 'cc_%'\n    --AND tablename = 'cc_integrator_t'\n    --AND (tablename = 'cc_integrator_t' OR tablename = 'cc_location_t')\n    AND tablename = 'products_01_on'\nORDER BY tablename;",
                                "queryTimeout": "02:00:00"
                            },
                            "dataset": {
                                "referenceName": "Canna_PostgreSQL_Collect_Tables",
                                "type": "DatasetReference",
                                "parameters": {
                                    "SchemaName": "@pipeline().parameters.SchemaName",
                                    "TableName": "@pipeline().parameters.TableName"
                                }
                            },
                            "firstRowOnly": false
                        }
                    },
                    {
                        "name": "ForEach_Collect_Table",
                        "description": "Iterate through each Collect table",
                        "type": "ForEach",
                        "dependsOn": [
                            {
                                "activity": "Get_Collect_Tables",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "userProperties": [],
                        "typeProperties": {
                            "items": {
                                "value": "@activity('Get_Collect_Tables').output.value",
                                "type": "Expression"
                            },
                            "isSequential": false,
                            "batchCount": 1,
                            "activities": [
                                {
                                    "name": "Execute_Table_Validation_Pipeline",
                                    "description": "Processes individual tables with full validation pipeline",
                                    "type": "ExecutePipeline",
                                    "dependsOn": [],
                                    "policy": {
                                        "secureInput": false
                                    },
                                    "userProperties": [],
                                    "typeProperties": {
                                        "pipeline": {
                                            "referenceName": "Collect_Table_With_Validation_JSON_LARGE_TABLE_SETTINGS",
                                            "type": "PipelineReference"
                                        },
                                        "waitOnCompletion": true,
                                        "parameters": {
                                            "SourceDatabase": "collect",
                                            "SchemaName": {
                                                "value": "@item().schemaname",
                                                "type": "Expression"
                                            },
                                            "TableName": {
                                                "value": "@item().tablename",
                                                "type": "Expression"
                                            }
                                        }
                                    }
                                }
                            ]
                        }
                    }
                ],
                "policy": {
                    "elapsedTimeMetric": {}
                },
                "parameters": {
                    "SchemaName": {
                        "type": "string"
                    },
                    "TableName": {
                        "type": "string"
                    }
                },
                "variables": {
                    "PipelineStartTime": {
                        "type": "String"
                    },
                    "ValidationErrors": {
                        "type": "String"
                    },
                    "ProcessedTables": {
                        "type": "String"
                    }
                },
                "folder": {
                    "name": "Archive"
                },
                "annotations": [],
                "lastPublishTime": "2025-09-18T14:27:22Z"
            },
            "dependsOn": [
                "[concat(variables('factoryId'), '/datasets/Canna_PostgreSQL_Collect_Tables')]",
                "[concat(variables('factoryId'), '/pipelines/Collect_Table_With_Validation_JSON_LARGE_TABLE_SETTINGS')]"
            ]
        },
        {
            "name": "[concat(parameters('factoryName'), '/Collect_Pipeline_Parquet')]",
            "type": "Microsoft.DataFactory/factories/pipelines",
            "apiVersion": "2018-06-01",
            "properties": {
                "activities": [
                    {
                        "name": "Set_Pipeline_Start_Time",
                        "description": "Set the start time of when the pipeline runs",
                        "type": "SetVariable",
                        "dependsOn": [],
                        "policy": {
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "variableName": "PipelineStartTime",
                            "value": {
                                "value": "@utcnow()",
                                "type": "Expression"
                            }
                        }
                    },
                    {
                        "name": "Get_Collect_Tables",
                        "description": "Get all tables in collect database",
                        "type": "Lookup",
                        "dependsOn": [
                            {
                                "activity": "Set_Pipeline_Start_Time",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "source": {
                                "type": "PostgreSqlV2Source",
                                "query": "SELECT \n    schemaname,\n    tablename\nFROM pg_tables \nWHERE schemaname = 'collect'\n--    AND tablename LIKE 'cc_%'\n    AND tablename = 'cc_integrator_t'\nORDER BY tablename;",
                                "queryTimeout": "02:00:00"
                            },
                            "dataset": {
                                "referenceName": "Canna_PostgreSQL_Collect_Tables",
                                "type": "DatasetReference",
                                "parameters": {
                                    "SchemaName": "@pipeline().parameters.SchemaName",
                                    "TableName": "@pipeline().parameters.TableName"
                                }
                            },
                            "firstRowOnly": false
                        }
                    },
                    {
                        "name": "ForEach_Collect_Table",
                        "description": "Iterate through each Collect table",
                        "type": "ForEach",
                        "dependsOn": [
                            {
                                "activity": "Get_Collect_Tables",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "userProperties": [],
                        "typeProperties": {
                            "items": {
                                "value": "@activity('Get_Collect_Tables').output.value",
                                "type": "Expression"
                            },
                            "isSequential": false,
                            "batchCount": 5,
                            "activities": [
                                {
                                    "name": "Execute_Table_Validation_Pipeline",
                                    "type": "ExecutePipeline",
                                    "dependsOn": [],
                                    "policy": {
                                        "secureInput": false
                                    },
                                    "userProperties": [],
                                    "typeProperties": {
                                        "pipeline": {
                                            "referenceName": "Copy_Table_With_Validation_Parquet",
                                            "type": "PipelineReference"
                                        },
                                        "waitOnCompletion": true,
                                        "parameters": {
                                            "SourceDatabase": "collect",
                                            "SchemaName": {
                                                "value": "@item().schemaname",
                                                "type": "Expression"
                                            },
                                            "TableName": {
                                                "value": "@item().tablename",
                                                "type": "Expression"
                                            }
                                        }
                                    }
                                }
                            ]
                        }
                    }
                ],
                "policy": {
                    "elapsedTimeMetric": {}
                },
                "parameters": {
                    "SchemaName": {
                        "type": "string"
                    },
                    "TableName": {
                        "type": "string"
                    }
                },
                "variables": {
                    "PipelineStartTime": {
                        "type": "String"
                    },
                    "ValidationErrors": {
                        "type": "String"
                    },
                    "ProcessedTables": {
                        "type": "String"
                    }
                },
                "folder": {
                    "name": "Archive"
                },
                "annotations": [],
                "lastPublishTime": "2025-09-17T15:47:12Z"
            },
            "dependsOn": [
                "[concat(variables('factoryId'), '/datasets/Canna_PostgreSQL_Collect_Tables')]",
                "[concat(variables('factoryId'), '/pipelines/Copy_Table_With_Validation_Parquet')]"
            ]
        },
        {
            "name": "[concat(parameters('factoryName'), '/Collect_Table_With_Validation_Incremental_JSON')]",
            "type": "Microsoft.DataFactory/factories/pipelines",
            "apiVersion": "2018-06-01",
            "properties": {
                "activities": [
                    {
                        "name": "Get_Source_Row_Count",
                        "description": "Get Postgres SQL table row count ",
                        "type": "Lookup",
                        "dependsOn": [
                            {
                                "activity": "Set_Watermark_Column",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "source": {
                                "type": "PostgreSqlV2Source",
                                "query": {
                                    "value": "@concat('SELECT COUNT(*) as row_count FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName)",
                                    "type": "Expression"
                                },
                                "queryTimeout": "02:00:00"
                            },
                            "dataset": {
                                "referenceName": "Canna_PostgreSQL_Collect_Tables",
                                "type": "DatasetReference",
                                "parameters": {
                                    "SchemaName": "@pipeline().parameters.SchemaName",
                                    "TableName": "@pipeline().parameters.TableName"
                                }
                            }
                        }
                    },
                    {
                        "name": "Copy_To_ADLS",
                        "description": "Copy raw Postgres data into ADLS",
                        "type": "Copy",
                        "dependsOn": [
                            {
                                "activity": "No_tm_Tables",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "source": {
                                "type": "PostgreSqlV2Source",
                                "query": {
                                    "value": "@if(equals(variables('WatermarkCol'), 'none'),\n  concat('SELECT * FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName),\n  if(equals(variables('LoadStrategy'), 'ROLLING_30DAY'),\n    if(lessOrEquals(formatDateTime(utcnow(), 'yyyy-MM-dd'), '2025-12-01'),\n      if(equals(pipeline().parameters.TableName, 'cc_io33_t'),\n        concat('SELECT * FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName, ' WHERE ', variables('WatermarkCol'), ' > ''2025-11-05 00:00:00'''),\n        concat('SELECT * FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName, ' WHERE ', variables('WatermarkCol'), ' > ''2025-11-02 00:00:00''')\n      ),\n      concat('SELECT * FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName, ' WHERE ', variables('WatermarkCol'), ' >= CURRENT_DATE - INTERVAL ''30 days''')\n    ),\n    if(equals(variables('LoadStrategy'), 'FULL_RELOAD'),\n      concat('SELECT * FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName),\n      concat('SELECT * FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName, ' WHERE ', variables('WatermarkCol'), ' > ''', pipeline().parameters.LastWatermark, '''')\n    )\n  )\n)",
                                    "type": "Expression"
                                },
                                "queryTimeout": "02:00:00"
                            },
                            "sink": {
                                "type": "JsonSink",
                                "storeSettings": {
                                    "type": "AzureBlobFSWriteSettings"
                                },
                                "formatSettings": {
                                    "type": "JsonWriteSettings"
                                }
                            },
                            "enableStaging": false,
                            "parallelCopies": {
                                "value": "@int(variables('ParallelCopies'))",
                                "type": "Expression"
                            },
                            "enableSkipIncompatibleRow": false,
                            "validateDataConsistency": true,
                            "logSettings": {
                                "enableCopyActivityLog": true,
                                "copyActivityLogSettings": {
                                    "logLevel": "Info",
                                    "enableReliableLogging": false
                                },
                                "logLocationSettings": {
                                    "linkedServiceName": {
                                        "referenceName": "Canna_ADLS",
                                        "type": "LinkedServiceReference"
                                    },
                                    "path": "logs/copy-activity"
                                }
                            },
                            "dataIntegrationUnits": {
                                "value": "@int(variables('DataIntegrationUnits'))",
                                "type": "Expression"
                            }
                        },
                        "inputs": [
                            {
                                "referenceName": "Canna_PostgreSQL_Collect_Tables",
                                "type": "DatasetReference",
                                "parameters": {
                                    "SchemaName": "@pipeline().parameters.SchemaName",
                                    "TableName": "@pipeline().parameters.TableName"
                                }
                            }
                        ],
                        "outputs": [
                            {
                                "referenceName": "ADLS_JSON",
                                "type": "DatasetReference",
                                "parameters": {
                                    "Container": "raw",
                                    "Directory": {
                                        "value": "@concat(\n  pipeline().parameters.SourceDatabase, '/',\n  pipeline().parameters.TableName, '/',\n  pipeline().parameters.RunDate, '/',\n  pipeline().RunId         \n)\n",
                                        "type": "Expression"
                                    },
                                    "FileName": {
                                        "value": "@concat(pipeline().parameters.SchemaName, '_', pipeline().parameters.TableName, '_', formatDateTime(utcNow(), 'yyyyMMdd_HHmmss'), '_', variables('LoadStrategy'), '.json')",
                                        "type": "Expression"
                                    }
                                }
                            }
                        ]
                    },
                    {
                        "name": "Validate_ADLS_File",
                        "description": "Verify the JSON file was created successfully in ADLS",
                        "type": "GetMetadata",
                        "dependsOn": [
                            {
                                "activity": "Copy_To_ADLS",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "dataset": {
                                "referenceName": "ADLS_JSON",
                                "type": "DatasetReference",
                                "parameters": {
                                    "Container": "raw",
                                    "Directory": "@concat(pipeline().parameters.SourceDatabase, '/', formatDateTime(utcnow(), 'yyyy-MM-dd'))",
                                    "FileName": "@concat(pipeline().parameters.SchemaName, '_', pipeline().parameters.TableName, '_', formatDateTime(utcnow(), 'yyyyMMddHHmmss'), '.json')"
                                }
                            },
                            "fieldList": [
                                "exists",
                                "childItems"
                            ],
                            "storeSettings": {
                                "type": "AzureBlobFSReadSettings",
                                "recursive": true,
                                "enablePartitionDiscovery": false
                            },
                            "formatSettings": {
                                "type": "JsonReadSettings"
                            }
                        }
                    },
                    {
                        "name": "Load_To_Snowflake_Bronze",
                        "description": "Load ADLS data into Snowflake Bronze layer",
                        "type": "Script",
                        "dependsOn": [
                            {
                                "activity": "Delete_30_Day_Data",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "linkedServiceName": {
                            "referenceName": "Canna_Snowflake_Collect",
                            "type": "LinkedServiceReference"
                        },
                        "typeProperties": {
                            "scripts": [
                                {
                                    "type": "Query",
                                    "text": {
                                        "value": "@concat(\n  'ALTER SESSION SET TIMEZONE = ''UTC''; ',\n  'USE SCHEMA BRONZE; ',\n\n  'COPY INTO ', \n  if(endsWith(pipeline().parameters.TableName, '_t'), replace(pipeline().parameters.TableName, '_t', ''), pipeline().parameters.TableName), ' (data) ',\n  'FROM @SOURCE_DB.BRONZE.ADLS_RAW_STAGE/',\n      pipeline().parameters.SourceDatabase, '/', pipeline().parameters.TableName, '/',\n      pipeline().parameters.RunDate, '/', pipeline().RunId, '/ ',\n  'PATTERN = ''', '.*', variables('LoadStrategy'), '.*', ''' ',\n  'FILE_FORMAT = (TYPE = JSON) ',\n  'FORCE = ', if(equals(variables('LoadStrategy'), 'FULL_RELOAD'), 'TRUE', 'FALSE'), ' ',\n  'ON_ERROR = ''CONTINUE'';',\n\n  'SELECT COUNT(*) AS rows_loaded, ''', variables('LoadStrategy'), ''' AS strategy_used ',\n  'FROM ', \n  if(endsWith(pipeline().parameters.TableName, '_t'), replace(pipeline().parameters.TableName, '_t', ''), pipeline().parameters.TableName), \n  ' WHERE data IS NOT NULL;'\n)",
                                        "type": "Expression"
                                    }
                                }
                            ],
                            "scriptBlockExecutionTimeout": "02:00:00"
                        }
                    },
                    {
                        "name": "Get_Snowflake_Row_Count",
                        "description": "Get loaded row count from Snowflake Bronze table",
                        "type": "Lookup",
                        "dependsOn": [
                            {
                                "activity": "Load_To_Snowflake_Bronze",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "source": {
                                "type": "SnowflakeV2Source",
                                "query": {
                                    "value": "SELECT COUNT(*) as snowflake_count \nFROM SOURCE_DB.BRONZE.@{if(endsWith(pipeline().parameters.TableName, '_t'), replace(pipeline().parameters.TableName, '_t', ''), pipeline().parameters.TableName)};",
                                    "type": "Expression"
                                },
                                "exportSettings": {
                                    "type": "SnowflakeExportCopyCommand"
                                }
                            },
                            "dataset": {
                                "referenceName": "Snowflake_Collect_Bronze",
                                "type": "DatasetReference",
                                "parameters": {}
                            }
                        }
                    },
                    {
                        "name": "Validate_Row_Count_Match",
                        "description": "Compare Postgres vs Snowflake row counts",
                        "type": "IfCondition",
                        "dependsOn": [
                            {
                                "activity": "Get_Snowflake_Row_Count",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "userProperties": [],
                        "typeProperties": {
                            "expression": {
                                "value": "@if(or(equals(variables('LoadStrategy'), 'ROLLING_30DAY'), equals(variables('LoadStrategy'), 'FULL_RELOAD')), true, equals(string(activity('Get_Source_Row_Count').output.firstRow.row_count), string(activity('Get_Snowflake_Row_Count').output.firstRow.SNOWFLAKE_COUNT)))",
                                "type": "Expression"
                            },
                            "ifFalseActivities": [
                                {
                                    "name": "Set_Validation_Error",
                                    "description": "Mark validation as failed due to row count mismatch",
                                    "type": "SetVariable",
                                    "dependsOn": [],
                                    "policy": {
                                        "secureOutput": false,
                                        "secureInput": false
                                    },
                                    "userProperties": [],
                                    "typeProperties": {
                                        "variableName": "ValidationStatus",
                                        "value": "ROW_COUNT_MISMATCH"
                                    }
                                }
                            ],
                            "ifTrueActivities": [
                                {
                                    "name": "Set_Validation_Status",
                                    "description": "Mark validation as successful",
                                    "type": "SetVariable",
                                    "dependsOn": [],
                                    "policy": {
                                        "secureOutput": false,
                                        "secureInput": false
                                    },
                                    "userProperties": [],
                                    "typeProperties": {
                                        "variableName": "ValidationStatus",
                                        "value": "SUCCESS"
                                    }
                                }
                            ]
                        }
                    },
                    {
                        "name": "Check_Null_Values",
                        "description": "Count null values in key columns",
                        "type": "Lookup",
                        "dependsOn": [
                            {
                                "activity": "Load_To_Snowflake_Bronze",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "source": {
                                "type": "SnowflakeV2Source",
                                "query": {
                                    "value": "SELECT \n    SUM(CASE WHEN data:id IS NULL THEN 1 ELSE 0 END) as null_ids,\n    SUM(CASE WHEN data:name IS NULL THEN 1 ELSE 0 END) as null_names\nFROM SOURCE_DB.BRONZE.@{if(endsWith(pipeline().parameters.TableName, '_t'), replace(pipeline().parameters.TableName, '_t', ''), pipeline().parameters.TableName)}",
                                    "type": "Expression"
                                },
                                "exportSettings": {
                                    "type": "SnowflakeExportCopyCommand"
                                }
                            },
                            "dataset": {
                                "referenceName": "Snowflake_Collect_Bronze",
                                "type": "DatasetReference",
                                "parameters": {}
                            }
                        }
                    },
                    {
                        "name": "Log_Pipeline_Summary",
                        "description": "Insert execution summary into UTILITY.PIPELINE_EXECUTION_LOG",
                        "type": "Script",
                        "dependsOn": [
                            {
                                "activity": "Validate_Row_Count_Match",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            },
                            {
                                "activity": "Check_Null_Values",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "linkedServiceName": {
                            "referenceName": "Canna_Snowflake_Collect",
                            "type": "LinkedServiceReference"
                        },
                        "typeProperties": {
                            "scripts": [
                                {
                                    "type": "Query",
                                    "text": {
                                        "value": "@concat(\n  'INSERT INTO SOURCE_DB.UTILITY.PIPELINE_EXECUTION_LOG VALUES (''',\n  pipeline().RunId, ''', ''',\n  pipeline().parameters.TableName, ''', ''',\n  formatDateTime(utcnow(), 'yyyy-MM-dd'), ''', ''',\n  utcnow(), ''', ',\n  if(empty(string(activity('Get_Source_Row_Count').output.firstRow.row_count)), '0', string(activity('Get_Source_Row_Count').output.firstRow.row_count)), ', ',\n  if(empty(string(activity('Get_Snowflake_Row_Count').output.firstRow.SNOWFLAKE_COUNT)), '0', string(activity('Get_Snowflake_Row_Count').output.firstRow.SNOWFLAKE_COUNT)), ', ',\n  if(equals(variables('ValidationStatus'), 'SUCCESS'), 'TRUE', 'FALSE'), ', ',\n  if(empty(string(activity('Check_Duplicates').output.firstRow.duplicate_count)), '0', string(activity('Check_Duplicates').output.firstRow.duplicate_count)), ', ',\n  if(empty(string(activity('Check_Null_Values').output.firstRow.NULL_IDS)), '0', string(activity('Check_Null_Values').output.firstRow.NULL_IDS)), ', ',\n  if(empty(string(activity('Check_Null_Values').output.firstRow.NULL_NAMES)), '0', string(activity('Check_Null_Values').output.firstRow.NULL_NAMES)), ', ''',\n  variables('ValidationStatus'), ''', ',\n  '0', \n  ');'\n)",
                                        "type": "Expression"
                                    }
                                }
                            ],
                            "scriptBlockExecutionTimeout": "02:00:00"
                        }
                    },
                    {
                        "name": "Check_Duplicates",
                        "description": "Check for duplicate rows in the table",
                        "type": "Lookup",
                        "dependsOn": [
                            {
                                "activity": "Get_Source_Row_Count",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "source": {
                                "type": "PostgreSqlV2Source",
                                "query": {
                                    "value": "@if(equals(variables('LoadStrategy'), 'ROLLING_30DAY'),\n  if(lessOrEquals(formatDateTime(utcnow(), 'yyyy-MM-dd'), '2025-12-01'),\n    if(equals(pipeline().parameters.TableName, 'cc_io33_t'),\n      concat('SELECT (SELECT COUNT(*) FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName, ' WHERE ', variables('WatermarkCol'), ' > ''2025-11-05 00:00:00'') - (SELECT COUNT(*) FROM (SELECT DISTINCT * FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName, ' WHERE ', variables('WatermarkCol'), ' > ''2025-11-05 00:00:00'') t) as duplicate_count'),\n      concat('SELECT (SELECT COUNT(*) FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName, ' WHERE ', variables('WatermarkCol'), ' > ''2025-11-02 00:00:00'') - (SELECT COUNT(*) FROM (SELECT DISTINCT * FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName, ' WHERE ', variables('WatermarkCol'), ' > ''2025-11-02 00:00:00'') t) as duplicate_count')\n    ),\n    concat('SELECT (SELECT COUNT(*) FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName, ' WHERE ', variables('WatermarkCol'), ' >= CURRENT_DATE - INTERVAL ''30 days'') - (SELECT COUNT(*) FROM (SELECT DISTINCT * FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName, ' WHERE ', variables('WatermarkCol'), ' >= CURRENT_DATE - INTERVAL ''30 days'') t) as duplicate_count')\n  ),\n  concat('SELECT (SELECT COUNT(*) FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName, ') - (SELECT COUNT(*) FROM (SELECT DISTINCT * FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName, ') t) as duplicate_count')\n)",
                                    "type": "Expression"
                                },
                                "queryTimeout": "02:00:00"
                            },
                            "dataset": {
                                "referenceName": "Canna_PostgreSQL_Collect_Tables",
                                "type": "DatasetReference",
                                "parameters": {
                                    "SchemaName": "@pipeline().parameters.SchemaName",
                                    "TableName": "@pipeline().parameters.TableName"
                                }
                            }
                        }
                    },
                    {
                        "name": "Delete_30_Day_Data",
                        "type": "Script",
                        "dependsOn": [
                            {
                                "activity": "Validate_ADLS_File",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "linkedServiceName": {
                            "referenceName": "Canna_Snowflake_Collect",
                            "type": "LinkedServiceReference"
                        },
                        "typeProperties": {
                            "scripts": [
                                {
                                    "type": "Query",
                                    "text": {
                                        "value": "@concat(\n  'USE SCHEMA BRONZE; ',\n  'ALTER SESSION SET TIMEZONE = ''UTC''; ',\n  if(equals(variables('LoadStrategy'), 'ROLLING_30DAY'),\n    if(lessOrEquals(formatDateTime(utcnow(), 'yyyy-MM-dd'), '2025-12-01'),\n      if(equals(pipeline().parameters.TableName, 'cc_io33_t'),\n        concat('DELETE FROM ', \n          if(endsWith(pipeline().parameters.TableName, '_t'), replace(pipeline().parameters.TableName, '_t', ''), pipeline().parameters.TableName), \n          ' WHERE TO_DATE(CONVERT_TIMEZONE(''UTC'', TRY_TO_TIMESTAMP_TZ(data:\"', variables('WatermarkCol'), '\"::string))) >= ''2025-11-05''; '),\n        concat('DELETE FROM ', \n          if(endsWith(pipeline().parameters.TableName, '_t'), replace(pipeline().parameters.TableName, '_t', ''), pipeline().parameters.TableName), \n          ' WHERE TO_DATE(CONVERT_TIMEZONE(''UTC'', TRY_TO_TIMESTAMP_TZ(data:\"', variables('WatermarkCol'), '\"::string))) >= ''2025-11-02''; ')\n      ),\n      concat('DELETE FROM ', \n        if(endsWith(pipeline().parameters.TableName, '_t'), replace(pipeline().parameters.TableName, '_t', ''), pipeline().parameters.TableName), \n        ' WHERE TO_DATE(CONVERT_TIMEZONE(''UTC'', TRY_TO_TIMESTAMP_TZ(data:\"', variables('WatermarkCol'), '\"::string))) >= DATEADD(day, -30, CURRENT_DATE()); ')\n    ),\n    if(equals(variables('LoadStrategy'), 'FULL_RELOAD'),\n      concat('TRUNCATE TABLE ', \n        if(endsWith(pipeline().parameters.TableName, '_t'), replace(pipeline().parameters.TableName, '_t', ''), pipeline().parameters.TableName), \n        '; '),\n      'SELECT ''No cleanup needed for incremental strategy'' as status; '\n    )\n  ),\n  'SELECT ''', variables('LoadStrategy'), ''' as strategy_applied;'\n)",
                                        "type": "Expression"
                                    }
                                }
                            ],
                            "scriptBlockExecutionTimeout": "02:00:00"
                        }
                    },
                    {
                        "name": "Get_Table_Strategy",
                        "type": "Lookup",
                        "dependsOn": [],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "source": {
                                "type": "SnowflakeV2Source",
                                "query": {
                                    "value": "SELECT \n       COALESCE(load_strategy, 'INCREMENTAL') as load_strategy,\n       COALESCE(parallel_copies, 8) as parallel_copies,\n       COALESCE(data_integration_units, 16) as data_integration_units,\n       COALESCE(watermark_column, 'tm') as watermark_column\n   FROM SOURCE_DB.UTILITY.TABLE_STRATEGY_CONFIG \n   WHERE table_name = '@{pipeline().parameters.TableName}'\n   AND is_active = TRUE",
                                    "type": "Expression"
                                },
                                "exportSettings": {
                                    "type": "SnowflakeExportCopyCommand"
                                }
                            },
                            "dataset": {
                                "referenceName": "Snowflake_Collect_Bronze",
                                "type": "DatasetReference",
                                "parameters": {}
                            }
                        }
                    },
                    {
                        "name": "Set_Strategy_From_Config",
                        "type": "SetVariable",
                        "dependsOn": [
                            {
                                "activity": "Get_Table_Strategy",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "variableName": "LoadStrategy",
                            "value": {
                                "value": "@activity('Get_Table_Strategy').output.firstRow.load_strategy",
                                "type": "Expression"
                            }
                        }
                    },
                    {
                        "name": "Set_Parallel_Copies",
                        "type": "SetVariable",
                        "dependsOn": [
                            {
                                "activity": "Set_Strategy_From_Config",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "variableName": "ParallelCopies",
                            "value": {
                                "value": "@string(activity('Get_Table_Strategy').output.firstRow.parallel_copies)",
                                "type": "Expression"
                            }
                        }
                    },
                    {
                        "name": "Set_DIU",
                        "type": "SetVariable",
                        "dependsOn": [
                            {
                                "activity": "Set_Parallel_Copies",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "variableName": "DataIntegrationUnits",
                            "value": {
                                "value": "@string(activity('Get_Table_Strategy').output.firstRow.data_integration_units)",
                                "type": "Expression"
                            }
                        }
                    },
                    {
                        "name": "Set_Watermark_Column",
                        "type": "SetVariable",
                        "dependsOn": [
                            {
                                "activity": "Set_DIU",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "variableName": "WatermarkCol",
                            "value": {
                                "value": "@activity('Get_Table_Strategy').output.firstRow.watermark_column",
                                "type": "Expression"
                            }
                        }
                    },
                    {
                        "name": "No_tm_Tables",
                        "type": "IfCondition",
                        "dependsOn": [
                            {
                                "activity": "Check_Duplicates",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "userProperties": [],
                        "typeProperties": {
                            "expression": {
                                "value": "@not(equals(variables('WatermarkCol'), 'none'))",
                                "type": "Expression"
                            },
                            "ifTrueActivities": [
                                {
                                    "name": "Get_Max_Watermark",
                                    "type": "Lookup",
                                    "dependsOn": [],
                                    "policy": {
                                        "timeout": "0.12:00:00",
                                        "retry": 0,
                                        "retryIntervalInSeconds": 30,
                                        "secureOutput": false,
                                        "secureInput": false
                                    },
                                    "userProperties": [],
                                    "typeProperties": {
                                        "source": {
                                            "type": "PostgreSqlV2Source",
                                            "query": {
                                                "value": "@concat('SELECT MAX(', variables('WatermarkCol'), ')::timestamp as max_watermark FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName)\n",
                                                "type": "Expression"
                                            },
                                            "queryTimeout": "02:00:00"
                                        },
                                        "dataset": {
                                            "referenceName": "Canna_PostgreSQL_Collect_Tables",
                                            "type": "DatasetReference",
                                            "parameters": {
                                                "SchemaName": "collect",
                                                "TableName": "cc_customers"
                                            }
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    {
                        "name": "Update_tm_Tables",
                        "type": "IfCondition",
                        "dependsOn": [
                            {
                                "activity": "Log_Pipeline_Summary",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "userProperties": [],
                        "typeProperties": {
                            "expression": {
                                "value": "@not(equals(variables('WatermarkCol'), 'none'))",
                                "type": "Expression"
                            },
                            "ifTrueActivities": [
                                {
                                    "name": "Update_Watermark",
                                    "type": "Lookup",
                                    "dependsOn": [],
                                    "policy": {
                                        "timeout": "0.12:00:00",
                                        "retry": 0,
                                        "retryIntervalInSeconds": 30,
                                        "secureOutput": false,
                                        "secureInput": false
                                    },
                                    "userProperties": [],
                                    "typeProperties": {
                                        "source": {
                                            "type": "PostgreSqlV2Source",
                                            "query": {
                                                "value": "WITH update_result AS (\n     INSERT INTO collect.watermark_control (table_name, last_watermark, updated_at)\n     VALUES (\n       '@{pipeline().parameters.TableName}',\n       '@{activity('Get_Max_Watermark').output.firstRow.max_watermark}'::timestamp,\n       CURRENT_TIMESTAMP\n     )\n     ON CONFLICT (table_name) \n     DO UPDATE SET \n       last_watermark = EXCLUDED.last_watermark,\n       updated_at = CURRENT_TIMESTAMP\n     RETURNING table_name\n   )\n   SELECT COUNT(*) as rows_updated FROM update_result;",
                                                "type": "Expression"
                                            },
                                            "queryTimeout": "02:00:00"
                                        },
                                        "dataset": {
                                            "referenceName": "Canna_PostgreSQL_Collect_Tables",
                                            "type": "DatasetReference",
                                            "parameters": {
                                                "SchemaName": "collect",
                                                "TableName": "cc_customers"
                                            }
                                        }
                                    }
                                }
                            ]
                        }
                    }
                ],
                "policy": {
                    "elapsedTimeMetric": {}
                },
                "parameters": {
                    "SourceDatabase": {
                        "type": "string",
                        "defaultValue": "collect"
                    },
                    "SchemaName": {
                        "type": "string",
                        "defaultValue": "collect"
                    },
                    "TableName": {
                        "type": "string"
                    },
                    "WatermarkColumn": {
                        "type": "string",
                        "defaultValue": "tm"
                    },
                    "LastWatermark": {
                        "type": "string",
                        "defaultValue": "2000-01-01 00:00:00"
                    },
                    "RunDate": {
                        "type": "string"
                    }
                },
                "variables": {
                    "ValidationStatus": {
                        "type": "String"
                    },
                    "LoadStrategy": {
                        "type": "String",
                        "defaultValue": "INCREMENTAL"
                    },
                    "ParallelCopies": {
                        "type": "String",
                        "defaultValue": "8"
                    },
                    "DataIntegrationUnits": {
                        "type": "String",
                        "defaultValue": "16"
                    },
                    "WatermarkCol": {
                        "type": "String",
                        "defaultValue": "tm"
                    }
                },
                "annotations": [],
                "lastPublishTime": "2025-09-18T14:21:00Z"
            },
            "dependsOn": [
                "[concat(variables('factoryId'), '/datasets/Canna_PostgreSQL_Collect_Tables')]",
                "[concat(variables('factoryId'), '/datasets/ADLS_JSON')]",
                "[concat(variables('factoryId'), '/linkedServices/Canna_Snowflake_Collect')]",
                "[concat(variables('factoryId'), '/datasets/Snowflake_Collect_Bronze')]",
                "[concat(variables('factoryId'), '/linkedServices/Canna_ADLS')]"
            ]
        },
        {
            "name": "[concat(parameters('factoryName'), '/Collect_Table_With_Validation_Incremental_JSON_Date')]",
            "type": "Microsoft.DataFactory/factories/pipelines",
            "apiVersion": "2018-06-01",
            "properties": {
                "activities": [
                    {
                        "name": "Get_Source_Row_Count",
                        "description": "Get Postgres SQL table row count ",
                        "type": "Lookup",
                        "dependsOn": [
                            {
                                "activity": "Set_Watermark_Column",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "source": {
                                "type": "PostgreSqlV2Source",
                                "query": {
                                    "value": "@concat('SELECT COUNT(*) as row_count FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName)",
                                    "type": "Expression"
                                },
                                "queryTimeout": "02:00:00"
                            },
                            "dataset": {
                                "referenceName": "Canna_PostgreSQL_Collect_Tables",
                                "type": "DatasetReference",
                                "parameters": {
                                    "SchemaName": "@pipeline().parameters.SchemaName",
                                    "TableName": "@pipeline().parameters.TableName"
                                }
                            }
                        }
                    },
                    {
                        "name": "Copy_To_ADLS",
                        "description": "Copy raw Postgres data into ADLS",
                        "type": "Copy",
                        "dependsOn": [
                            {
                                "activity": "No_tm_Tables",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "source": {
                                "type": "PostgreSqlV2Source",
                                "query": {
                                    "value": "@if(equals(variables('WatermarkCol'), 'none'),\n  concat('SELECT * FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName),\n  if(equals(variables('LoadStrategy'), 'ROLLING_30DAY'),\n    concat('SELECT * FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName, ' WHERE ', variables('WatermarkCol'), ' >= (''', pipeline().parameters.RunDate, '''::date - INTERVAL ''30 days'')'),\n    if(equals(variables('LoadStrategy'), 'FULL_RELOAD'),\n      concat('SELECT * FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName),\n      concat('SELECT * FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName, ' WHERE ', variables('WatermarkCol'), ' > ''', pipeline().parameters.LastWatermark, '''')\n    )\n  )\n)",
                                    "type": "Expression"
                                },
                                "queryTimeout": "02:00:00"
                            },
                            "sink": {
                                "type": "JsonSink",
                                "storeSettings": {
                                    "type": "AzureBlobFSWriteSettings"
                                },
                                "formatSettings": {
                                    "type": "JsonWriteSettings"
                                }
                            },
                            "enableStaging": false,
                            "parallelCopies": {
                                "value": "@int(variables('ParallelCopies'))",
                                "type": "Expression"
                            },
                            "enableSkipIncompatibleRow": false,
                            "validateDataConsistency": true,
                            "logSettings": {
                                "enableCopyActivityLog": true,
                                "copyActivityLogSettings": {
                                    "logLevel": "Info",
                                    "enableReliableLogging": false
                                },
                                "logLocationSettings": {
                                    "linkedServiceName": {
                                        "referenceName": "Canna_ADLS",
                                        "type": "LinkedServiceReference"
                                    },
                                    "path": "logs/copy-activity"
                                }
                            },
                            "dataIntegrationUnits": {
                                "value": "@int(variables('DataIntegrationUnits'))",
                                "type": "Expression"
                            }
                        },
                        "inputs": [
                            {
                                "referenceName": "Canna_PostgreSQL_Collect_Tables",
                                "type": "DatasetReference",
                                "parameters": {
                                    "SchemaName": "@pipeline().parameters.SchemaName",
                                    "TableName": "@pipeline().parameters.TableName"
                                }
                            }
                        ],
                        "outputs": [
                            {
                                "referenceName": "ADLS_JSON",
                                "type": "DatasetReference",
                                "parameters": {
                                    "Container": "raw",
                                    "Directory": {
                                        "value": "@concat(\n  pipeline().parameters.SourceDatabase, '/',\n  pipeline().parameters.TableName, '/',\n  pipeline().parameters.RunDate, '/',\n  pipeline().RunId         \n)\n",
                                        "type": "Expression"
                                    },
                                    "FileName": {
                                        "value": "@concat(pipeline().parameters.SchemaName, '_', pipeline().parameters.TableName, '_', formatDateTime(utcNow(), 'yyyyMMdd_HHmmss'), '_', variables('LoadStrategy'), '.json')",
                                        "type": "Expression"
                                    }
                                }
                            }
                        ]
                    },
                    {
                        "name": "Validate_ADLS_File",
                        "description": "Verify the JSON file was created successfully in ADLS",
                        "type": "GetMetadata",
                        "dependsOn": [
                            {
                                "activity": "Copy_To_ADLS",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "dataset": {
                                "referenceName": "ADLS_JSON",
                                "type": "DatasetReference",
                                "parameters": {
                                    "Container": "raw",
                                    "Directory": "@concat(pipeline().parameters.SourceDatabase, '/', formatDateTime(utcnow(), 'yyyy-MM-dd'))",
                                    "FileName": "@concat(pipeline().parameters.SchemaName, '_', pipeline().parameters.TableName, '_', formatDateTime(utcnow(), 'yyyyMMddHHmmss'), '.json')"
                                }
                            },
                            "fieldList": [
                                "exists",
                                "childItems"
                            ],
                            "storeSettings": {
                                "type": "AzureBlobFSReadSettings",
                                "recursive": true,
                                "enablePartitionDiscovery": false
                            },
                            "formatSettings": {
                                "type": "JsonReadSettings"
                            }
                        }
                    },
                    {
                        "name": "Load_To_Snowflake_Bronze",
                        "description": "Load ADLS data into Snowflake Bronze layer",
                        "type": "Script",
                        "dependsOn": [
                            {
                                "activity": "Delete_30_Day_Data",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "linkedServiceName": {
                            "referenceName": "Canna_Snowflake_Collect",
                            "type": "LinkedServiceReference"
                        },
                        "typeProperties": {
                            "scripts": [
                                {
                                    "type": "Query",
                                    "text": {
                                        "value": "@concat(\n  'ALTER SESSION SET TIMEZONE = ''UTC''; ',\n  'USE SCHEMA BRONZE; ',\n\n  'CREATE TABLE IF NOT EXISTS ', \n  if(endsWith(pipeline().parameters.TableName, '_t'), replace(pipeline().parameters.TableName, '_t', ''), pipeline().parameters.TableName), ' (',\n  '  data VARIANT,',\n  '  load_timestamp TIMESTAMP_NTZ DEFAULT CURRENT_TIMESTAMP()',\n  ');',\n\n  'COPY INTO ', \n  if(endsWith(pipeline().parameters.TableName, '_t'), replace(pipeline().parameters.TableName, '_t', ''), pipeline().parameters.TableName), ' (data) ',\n  'FROM @SOURCE_DB.BRONZE.ADLS_RAW_STAGE/',\n      pipeline().parameters.SourceDatabase, '/', pipeline().parameters.TableName, '/',\n      pipeline().parameters.RunDate, '/', pipeline().RunId, '/ ',\n  'PATTERN = ''', '.*', variables('LoadStrategy'), '.*', ''' ',\n  'FILE_FORMAT = (TYPE = JSON) ',\n  'FORCE = ', if(equals(variables('LoadStrategy'), 'FULL_RELOAD'), 'TRUE', 'FALSE'), ' ',\n  'ON_ERROR = ''CONTINUE'';',\n\n  'GRANT SELECT ON TABLE ', \n  if(endsWith(pipeline().parameters.TableName, '_t'), replace(pipeline().parameters.TableName, '_t', ''), pipeline().parameters.TableName), \n  ' TO ROLE SYSADMIN;',\n\n  'SELECT COUNT(*) AS rows_loaded, ''', variables('LoadStrategy'), ''' AS strategy_used ',\n  'FROM ', \n  if(endsWith(pipeline().parameters.TableName, '_t'), replace(pipeline().parameters.TableName, '_t', ''), pipeline().parameters.TableName), \n  ' WHERE data IS NOT NULL;'\n)",
                                        "type": "Expression"
                                    }
                                }
                            ],
                            "scriptBlockExecutionTimeout": "02:00:00"
                        }
                    },
                    {
                        "name": "Get_Snowflake_Row_Count",
                        "description": "Get loaded row count from Snowflake Bronze table",
                        "type": "Lookup",
                        "dependsOn": [
                            {
                                "activity": "Load_To_Snowflake_Bronze",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "source": {
                                "type": "SnowflakeV2Source",
                                "query": {
                                    "value": "@concat('SELECT COUNT(*) as snowflake_count FROM SOURCE_DB.BRONZE.',\n  if(endsWith(pipeline().parameters.TableName, '_t'), \n    replace(pipeline().parameters.TableName, '_t', ''), \n    pipeline().parameters.TableName))",
                                    "type": "Expression"
                                },
                                "exportSettings": {
                                    "type": "SnowflakeExportCopyCommand"
                                }
                            },
                            "dataset": {
                                "referenceName": "Snowflake_Collect_Bronze",
                                "type": "DatasetReference",
                                "parameters": {}
                            }
                        }
                    },
                    {
                        "name": "Validate_Row_Count_Match",
                        "description": "Compare Postgres vs Snowflake row counts",
                        "type": "IfCondition",
                        "dependsOn": [
                            {
                                "activity": "Get_Snowflake_Row_Count",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "userProperties": [],
                        "typeProperties": {
                            "expression": {
                                "value": "@equals(string(activity('Get_Source_Row_Count').output.firstRow.row_count), string(activity('Get_Snowflake_Row_Count').output.firstRow.SNOWFLAKE_COUNT))",
                                "type": "Expression"
                            },
                            "ifFalseActivities": [
                                {
                                    "name": "Set_Validation_Error",
                                    "description": "Mark validation as failed due to row count mismatch",
                                    "type": "SetVariable",
                                    "dependsOn": [],
                                    "policy": {
                                        "secureOutput": false,
                                        "secureInput": false
                                    },
                                    "userProperties": [],
                                    "typeProperties": {
                                        "variableName": "ValidationStatus",
                                        "value": "ROW_COUNT_MISMATCH"
                                    }
                                }
                            ],
                            "ifTrueActivities": [
                                {
                                    "name": "Set_Validation_Status",
                                    "description": "Mark validation as successful",
                                    "type": "SetVariable",
                                    "dependsOn": [],
                                    "policy": {
                                        "secureOutput": false,
                                        "secureInput": false
                                    },
                                    "userProperties": [],
                                    "typeProperties": {
                                        "variableName": "ValidationStatus",
                                        "value": "SUCCESS"
                                    }
                                }
                            ]
                        }
                    },
                    {
                        "name": "Check_Null_Values",
                        "description": "Count null values in key columns",
                        "type": "Lookup",
                        "dependsOn": [
                            {
                                "activity": "Load_To_Snowflake_Bronze",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "source": {
                                "type": "SnowflakeV2Source",
                                "query": {
                                    "value": "SELECT \n    SUM(CASE WHEN data:id IS NULL THEN 1 ELSE 0 END) as null_ids,\n    SUM(CASE WHEN data:name IS NULL THEN 1 ELSE 0 END) as null_names\nFROM SOURCE_DB.BRONZE.@{if(endsWith(pipeline().parameters.TableName, '_t'), replace(pipeline().parameters.TableName, '_t', ''), pipeline().parameters.TableName)}",
                                    "type": "Expression"
                                },
                                "exportSettings": {
                                    "type": "SnowflakeExportCopyCommand"
                                }
                            },
                            "dataset": {
                                "referenceName": "Snowflake_Collect_Bronze",
                                "type": "DatasetReference",
                                "parameters": {}
                            }
                        }
                    },
                    {
                        "name": "Log_Pipeline_Summary",
                        "description": "Insert execution summary into UTILITY.PIPELINE_EXECUTION_LOG",
                        "type": "Script",
                        "dependsOn": [
                            {
                                "activity": "Validate_Row_Count_Match",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            },
                            {
                                "activity": "Check_Null_Values",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "linkedServiceName": {
                            "referenceName": "Canna_Snowflake_Collect",
                            "type": "LinkedServiceReference"
                        },
                        "typeProperties": {
                            "scripts": [
                                {
                                    "type": "Query",
                                    "text": {
                                        "value": "@concat(\n  'INSERT INTO SOURCE_DB.UTILITY.PIPELINE_EXECUTION_LOG VALUES (''',\n  pipeline().RunId, ''', ''',\n  pipeline().parameters.TableName, ''', ''',\n  formatDateTime(utcnow(), 'yyyy-MM-dd'), ''', ''',\n  utcnow(), ''', ',\n  if(empty(string(activity('Get_Source_Row_Count').output.firstRow.row_count)), '0', string(activity('Get_Source_Row_Count').output.firstRow.row_count)), ', ',\n  if(empty(string(activity('Get_Snowflake_Row_Count').output.firstRow.SNOWFLAKE_COUNT)), '0', string(activity('Get_Snowflake_Row_Count').output.firstRow.SNOWFLAKE_COUNT)), ', ',\n  if(equals(variables('ValidationStatus'), 'SUCCESS'), 'TRUE', 'FALSE'), ', ',\n  if(empty(string(activity('Check_Duplicates').output.firstRow.duplicate_count)), '0', string(activity('Check_Duplicates').output.firstRow.duplicate_count)), ', ',\n  if(empty(string(activity('Check_Null_Values').output.firstRow.NULL_IDS)), '0', string(activity('Check_Null_Values').output.firstRow.NULL_IDS)), ', ',\n  if(empty(string(activity('Check_Null_Values').output.firstRow.NULL_NAMES)), '0', string(activity('Check_Null_Values').output.firstRow.NULL_NAMES)), ', ''',\n  variables('ValidationStatus'), ''', ',\n  '0', \n  ');'\n)",
                                        "type": "Expression"
                                    }
                                }
                            ],
                            "scriptBlockExecutionTimeout": "02:00:00"
                        }
                    },
                    {
                        "name": "Check_Duplicates",
                        "description": "Check for duplicate rows in the table",
                        "type": "Lookup",
                        "dependsOn": [
                            {
                                "activity": "Get_Source_Row_Count",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "source": {
                                "type": "PostgreSqlV2Source",
                                "query": {
                                    "value": "@if(equals(variables('LoadStrategy'), 'ROLLING_30DAY'),\n  concat('SELECT (SELECT COUNT(*) FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName, ' WHERE ', variables('WatermarkCol'), ' >= (''', pipeline().parameters.RunDate, '''::date - INTERVAL ''30 days'')) - (SELECT COUNT(*) FROM (SELECT DISTINCT * FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName, ' WHERE ', variables('WatermarkCol'), ' >= (''', pipeline().parameters.RunDate, '''::date - INTERVAL ''30 days'')) t) as duplicate_count'),\n  concat('SELECT (SELECT COUNT(*) FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName, ') - (SELECT COUNT(*) FROM (SELECT DISTINCT * FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName, ') t) as duplicate_count')\n)",
                                    "type": "Expression"
                                },
                                "queryTimeout": "02:00:00"
                            },
                            "dataset": {
                                "referenceName": "Canna_PostgreSQL_Collect_Tables",
                                "type": "DatasetReference",
                                "parameters": {
                                    "SchemaName": "@pipeline().parameters.SchemaName",
                                    "TableName": "@pipeline().parameters.TableName"
                                }
                            }
                        }
                    },
                    {
                        "name": "Delete_30_Day_Data",
                        "type": "Script",
                        "dependsOn": [
                            {
                                "activity": "Validate_ADLS_File",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "linkedServiceName": {
                            "referenceName": "Canna_Snowflake_Collect",
                            "type": "LinkedServiceReference"
                        },
                        "typeProperties": {
                            "scripts": [
                                {
                                    "type": "Query",
                                    "text": {
                                        "value": "@concat(\n  'USE SCHEMA BRONZE; ',\n  'CREATE TABLE IF NOT EXISTS ', \n  if(endsWith(pipeline().parameters.TableName, '_t'), replace(pipeline().parameters.TableName, '_t', ''), pipeline().parameters.TableName), \n  ' (data VARIANT); ',\n  'ALTER SESSION SET TIMEZONE = ''UTC''; ',\n  if(equals(variables('LoadStrategy'), 'ROLLING_30DAY'),\n    concat('DELETE FROM ', \n      if(endsWith(pipeline().parameters.TableName, '_t'), replace(pipeline().parameters.TableName, '_t', ''), pipeline().parameters.TableName), \n      ' WHERE TO_DATE(data:', variables('WatermarkCol'), '::TIMESTAMP) >= DATEADD(day, -30, TO_DATE(''', pipeline().parameters.RunDate, ''')); '),\n    if(equals(variables('LoadStrategy'), 'FULL_RELOAD'),\n      concat('TRUNCATE TABLE ', \n        if(endsWith(pipeline().parameters.TableName, '_t'), replace(pipeline().parameters.TableName, '_t', ''), pipeline().parameters.TableName), \n        '; '),\n      'SELECT ''No cleanup needed for incremental strategy'' as status; '\n    )\n  ),\n  'SELECT ''', variables('LoadStrategy'), ''' as strategy_applied;'\n)",
                                        "type": "Expression"
                                    }
                                }
                            ],
                            "scriptBlockExecutionTimeout": "02:00:00"
                        }
                    },
                    {
                        "name": "Get_Table_Strategy",
                        "type": "Lookup",
                        "dependsOn": [],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "source": {
                                "type": "SnowflakeV2Source",
                                "query": {
                                    "value": "SELECT \n    COALESCE(load_strategy, 'INCREMENTAL') as load_strategy,\n    COALESCE(parallel_copies, 8) as parallel_copies,\n    COALESCE(data_integration_units, 16) as data_integration_units,\n    COALESCE(watermark_column, 'none') as watermark_column\nFROM SOURCE_DB.UTILITY.TABLE_STRATEGY_CONFIG \nWHERE table_name = '@{pipeline().parameters.TableName}'\nAND is_active = TRUE",
                                    "type": "Expression"
                                },
                                "exportSettings": {
                                    "type": "SnowflakeExportCopyCommand"
                                }
                            },
                            "dataset": {
                                "referenceName": "Snowflake_Collect_Bronze",
                                "type": "DatasetReference",
                                "parameters": {}
                            }
                        }
                    },
                    {
                        "name": "Set_Strategy_From_Config",
                        "type": "SetVariable",
                        "dependsOn": [
                            {
                                "activity": "Get_Table_Strategy",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "variableName": "LoadStrategy",
                            "value": {
                                "value": "@activity('Get_Table_Strategy').output.firstRow.load_strategy",
                                "type": "Expression"
                            }
                        }
                    },
                    {
                        "name": "Set_Parallel_Copies",
                        "type": "SetVariable",
                        "dependsOn": [
                            {
                                "activity": "Set_Strategy_From_Config",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "variableName": "ParallelCopies",
                            "value": {
                                "value": "@string(activity('Get_Table_Strategy').output.firstRow.parallel_copies)",
                                "type": "Expression"
                            }
                        }
                    },
                    {
                        "name": "Set_DIU",
                        "type": "SetVariable",
                        "dependsOn": [
                            {
                                "activity": "Set_Parallel_Copies",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "variableName": "DataIntegrationUnits",
                            "value": {
                                "value": "@string(activity('Get_Table_Strategy').output.firstRow.data_integration_units)",
                                "type": "Expression"
                            }
                        }
                    },
                    {
                        "name": "Set_Watermark_Column",
                        "type": "SetVariable",
                        "dependsOn": [
                            {
                                "activity": "Set_DIU",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "variableName": "WatermarkCol",
                            "value": {
                                "value": "@activity('Get_Table_Strategy').output.firstRow.watermark_column",
                                "type": "Expression"
                            }
                        }
                    },
                    {
                        "name": "No_tm_Tables",
                        "type": "IfCondition",
                        "dependsOn": [
                            {
                                "activity": "Check_Duplicates",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "userProperties": [],
                        "typeProperties": {
                            "expression": {
                                "value": "@not(equals(variables('WatermarkCol'), 'none'))",
                                "type": "Expression"
                            },
                            "ifTrueActivities": [
                                {
                                    "name": "Get_Max_Watermark",
                                    "type": "Lookup",
                                    "dependsOn": [],
                                    "policy": {
                                        "timeout": "0.12:00:00",
                                        "retry": 0,
                                        "retryIntervalInSeconds": 30,
                                        "secureOutput": false,
                                        "secureInput": false
                                    },
                                    "userProperties": [],
                                    "typeProperties": {
                                        "source": {
                                            "type": "PostgreSqlV2Source",
                                            "query": {
                                                "value": "@if(equals(variables('WatermarkCol'), 'none'),\n  concat('SELECT ''2000-01-01 00:00:00''::timestamp as max_watermark'),\n  concat('SELECT MAX(', variables('WatermarkCol'), ')::timestamp as max_watermark FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName)\n)",
                                                "type": "Expression"
                                            },
                                            "queryTimeout": "02:00:00"
                                        },
                                        "dataset": {
                                            "referenceName": "Canna_PostgreSQL_Collect_Tables",
                                            "type": "DatasetReference",
                                            "parameters": {
                                                "SchemaName": "collect",
                                                "TableName": "cc_customers"
                                            }
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    {
                        "name": "Update_tm_Tables",
                        "type": "IfCondition",
                        "dependsOn": [
                            {
                                "activity": "Log_Pipeline_Summary",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "userProperties": [],
                        "typeProperties": {
                            "expression": {
                                "value": "@not(equals(variables('WatermarkCol'), 'none'))",
                                "type": "Expression"
                            },
                            "ifTrueActivities": [
                                {
                                    "name": "Update_Watermark",
                                    "type": "Lookup",
                                    "dependsOn": [],
                                    "policy": {
                                        "timeout": "0.12:00:00",
                                        "retry": 0,
                                        "retryIntervalInSeconds": 30,
                                        "secureOutput": false,
                                        "secureInput": false
                                    },
                                    "userProperties": [],
                                    "typeProperties": {
                                        "source": {
                                            "type": "PostgreSqlV2Source",
                                            "query": {
                                                "value": "WITH update_result AS (\n     INSERT INTO collect.watermark_control (table_name, last_watermark, updated_at)\n     VALUES (\n       '@{pipeline().parameters.TableName}',\n       '@{activity('Get_Max_Watermark').output.firstRow.max_watermark}'::timestamp,\n       CURRENT_TIMESTAMP\n     )\n     ON CONFLICT (table_name) \n     DO UPDATE SET \n       last_watermark = EXCLUDED.last_watermark,\n       updated_at = CURRENT_TIMESTAMP\n     RETURNING table_name\n   )\n   SELECT COUNT(*) as rows_updated FROM update_result;",
                                                "type": "Expression"
                                            },
                                            "queryTimeout": "02:00:00"
                                        },
                                        "dataset": {
                                            "referenceName": "Canna_PostgreSQL_Collect_Tables",
                                            "type": "DatasetReference",
                                            "parameters": {
                                                "SchemaName": "collect",
                                                "TableName": "cc_customers"
                                            }
                                        }
                                    }
                                }
                            ]
                        }
                    }
                ],
                "policy": {
                    "elapsedTimeMetric": {}
                },
                "parameters": {
                    "SourceDatabase": {
                        "type": "string",
                        "defaultValue": "collect"
                    },
                    "SchemaName": {
                        "type": "string",
                        "defaultValue": "collect"
                    },
                    "TableName": {
                        "type": "string"
                    },
                    "WatermarkColumn": {
                        "type": "string",
                        "defaultValue": "tm"
                    },
                    "LastWatermark": {
                        "type": "string",
                        "defaultValue": "2000-01-01 00:00:00"
                    },
                    "RunDate": {
                        "type": "string"
                    }
                },
                "variables": {
                    "ValidationStatus": {
                        "type": "String"
                    },
                    "LoadStrategy": {
                        "type": "String",
                        "defaultValue": "INCREMENTAL"
                    },
                    "ParallelCopies": {
                        "type": "String",
                        "defaultValue": "8"
                    },
                    "DataIntegrationUnits": {
                        "type": "String",
                        "defaultValue": "16"
                    },
                    "WatermarkCol": {
                        "type": "String",
                        "defaultValue": "tm"
                    }
                },
                "folder": {
                    "name": "Archive"
                },
                "annotations": [],
                "lastPublishTime": "2025-09-18T14:21:00Z"
            },
            "dependsOn": [
                "[concat(variables('factoryId'), '/datasets/Canna_PostgreSQL_Collect_Tables')]",
                "[concat(variables('factoryId'), '/datasets/ADLS_JSON')]",
                "[concat(variables('factoryId'), '/linkedServices/Canna_Snowflake_Collect')]",
                "[concat(variables('factoryId'), '/datasets/Snowflake_Collect_Bronze')]",
                "[concat(variables('factoryId'), '/linkedServices/Canna_ADLS')]"
            ]
        },
        {
            "name": "[concat(parameters('factoryName'), '/Collect_Table_With_Validation_Incremental_JSON_Increm_Row_Count')]",
            "type": "Microsoft.DataFactory/factories/pipelines",
            "apiVersion": "2018-06-01",
            "properties": {
                "activities": [
                    {
                        "name": "Get_Source_Row_Count",
                        "description": "Get Postgres SQL table row count ",
                        "type": "Lookup",
                        "dependsOn": [
                            {
                                "activity": "Set_Watermark_Column",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "source": {
                                "type": "PostgreSqlV2Source",
                                "query": {
                                    "value": "@if(equals(variables('WatermarkCol'), 'none'),\n  concat('SELECT COUNT(*) as row_count FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName),\n  if(equals(variables('LoadStrategy'), 'ROLLING_30DAY'),\n    if(lessOrEquals(formatDateTime(utcnow(), 'yyyy-MM-dd'), '2025-12-01'),\n      concat('SELECT COUNT(*) as row_count FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName, ' WHERE ', variables('WatermarkCol'), ' > ''2025-11-02 00:00:00'''),\n      concat('SELECT COUNT(*) as row_count FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName, ' WHERE ', variables('WatermarkCol'), ' >= CURRENT_DATE - INTERVAL ''30 days''')\n    ),\n    if(equals(variables('LoadStrategy'), 'FULL_RELOAD'),\n      concat('SELECT COUNT(*) as row_count FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName),\n      concat('SELECT COUNT(*) as row_count FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName, ' WHERE ', variables('WatermarkCol'), ' > ''', pipeline().parameters.LastWatermark, '''')\n    )\n  )\n)",
                                    "type": "Expression"
                                },
                                "queryTimeout": "02:00:00"
                            },
                            "dataset": {
                                "referenceName": "Canna_PostgreSQL_Collect_Tables",
                                "type": "DatasetReference",
                                "parameters": {
                                    "SchemaName": "@pipeline().parameters.SchemaName",
                                    "TableName": "@pipeline().parameters.TableName"
                                }
                            }
                        }
                    },
                    {
                        "name": "Copy_To_ADLS",
                        "description": "Copy raw Postgres data into ADLS",
                        "type": "Copy",
                        "dependsOn": [
                            {
                                "activity": "No_tm_Tables",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "source": {
                                "type": "PostgreSqlV2Source",
                                "query": {
                                    "value": "@if(equals(variables('WatermarkCol'), 'none'),\n  concat('SELECT * FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName),\n  if(equals(variables('LoadStrategy'), 'ROLLING_30DAY'),\n    if(lessOrEquals(formatDateTime(utcnow(), 'yyyy-MM-dd'), '2025-12-01'),\n      concat('SELECT * FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName, ' WHERE ', variables('WatermarkCol'), ' > ''2025-11-02 00:00:00'''),\n      concat('SELECT * FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName, ' WHERE ', variables('WatermarkCol'), ' >= CURRENT_DATE - INTERVAL ''30 days''')\n    ),\n    if(equals(variables('LoadStrategy'), 'FULL_RELOAD'),\n      concat('SELECT * FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName),\n      concat('SELECT * FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName, ' WHERE ', variables('WatermarkCol'), ' > ''', pipeline().parameters.LastWatermark, '''')\n    )\n  )\n)",
                                    "type": "Expression"
                                },
                                "queryTimeout": "02:00:00"
                            },
                            "sink": {
                                "type": "JsonSink",
                                "storeSettings": {
                                    "type": "AzureBlobFSWriteSettings"
                                },
                                "formatSettings": {
                                    "type": "JsonWriteSettings"
                                }
                            },
                            "enableStaging": false,
                            "parallelCopies": {
                                "value": "@int(variables('ParallelCopies'))",
                                "type": "Expression"
                            },
                            "enableSkipIncompatibleRow": false,
                            "validateDataConsistency": true,
                            "logSettings": {
                                "enableCopyActivityLog": true,
                                "copyActivityLogSettings": {
                                    "logLevel": "Info",
                                    "enableReliableLogging": false
                                },
                                "logLocationSettings": {
                                    "linkedServiceName": {
                                        "referenceName": "Canna_ADLS",
                                        "type": "LinkedServiceReference"
                                    },
                                    "path": "logs/copy-activity"
                                }
                            },
                            "dataIntegrationUnits": {
                                "value": "@int(variables('DataIntegrationUnits'))",
                                "type": "Expression"
                            }
                        },
                        "inputs": [
                            {
                                "referenceName": "Canna_PostgreSQL_Collect_Tables",
                                "type": "DatasetReference",
                                "parameters": {
                                    "SchemaName": "@pipeline().parameters.SchemaName",
                                    "TableName": "@pipeline().parameters.TableName"
                                }
                            }
                        ],
                        "outputs": [
                            {
                                "referenceName": "ADLS_JSON",
                                "type": "DatasetReference",
                                "parameters": {
                                    "Container": "raw",
                                    "Directory": {
                                        "value": "@concat(\n  pipeline().parameters.SourceDatabase, '/',\n  pipeline().parameters.TableName, '/',\n  pipeline().parameters.RunDate, '/',\n  pipeline().RunId         \n)\n",
                                        "type": "Expression"
                                    },
                                    "FileName": {
                                        "value": "@concat(pipeline().parameters.SchemaName, '_', pipeline().parameters.TableName, '_', formatDateTime(utcNow(), 'yyyyMMdd_HHmmss'), '_', variables('LoadStrategy'), '.json')",
                                        "type": "Expression"
                                    }
                                }
                            }
                        ]
                    },
                    {
                        "name": "Validate_ADLS_File",
                        "description": "Verify the JSON file was created successfully in ADLS",
                        "type": "GetMetadata",
                        "dependsOn": [
                            {
                                "activity": "Copy_To_ADLS",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "dataset": {
                                "referenceName": "ADLS_JSON",
                                "type": "DatasetReference",
                                "parameters": {
                                    "Container": "raw",
                                    "Directory": "@concat(pipeline().parameters.SourceDatabase, '/', formatDateTime(utcnow(), 'yyyy-MM-dd'))",
                                    "FileName": "@concat(pipeline().parameters.SchemaName, '_', pipeline().parameters.TableName, '_', formatDateTime(utcnow(), 'yyyyMMddHHmmss'), '.json')"
                                }
                            },
                            "fieldList": [
                                "exists",
                                "childItems"
                            ],
                            "storeSettings": {
                                "type": "AzureBlobFSReadSettings",
                                "recursive": true,
                                "enablePartitionDiscovery": false
                            },
                            "formatSettings": {
                                "type": "JsonReadSettings"
                            }
                        }
                    },
                    {
                        "name": "Load_To_Snowflake_Bronze",
                        "description": "Load ADLS data into Snowflake Bronze layer",
                        "type": "Script",
                        "dependsOn": [
                            {
                                "activity": "Delete_30_Day_Data",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "linkedServiceName": {
                            "referenceName": "Canna_Snowflake_Collect",
                            "type": "LinkedServiceReference"
                        },
                        "typeProperties": {
                            "scripts": [
                                {
                                    "type": "Query",
                                    "text": {
                                        "value": "@concat(\n  'ALTER SESSION SET TIMEZONE = ''UTC''; ',\n  'USE SCHEMA BRONZE; ',\n\n  'COPY INTO ', \n  if(endsWith(pipeline().parameters.TableName, '_t'), replace(pipeline().parameters.TableName, '_t', ''), pipeline().parameters.TableName), ' (data) ',\n  'FROM @SOURCE_DB.BRONZE.ADLS_RAW_STAGE/',\n      pipeline().parameters.SourceDatabase, '/', pipeline().parameters.TableName, '/',\n      pipeline().parameters.RunDate, '/', pipeline().RunId, '/ ',\n  'PATTERN = ''', '.*', variables('LoadStrategy'), '.*', ''' ',\n  'FILE_FORMAT = (TYPE = JSON) ',\n  'FORCE = ', if(equals(variables('LoadStrategy'), 'FULL_RELOAD'), 'TRUE', 'FALSE'), ' ',\n  'ON_ERROR = ''CONTINUE'';',\n\n  'SELECT COUNT(*) AS rows_loaded, ''', variables('LoadStrategy'), ''' AS strategy_used ',\n  'FROM ', \n  if(endsWith(pipeline().parameters.TableName, '_t'), replace(pipeline().parameters.TableName, '_t', ''), pipeline().parameters.TableName), \n  ' WHERE data IS NOT NULL;'\n)",
                                        "type": "Expression"
                                    }
                                }
                            ],
                            "scriptBlockExecutionTimeout": "02:00:00"
                        }
                    },
                    {
                        "name": "Get_Snowflake_Row_Count",
                        "description": "Get loaded row count from Snowflake Bronze table",
                        "type": "Lookup",
                        "dependsOn": [
                            {
                                "activity": "Load_To_Snowflake_Bronze",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "source": {
                                "type": "SnowflakeV2Source",
                                "query": {
                                    "value": "SELECT COUNT(*) as snowflake_count \nFROM SOURCE_DB.BRONZE.@{if(endsWith(pipeline().parameters.TableName, '_t'), replace(pipeline().parameters.TableName, '_t', ''), pipeline().parameters.TableName)};",
                                    "type": "Expression"
                                },
                                "exportSettings": {
                                    "type": "SnowflakeExportCopyCommand"
                                }
                            },
                            "dataset": {
                                "referenceName": "Snowflake_Collect_Bronze",
                                "type": "DatasetReference",
                                "parameters": {}
                            }
                        }
                    },
                    {
                        "name": "Validate_Row_Count_Match",
                        "description": "Compare Postgres vs Snowflake row counts",
                        "type": "IfCondition",
                        "dependsOn": [
                            {
                                "activity": "Get_Snowflake_Row_Count",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "userProperties": [],
                        "typeProperties": {
                            "expression": {
                                "value": "@if(or(equals(variables('LoadStrategy'), 'ROLLING_30DAY'), equals(variables('LoadStrategy'), 'FULL_RELOAD')), true, equals(string(activity('Get_Source_Row_Count').output.firstRow.row_count), string(activity('Get_Snowflake_Row_Count').output.firstRow.SNOWFLAKE_COUNT)))",
                                "type": "Expression"
                            },
                            "ifFalseActivities": [
                                {
                                    "name": "Set_Validation_Error",
                                    "description": "Mark validation as failed due to row count mismatch",
                                    "type": "SetVariable",
                                    "dependsOn": [],
                                    "policy": {
                                        "secureOutput": false,
                                        "secureInput": false
                                    },
                                    "userProperties": [],
                                    "typeProperties": {
                                        "variableName": "ValidationStatus",
                                        "value": "ROW_COUNT_MISMATCH"
                                    }
                                }
                            ],
                            "ifTrueActivities": [
                                {
                                    "name": "Set_Validation_Status",
                                    "description": "Mark validation as successful",
                                    "type": "SetVariable",
                                    "dependsOn": [],
                                    "policy": {
                                        "secureOutput": false,
                                        "secureInput": false
                                    },
                                    "userProperties": [],
                                    "typeProperties": {
                                        "variableName": "ValidationStatus",
                                        "value": "SUCCESS"
                                    }
                                }
                            ]
                        }
                    },
                    {
                        "name": "Check_Null_Values",
                        "description": "Count null values in key columns",
                        "type": "Lookup",
                        "dependsOn": [
                            {
                                "activity": "Load_To_Snowflake_Bronze",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "source": {
                                "type": "SnowflakeV2Source",
                                "query": {
                                    "value": "SELECT \n    SUM(CASE WHEN data:id IS NULL THEN 1 ELSE 0 END) as null_ids,\n    SUM(CASE WHEN data:name IS NULL THEN 1 ELSE 0 END) as null_names\nFROM SOURCE_DB.BRONZE.@{if(endsWith(pipeline().parameters.TableName, '_t'), replace(pipeline().parameters.TableName, '_t', ''), pipeline().parameters.TableName)}",
                                    "type": "Expression"
                                },
                                "exportSettings": {
                                    "type": "SnowflakeExportCopyCommand"
                                }
                            },
                            "dataset": {
                                "referenceName": "Snowflake_Collect_Bronze",
                                "type": "DatasetReference",
                                "parameters": {}
                            }
                        }
                    },
                    {
                        "name": "Log_Pipeline_Summary",
                        "description": "Insert execution summary into UTILITY.PIPELINE_EXECUTION_LOG",
                        "type": "Script",
                        "dependsOn": [
                            {
                                "activity": "Validate_Row_Count_Match",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            },
                            {
                                "activity": "Check_Null_Values",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "linkedServiceName": {
                            "referenceName": "Canna_Snowflake_Collect",
                            "type": "LinkedServiceReference"
                        },
                        "typeProperties": {
                            "scripts": [
                                {
                                    "type": "Query",
                                    "text": {
                                        "value": "@concat(\n  'INSERT INTO SOURCE_DB.UTILITY.PIPELINE_EXECUTION_LOG VALUES (''',\n  pipeline().RunId, ''', ''',\n  pipeline().parameters.TableName, ''', ''',\n  formatDateTime(utcnow(), 'yyyy-MM-dd'), ''', ''',\n  utcnow(), ''', ',\n  if(empty(string(activity('Get_Source_Row_Count').output.firstRow.row_count)), '0', string(activity('Get_Source_Row_Count').output.firstRow.row_count)), ', ',\n  if(empty(string(activity('Get_Snowflake_Row_Count').output.firstRow.SNOWFLAKE_COUNT)), '0', string(activity('Get_Snowflake_Row_Count').output.firstRow.SNOWFLAKE_COUNT)), ', ',\n  if(equals(variables('ValidationStatus'), 'SUCCESS'), 'TRUE', 'FALSE'), ', ',\n  if(empty(string(activity('Check_Duplicates').output.firstRow.duplicate_count)), '0', string(activity('Check_Duplicates').output.firstRow.duplicate_count)), ', ',\n  if(empty(string(activity('Check_Null_Values').output.firstRow.NULL_IDS)), '0', string(activity('Check_Null_Values').output.firstRow.NULL_IDS)), ', ',\n  if(empty(string(activity('Check_Null_Values').output.firstRow.NULL_NAMES)), '0', string(activity('Check_Null_Values').output.firstRow.NULL_NAMES)), ', ''',\n  variables('ValidationStatus'), ''', ',\n  '0', \n  ');'\n)",
                                        "type": "Expression"
                                    }
                                }
                            ],
                            "scriptBlockExecutionTimeout": "02:00:00"
                        }
                    },
                    {
                        "name": "Check_Duplicates",
                        "description": "Check for duplicate rows in the table",
                        "type": "Lookup",
                        "dependsOn": [
                            {
                                "activity": "Get_Source_Row_Count",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "source": {
                                "type": "PostgreSqlV2Source",
                                "query": {
                                    "value": "@if(equals(variables('LoadStrategy'), 'ROLLING_30DAY'),\n  if(lessOrEquals(formatDateTime(utcnow(), 'yyyy-MM-dd'), '2025-12-01'),\n    concat('SELECT (SELECT COUNT(*) FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName, ' WHERE ', variables('WatermarkCol'), ' > ''2025-11-02 00:00:00'') - (SELECT COUNT(*) FROM (SELECT DISTINCT * FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName, ' WHERE ', variables('WatermarkCol'), ' > ''2025-11-02 00:00:00'') t) as duplicate_count'),\n    concat('SELECT (SELECT COUNT(*) FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName, ' WHERE ', variables('WatermarkCol'), ' >= CURRENT_DATE - INTERVAL ''30 days'') - (SELECT COUNT(*) FROM (SELECT DISTINCT * FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName, ' WHERE ', variables('WatermarkCol'), ' >= CURRENT_DATE - INTERVAL ''30 days'') t) as duplicate_count')\n  ),\n  concat('SELECT (SELECT COUNT(*) FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName, ') - (SELECT COUNT(*) FROM (SELECT DISTINCT * FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName, ') t) as duplicate_count')\n)",
                                    "type": "Expression"
                                },
                                "queryTimeout": "02:00:00"
                            },
                            "dataset": {
                                "referenceName": "Canna_PostgreSQL_Collect_Tables",
                                "type": "DatasetReference",
                                "parameters": {
                                    "SchemaName": "@pipeline().parameters.SchemaName",
                                    "TableName": "@pipeline().parameters.TableName"
                                }
                            }
                        }
                    },
                    {
                        "name": "Delete_30_Day_Data",
                        "type": "Script",
                        "dependsOn": [
                            {
                                "activity": "Validate_ADLS_File",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "linkedServiceName": {
                            "referenceName": "Canna_Snowflake_Collect",
                            "type": "LinkedServiceReference"
                        },
                        "typeProperties": {
                            "scripts": [
                                {
                                    "type": "Query",
                                    "text": {
                                        "value": "@concat(\n  'USE SCHEMA BRONZE; ',\n  'ALTER SESSION SET TIMEZONE = ''UTC''; ',\n  if(equals(variables('LoadStrategy'), 'ROLLING_30DAY'),\n    if(lessOrEquals(formatDateTime(utcnow(), 'yyyy-MM-dd'), '2025-12-01'),\n      concat('DELETE FROM ', \n        if(endsWith(pipeline().parameters.TableName, '_t'), replace(pipeline().parameters.TableName, '_t', ''), pipeline().parameters.TableName), \n        ' WHERE TO_DATE(CONVERT_TIMEZONE(''UTC'', TRY_TO_TIMESTAMP_TZ(data:\"', variables('WatermarkCol'), '\"::string))) >= ''2025-11-02''; '),\n      concat('DELETE FROM ', \n        if(endsWith(pipeline().parameters.TableName, '_t'), replace(pipeline().parameters.TableName, '_t', ''), pipeline().parameters.TableName), \n        ' WHERE TO_DATE(CONVERT_TIMEZONE(''UTC'', TRY_TO_TIMESTAMP_TZ(data:\"', variables('WatermarkCol'), '\"::string))) >= DATEADD(day, -30, CURRENT_DATE()); ')\n    ),\n    if(equals(variables('LoadStrategy'), 'FULL_RELOAD'),\n      concat('TRUNCATE TABLE ', \n        if(endsWith(pipeline().parameters.TableName, '_t'), replace(pipeline().parameters.TableName, '_t', ''), pipeline().parameters.TableName), \n        '; '),\n      'SELECT ''No cleanup needed for incremental strategy'' as status; '\n    )\n  ),\n  'SELECT ''', variables('LoadStrategy'), ''' as strategy_applied;'\n)",
                                        "type": "Expression"
                                    }
                                }
                            ],
                            "scriptBlockExecutionTimeout": "02:00:00"
                        }
                    },
                    {
                        "name": "Get_Table_Strategy",
                        "type": "Lookup",
                        "dependsOn": [],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "source": {
                                "type": "SnowflakeV2Source",
                                "query": {
                                    "value": "SELECT \n       COALESCE(load_strategy, 'INCREMENTAL') as load_strategy,\n       COALESCE(parallel_copies, 8) as parallel_copies,\n       COALESCE(data_integration_units, 16) as data_integration_units,\n       COALESCE(watermark_column, 'tm') as watermark_column\n   FROM SOURCE_DB.UTILITY.TABLE_STRATEGY_CONFIG \n   WHERE table_name = '@{pipeline().parameters.TableName}'\n   AND is_active = TRUE",
                                    "type": "Expression"
                                },
                                "exportSettings": {
                                    "type": "SnowflakeExportCopyCommand"
                                }
                            },
                            "dataset": {
                                "referenceName": "Snowflake_Collect_Bronze",
                                "type": "DatasetReference",
                                "parameters": {}
                            }
                        }
                    },
                    {
                        "name": "Set_Strategy_From_Config",
                        "type": "SetVariable",
                        "dependsOn": [
                            {
                                "activity": "Get_Table_Strategy",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "variableName": "LoadStrategy",
                            "value": {
                                "value": "@activity('Get_Table_Strategy').output.firstRow.load_strategy",
                                "type": "Expression"
                            }
                        }
                    },
                    {
                        "name": "Set_Parallel_Copies",
                        "type": "SetVariable",
                        "dependsOn": [
                            {
                                "activity": "Set_Strategy_From_Config",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "variableName": "ParallelCopies",
                            "value": {
                                "value": "@string(activity('Get_Table_Strategy').output.firstRow.parallel_copies)",
                                "type": "Expression"
                            }
                        }
                    },
                    {
                        "name": "Set_DIU",
                        "type": "SetVariable",
                        "dependsOn": [
                            {
                                "activity": "Set_Parallel_Copies",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "variableName": "DataIntegrationUnits",
                            "value": {
                                "value": "@string(activity('Get_Table_Strategy').output.firstRow.data_integration_units)",
                                "type": "Expression"
                            }
                        }
                    },
                    {
                        "name": "Set_Watermark_Column",
                        "type": "SetVariable",
                        "dependsOn": [
                            {
                                "activity": "Set_DIU",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "variableName": "WatermarkCol",
                            "value": {
                                "value": "@activity('Get_Table_Strategy').output.firstRow.watermark_column",
                                "type": "Expression"
                            }
                        }
                    },
                    {
                        "name": "No_tm_Tables",
                        "type": "IfCondition",
                        "dependsOn": [
                            {
                                "activity": "Check_Duplicates",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "userProperties": [],
                        "typeProperties": {
                            "expression": {
                                "value": "@not(equals(variables('WatermarkCol'), 'none'))",
                                "type": "Expression"
                            },
                            "ifTrueActivities": [
                                {
                                    "name": "Get_Max_Watermark",
                                    "type": "Lookup",
                                    "dependsOn": [],
                                    "policy": {
                                        "timeout": "0.12:00:00",
                                        "retry": 0,
                                        "retryIntervalInSeconds": 30,
                                        "secureOutput": false,
                                        "secureInput": false
                                    },
                                    "userProperties": [],
                                    "typeProperties": {
                                        "source": {
                                            "type": "PostgreSqlV2Source",
                                            "query": {
                                                "value": "@concat('SELECT MAX(', variables('WatermarkCol'), ')::timestamp as max_watermark FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName)\n",
                                                "type": "Expression"
                                            },
                                            "queryTimeout": "02:00:00"
                                        },
                                        "dataset": {
                                            "referenceName": "Canna_PostgreSQL_Collect_Tables",
                                            "type": "DatasetReference",
                                            "parameters": {
                                                "SchemaName": "collect",
                                                "TableName": "cc_customers"
                                            }
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    {
                        "name": "Update_tm_Tables",
                        "type": "IfCondition",
                        "dependsOn": [
                            {
                                "activity": "Log_Pipeline_Summary",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "userProperties": [],
                        "typeProperties": {
                            "expression": {
                                "value": "@not(equals(variables('WatermarkCol'), 'none'))",
                                "type": "Expression"
                            },
                            "ifTrueActivities": [
                                {
                                    "name": "Update_Watermark",
                                    "type": "Lookup",
                                    "dependsOn": [],
                                    "policy": {
                                        "timeout": "0.12:00:00",
                                        "retry": 0,
                                        "retryIntervalInSeconds": 30,
                                        "secureOutput": false,
                                        "secureInput": false
                                    },
                                    "userProperties": [],
                                    "typeProperties": {
                                        "source": {
                                            "type": "PostgreSqlV2Source",
                                            "query": {
                                                "value": "WITH update_result AS (\n     INSERT INTO collect.watermark_control (table_name, last_watermark, updated_at)\n     VALUES (\n       '@{pipeline().parameters.TableName}',\n       '@{activity('Get_Max_Watermark').output.firstRow.max_watermark}'::timestamp,\n       CURRENT_TIMESTAMP\n     )\n     ON CONFLICT (table_name) \n     DO UPDATE SET \n       last_watermark = EXCLUDED.last_watermark,\n       updated_at = CURRENT_TIMESTAMP\n     RETURNING table_name\n   )\n   SELECT COUNT(*) as rows_updated FROM update_result;",
                                                "type": "Expression"
                                            },
                                            "queryTimeout": "02:00:00"
                                        },
                                        "dataset": {
                                            "referenceName": "Canna_PostgreSQL_Collect_Tables",
                                            "type": "DatasetReference",
                                            "parameters": {
                                                "SchemaName": "collect",
                                                "TableName": "cc_customers"
                                            }
                                        }
                                    }
                                }
                            ]
                        }
                    }
                ],
                "policy": {
                    "elapsedTimeMetric": {}
                },
                "parameters": {
                    "SourceDatabase": {
                        "type": "string",
                        "defaultValue": "collect"
                    },
                    "SchemaName": {
                        "type": "string",
                        "defaultValue": "collect"
                    },
                    "TableName": {
                        "type": "string"
                    },
                    "WatermarkColumn": {
                        "type": "string",
                        "defaultValue": "tm"
                    },
                    "LastWatermark": {
                        "type": "string",
                        "defaultValue": "2000-01-01 00:00:00"
                    },
                    "RunDate": {
                        "type": "string"
                    }
                },
                "variables": {
                    "ValidationStatus": {
                        "type": "String"
                    },
                    "LoadStrategy": {
                        "type": "String",
                        "defaultValue": "INCREMENTAL"
                    },
                    "ParallelCopies": {
                        "type": "String",
                        "defaultValue": "8"
                    },
                    "DataIntegrationUnits": {
                        "type": "String",
                        "defaultValue": "16"
                    },
                    "WatermarkCol": {
                        "type": "String",
                        "defaultValue": "tm"
                    }
                },
                "folder": {
                    "name": "Archive"
                },
                "annotations": [],
                "lastPublishTime": "2025-09-18T14:21:00Z"
            },
            "dependsOn": [
                "[concat(variables('factoryId'), '/datasets/Canna_PostgreSQL_Collect_Tables')]",
                "[concat(variables('factoryId'), '/datasets/ADLS_JSON')]",
                "[concat(variables('factoryId'), '/linkedServices/Canna_Snowflake_Collect')]",
                "[concat(variables('factoryId'), '/datasets/Snowflake_Collect_Bronze')]",
                "[concat(variables('factoryId'), '/linkedServices/Canna_ADLS')]"
            ]
        },
        {
            "name": "[concat(parameters('factoryName'), '/Collect_Table_With_Validation_Incremental_JSON_Nov')]",
            "type": "Microsoft.DataFactory/factories/pipelines",
            "apiVersion": "2018-06-01",
            "properties": {
                "activities": [
                    {
                        "name": "Get_Source_Row_Count",
                        "description": "Get Postgres SQL table row count ",
                        "type": "Lookup",
                        "dependsOn": [
                            {
                                "activity": "Set_Watermark_Column",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "source": {
                                "type": "PostgreSqlV2Source",
                                "query": {
                                    "value": "@if(equals(variables('WatermarkCol'), 'none'),\n  concat('SELECT COUNT(*) as row_count FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName),\n  if(equals(variables('LoadStrategy'), 'ROLLING_30DAY'),\n    concat('SELECT COUNT(*) as row_count FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName, ' WHERE ', variables('WatermarkCol'), ' > ''2025-11-02 00:00:00'''),\n    if(equals(variables('LoadStrategy'), 'FULL_RELOAD'),\n      concat('SELECT COUNT(*) as row_count FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName),\n      concat('SELECT COUNT(*) as row_count FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName, ' WHERE ', variables('WatermarkCol'), ' > ''', pipeline().parameters.LastWatermark, '''')\n    )\n  )\n)",
                                    "type": "Expression"
                                },
                                "queryTimeout": "02:00:00"
                            },
                            "dataset": {
                                "referenceName": "Canna_PostgreSQL_Collect_Tables",
                                "type": "DatasetReference",
                                "parameters": {
                                    "SchemaName": "@pipeline().parameters.SchemaName",
                                    "TableName": "@pipeline().parameters.TableName"
                                }
                            }
                        }
                    },
                    {
                        "name": "Copy_To_ADLS",
                        "description": "Copy raw Postgres data into ADLS",
                        "type": "Copy",
                        "dependsOn": [
                            {
                                "activity": "No_tm_Tables",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "source": {
                                "type": "PostgreSqlV2Source",
                                "query": {
                                    "value": "@if(equals(variables('WatermarkCol'), 'none'),\n  concat('SELECT * FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName),\n  if(equals(variables('LoadStrategy'), 'ROLLING_30DAY'),\n    concat('SELECT * FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName, ' WHERE ', variables('WatermarkCol'), ' > ''2025-11-02 00:00:00'''),\n    if(equals(variables('LoadStrategy'), 'FULL_RELOAD'),\n      concat('SELECT * FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName),\n      concat('SELECT * FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName, ' WHERE ', variables('WatermarkCol'), ' > ''', pipeline().parameters.LastWatermark, '''')\n    )\n  )\n)",
                                    "type": "Expression"
                                },
                                "queryTimeout": "02:00:00"
                            },
                            "sink": {
                                "type": "JsonSink",
                                "storeSettings": {
                                    "type": "AzureBlobFSWriteSettings"
                                },
                                "formatSettings": {
                                    "type": "JsonWriteSettings"
                                }
                            },
                            "enableStaging": false,
                            "parallelCopies": {
                                "value": "@int(variables('ParallelCopies'))",
                                "type": "Expression"
                            },
                            "enableSkipIncompatibleRow": false,
                            "validateDataConsistency": true,
                            "logSettings": {
                                "enableCopyActivityLog": true,
                                "copyActivityLogSettings": {
                                    "logLevel": "Info",
                                    "enableReliableLogging": false
                                },
                                "logLocationSettings": {
                                    "linkedServiceName": {
                                        "referenceName": "Canna_ADLS",
                                        "type": "LinkedServiceReference"
                                    },
                                    "path": "logs/copy-activity"
                                }
                            },
                            "dataIntegrationUnits": {
                                "value": "@int(variables('DataIntegrationUnits'))",
                                "type": "Expression"
                            }
                        },
                        "inputs": [
                            {
                                "referenceName": "Canna_PostgreSQL_Collect_Tables",
                                "type": "DatasetReference",
                                "parameters": {
                                    "SchemaName": "@pipeline().parameters.SchemaName",
                                    "TableName": "@pipeline().parameters.TableName"
                                }
                            }
                        ],
                        "outputs": [
                            {
                                "referenceName": "ADLS_JSON",
                                "type": "DatasetReference",
                                "parameters": {
                                    "Container": "raw",
                                    "Directory": {
                                        "value": "@concat(\n  pipeline().parameters.SourceDatabase, '/',\n  pipeline().parameters.TableName, '/',\n  pipeline().parameters.RunDate, '/',\n  pipeline().RunId         \n)\n",
                                        "type": "Expression"
                                    },
                                    "FileName": {
                                        "value": "@concat(pipeline().parameters.SchemaName, '_', pipeline().parameters.TableName, '_', formatDateTime(utcNow(), 'yyyyMMdd_HHmmss'), '_', variables('LoadStrategy'), '.json')",
                                        "type": "Expression"
                                    }
                                }
                            }
                        ]
                    },
                    {
                        "name": "Validate_ADLS_File",
                        "description": "Verify the JSON file was created successfully in ADLS",
                        "type": "GetMetadata",
                        "dependsOn": [
                            {
                                "activity": "Copy_To_ADLS",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "dataset": {
                                "referenceName": "ADLS_JSON",
                                "type": "DatasetReference",
                                "parameters": {
                                    "Container": "raw",
                                    "Directory": "@concat(pipeline().parameters.SourceDatabase, '/', formatDateTime(utcnow(), 'yyyy-MM-dd'))",
                                    "FileName": "@concat(pipeline().parameters.SchemaName, '_', pipeline().parameters.TableName, '_', formatDateTime(utcnow(), 'yyyyMMddHHmmss'), '.json')"
                                }
                            },
                            "fieldList": [
                                "exists",
                                "childItems"
                            ],
                            "storeSettings": {
                                "type": "AzureBlobFSReadSettings",
                                "recursive": true,
                                "enablePartitionDiscovery": false
                            },
                            "formatSettings": {
                                "type": "JsonReadSettings"
                            }
                        }
                    },
                    {
                        "name": "Load_To_Snowflake_Bronze",
                        "description": "Load ADLS data into Snowflake Bronze layer",
                        "type": "Script",
                        "dependsOn": [
                            {
                                "activity": "Delete_30_Day_Data",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "linkedServiceName": {
                            "referenceName": "Canna_Snowflake_Collect",
                            "type": "LinkedServiceReference"
                        },
                        "typeProperties": {
                            "scripts": [
                                {
                                    "type": "Query",
                                    "text": {
                                        "value": "@concat(\n  'ALTER SESSION SET TIMEZONE = ''UTC''; ',\n  'USE SCHEMA BRONZE; ',\n\n  'COPY INTO ', \n  if(endsWith(pipeline().parameters.TableName, '_t'), replace(pipeline().parameters.TableName, '_t', ''), pipeline().parameters.TableName), ' (data) ',\n  'FROM @SOURCE_DB.BRONZE.ADLS_RAW_STAGE/',\n      pipeline().parameters.SourceDatabase, '/', pipeline().parameters.TableName, '/',\n      pipeline().parameters.RunDate, '/', pipeline().RunId, '/ ',\n  'PATTERN = ''', '.*', variables('LoadStrategy'), '.*', ''' ',\n  'FILE_FORMAT = (TYPE = JSON) ',\n  'FORCE = ', if(equals(variables('LoadStrategy'), 'FULL_RELOAD'), 'TRUE', 'FALSE'), ' ',\n  'ON_ERROR = ''CONTINUE'';',\n\n  'SELECT COUNT(*) AS rows_loaded, ''', variables('LoadStrategy'), ''' AS strategy_used ',\n  'FROM ', \n  if(endsWith(pipeline().parameters.TableName, '_t'), replace(pipeline().parameters.TableName, '_t', ''), pipeline().parameters.TableName), \n  ' WHERE data IS NOT NULL;'\n)",
                                        "type": "Expression"
                                    }
                                }
                            ],
                            "scriptBlockExecutionTimeout": "02:00:00"
                        }
                    },
                    {
                        "name": "Get_Snowflake_Row_Count",
                        "description": "Get loaded row count from Snowflake Bronze table",
                        "type": "Lookup",
                        "dependsOn": [
                            {
                                "activity": "Load_To_Snowflake_Bronze",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "source": {
                                "type": "SnowflakeV2Source",
                                "query": {
                                    "value": "SELECT COUNT(*) as snowflake_count \nFROM SOURCE_DB.BRONZE.@{if(endsWith(pipeline().parameters.TableName, '_t'), replace(pipeline().parameters.TableName, '_t', ''), pipeline().parameters.TableName)};",
                                    "type": "Expression"
                                },
                                "exportSettings": {
                                    "type": "SnowflakeExportCopyCommand"
                                }
                            },
                            "dataset": {
                                "referenceName": "Snowflake_Collect_Bronze",
                                "type": "DatasetReference",
                                "parameters": {}
                            }
                        }
                    },
                    {
                        "name": "Validate_Row_Count_Match",
                        "description": "Compare Postgres vs Snowflake row counts",
                        "type": "IfCondition",
                        "dependsOn": [
                            {
                                "activity": "Get_Snowflake_Row_Count",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "userProperties": [],
                        "typeProperties": {
                            "expression": {
                                "value": "@if(or(equals(variables('LoadStrategy'), 'ROLLING_30DAY'), equals(variables('LoadStrategy'), 'FULL_RELOAD')), true, equals(string(activity('Get_Source_Row_Count').output.firstRow.row_count), string(activity('Get_Snowflake_Row_Count').output.firstRow.SNOWFLAKE_COUNT)))",
                                "type": "Expression"
                            },
                            "ifFalseActivities": [
                                {
                                    "name": "Set_Validation_Error",
                                    "description": "Mark validation as failed due to row count mismatch",
                                    "type": "SetVariable",
                                    "dependsOn": [],
                                    "policy": {
                                        "secureOutput": false,
                                        "secureInput": false
                                    },
                                    "userProperties": [],
                                    "typeProperties": {
                                        "variableName": "ValidationStatus",
                                        "value": "ROW_COUNT_MISMATCH"
                                    }
                                }
                            ],
                            "ifTrueActivities": [
                                {
                                    "name": "Set_Validation_Status",
                                    "description": "Mark validation as successful",
                                    "type": "SetVariable",
                                    "dependsOn": [],
                                    "policy": {
                                        "secureOutput": false,
                                        "secureInput": false
                                    },
                                    "userProperties": [],
                                    "typeProperties": {
                                        "variableName": "ValidationStatus",
                                        "value": "SUCCESS"
                                    }
                                }
                            ]
                        }
                    },
                    {
                        "name": "Check_Null_Values",
                        "description": "Count null values in key columns",
                        "type": "Lookup",
                        "dependsOn": [
                            {
                                "activity": "Load_To_Snowflake_Bronze",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "source": {
                                "type": "SnowflakeV2Source",
                                "query": {
                                    "value": "SELECT \n    SUM(CASE WHEN data:id IS NULL THEN 1 ELSE 0 END) as null_ids,\n    SUM(CASE WHEN data:name IS NULL THEN 1 ELSE 0 END) as null_names\nFROM SOURCE_DB.BRONZE.@{if(endsWith(pipeline().parameters.TableName, '_t'), replace(pipeline().parameters.TableName, '_t', ''), pipeline().parameters.TableName)}",
                                    "type": "Expression"
                                },
                                "exportSettings": {
                                    "type": "SnowflakeExportCopyCommand"
                                }
                            },
                            "dataset": {
                                "referenceName": "Snowflake_Collect_Bronze",
                                "type": "DatasetReference",
                                "parameters": {}
                            }
                        }
                    },
                    {
                        "name": "Log_Pipeline_Summary",
                        "description": "Insert execution summary into UTILITY.PIPELINE_EXECUTION_LOG",
                        "type": "Script",
                        "dependsOn": [
                            {
                                "activity": "Validate_Row_Count_Match",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            },
                            {
                                "activity": "Check_Null_Values",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "linkedServiceName": {
                            "referenceName": "Canna_Snowflake_Collect",
                            "type": "LinkedServiceReference"
                        },
                        "typeProperties": {
                            "scripts": [
                                {
                                    "type": "Query",
                                    "text": {
                                        "value": "@concat(\n  'INSERT INTO SOURCE_DB.UTILITY.PIPELINE_EXECUTION_LOG VALUES (''',\n  pipeline().RunId, ''', ''',\n  pipeline().parameters.TableName, ''', ''',\n  formatDateTime(utcnow(), 'yyyy-MM-dd'), ''', ''',\n  utcnow(), ''', ',\n  if(empty(string(activity('Get_Source_Row_Count').output.firstRow.row_count)), '0', string(activity('Get_Source_Row_Count').output.firstRow.row_count)), ', ',\n  if(empty(string(activity('Get_Snowflake_Row_Count').output.firstRow.SNOWFLAKE_COUNT)), '0', string(activity('Get_Snowflake_Row_Count').output.firstRow.SNOWFLAKE_COUNT)), ', ',\n  if(equals(variables('ValidationStatus'), 'SUCCESS'), 'TRUE', 'FALSE'), ', ',\n  if(empty(string(activity('Check_Duplicates').output.firstRow.duplicate_count)), '0', string(activity('Check_Duplicates').output.firstRow.duplicate_count)), ', ',\n  if(empty(string(activity('Check_Null_Values').output.firstRow.NULL_IDS)), '0', string(activity('Check_Null_Values').output.firstRow.NULL_IDS)), ', ',\n  if(empty(string(activity('Check_Null_Values').output.firstRow.NULL_NAMES)), '0', string(activity('Check_Null_Values').output.firstRow.NULL_NAMES)), ', ''',\n  variables('ValidationStatus'), ''', ',\n  '0', \n  ');'\n)",
                                        "type": "Expression"
                                    }
                                }
                            ],
                            "scriptBlockExecutionTimeout": "02:00:00"
                        }
                    },
                    {
                        "name": "Check_Duplicates",
                        "description": "Check for duplicate rows in the table",
                        "type": "Lookup",
                        "dependsOn": [
                            {
                                "activity": "Get_Source_Row_Count",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "source": {
                                "type": "PostgreSqlV2Source",
                                "query": {
                                    "value": "@if(equals(variables('LoadStrategy'), 'ROLLING_30DAY'),\n  concat('SELECT (SELECT COUNT(*) FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName, ' WHERE ', variables('WatermarkCol'), ' > ''2025-11-02 00:00:00'') - (SELECT COUNT(*) FROM (SELECT DISTINCT * FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName, ' WHERE ', variables('WatermarkCol'), ' > ''2025-11-02 00:00:00'') t) as duplicate_count'),\n  concat('SELECT (SELECT COUNT(*) FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName, ') - (SELECT COUNT(*) FROM (SELECT DISTINCT * FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName, ') t) as duplicate_count')\n)",
                                    "type": "Expression"
                                },
                                "queryTimeout": "02:00:00"
                            },
                            "dataset": {
                                "referenceName": "Canna_PostgreSQL_Collect_Tables",
                                "type": "DatasetReference",
                                "parameters": {
                                    "SchemaName": "@pipeline().parameters.SchemaName",
                                    "TableName": "@pipeline().parameters.TableName"
                                }
                            }
                        }
                    },
                    {
                        "name": "Delete_30_Day_Data",
                        "type": "Script",
                        "dependsOn": [
                            {
                                "activity": "Validate_ADLS_File",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "linkedServiceName": {
                            "referenceName": "Canna_Snowflake_Collect",
                            "type": "LinkedServiceReference"
                        },
                        "typeProperties": {
                            "scripts": [
                                {
                                    "type": "Query",
                                    "text": {
                                        "value": "@concat(\n  'USE SCHEMA BRONZE; ',\n  'ALTER SESSION SET TIMEZONE = ''UTC''; ',\n  if(equals(variables('LoadStrategy'), 'ROLLING_30DAY'),\n    concat('DELETE FROM ',\n      if(endsWith(pipeline().parameters.TableName, '_t'), replace(pipeline().parameters.TableName, '_t', ''), pipeline().parameters.TableName),\n      ' WHERE TO_DATE(CONVERT_TIMEZONE(''UTC'', TRY_TO_TIMESTAMP_TZ(data:\"', variables('WatermarkCol'), '\"::string))) >= ''2025-11-02''; '),\n    if(equals(variables('LoadStrategy'), 'FULL_RELOAD'),\n      concat('TRUNCATE TABLE ',\n        if(endsWith(pipeline().parameters.TableName, '_t'), replace(pipeline().parameters.TableName, '_t', ''), pipeline().parameters.TableName),\n        '; '),\n      'SELECT ''No cleanup needed for incremental strategy'' as status; '\n    )\n  ),\n  'SELECT ''', variables('LoadStrategy'), ''' as strategy_applied;'\n)",
                                        "type": "Expression"
                                    }
                                }
                            ],
                            "scriptBlockExecutionTimeout": "02:00:00"
                        }
                    },
                    {
                        "name": "Get_Table_Strategy",
                        "type": "Lookup",
                        "dependsOn": [],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "source": {
                                "type": "SnowflakeV2Source",
                                "query": {
                                    "value": "SELECT \n       COALESCE(load_strategy, 'INCREMENTAL') as load_strategy,\n       COALESCE(parallel_copies, 8) as parallel_copies,\n       COALESCE(data_integration_units, 16) as data_integration_units,\n       COALESCE(watermark_column, 'tm') as watermark_column\n   FROM SOURCE_DB.UTILITY.TABLE_STRATEGY_CONFIG \n   WHERE table_name = '@{pipeline().parameters.TableName}'\n   AND is_active = TRUE",
                                    "type": "Expression"
                                },
                                "exportSettings": {
                                    "type": "SnowflakeExportCopyCommand"
                                }
                            },
                            "dataset": {
                                "referenceName": "Snowflake_Collect_Bronze",
                                "type": "DatasetReference",
                                "parameters": {}
                            }
                        }
                    },
                    {
                        "name": "Set_Strategy_From_Config",
                        "type": "SetVariable",
                        "dependsOn": [
                            {
                                "activity": "Get_Table_Strategy",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "variableName": "LoadStrategy",
                            "value": {
                                "value": "@activity('Get_Table_Strategy').output.firstRow.load_strategy",
                                "type": "Expression"
                            }
                        }
                    },
                    {
                        "name": "Set_Parallel_Copies",
                        "type": "SetVariable",
                        "dependsOn": [
                            {
                                "activity": "Set_Strategy_From_Config",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "variableName": "ParallelCopies",
                            "value": {
                                "value": "@string(activity('Get_Table_Strategy').output.firstRow.parallel_copies)",
                                "type": "Expression"
                            }
                        }
                    },
                    {
                        "name": "Set_DIU",
                        "type": "SetVariable",
                        "dependsOn": [
                            {
                                "activity": "Set_Parallel_Copies",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "variableName": "DataIntegrationUnits",
                            "value": {
                                "value": "@string(activity('Get_Table_Strategy').output.firstRow.data_integration_units)",
                                "type": "Expression"
                            }
                        }
                    },
                    {
                        "name": "Set_Watermark_Column",
                        "type": "SetVariable",
                        "dependsOn": [
                            {
                                "activity": "Set_DIU",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "variableName": "WatermarkCol",
                            "value": {
                                "value": "@activity('Get_Table_Strategy').output.firstRow.watermark_column",
                                "type": "Expression"
                            }
                        }
                    },
                    {
                        "name": "No_tm_Tables",
                        "type": "IfCondition",
                        "dependsOn": [
                            {
                                "activity": "Check_Duplicates",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "userProperties": [],
                        "typeProperties": {
                            "expression": {
                                "value": "@not(equals(variables('WatermarkCol'), 'none'))",
                                "type": "Expression"
                            },
                            "ifTrueActivities": [
                                {
                                    "name": "Get_Max_Watermark",
                                    "type": "Lookup",
                                    "dependsOn": [],
                                    "policy": {
                                        "timeout": "0.12:00:00",
                                        "retry": 0,
                                        "retryIntervalInSeconds": 30,
                                        "secureOutput": false,
                                        "secureInput": false
                                    },
                                    "userProperties": [],
                                    "typeProperties": {
                                        "source": {
                                            "type": "PostgreSqlV2Source",
                                            "query": {
                                                "value": "@concat('SELECT MAX(', variables('WatermarkCol'), ')::timestamp as max_watermark FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName)\n",
                                                "type": "Expression"
                                            },
                                            "queryTimeout": "02:00:00"
                                        },
                                        "dataset": {
                                            "referenceName": "Canna_PostgreSQL_Collect_Tables",
                                            "type": "DatasetReference",
                                            "parameters": {
                                                "SchemaName": "collect",
                                                "TableName": "cc_customers"
                                            }
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    {
                        "name": "Update_tm_Tables",
                        "type": "IfCondition",
                        "dependsOn": [
                            {
                                "activity": "Log_Pipeline_Summary",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "userProperties": [],
                        "typeProperties": {
                            "expression": {
                                "value": "@not(equals(variables('WatermarkCol'), 'none'))",
                                "type": "Expression"
                            },
                            "ifTrueActivities": [
                                {
                                    "name": "Update_Watermark",
                                    "type": "Lookup",
                                    "dependsOn": [],
                                    "policy": {
                                        "timeout": "0.12:00:00",
                                        "retry": 0,
                                        "retryIntervalInSeconds": 30,
                                        "secureOutput": false,
                                        "secureInput": false
                                    },
                                    "userProperties": [],
                                    "typeProperties": {
                                        "source": {
                                            "type": "PostgreSqlV2Source",
                                            "query": {
                                                "value": "WITH update_result AS (\n     INSERT INTO collect.watermark_control (table_name, last_watermark, updated_at)\n     VALUES (\n       '@{pipeline().parameters.TableName}',\n       '@{activity('Get_Max_Watermark').output.firstRow.max_watermark}'::timestamp,\n       CURRENT_TIMESTAMP\n     )\n     ON CONFLICT (table_name) \n     DO UPDATE SET \n       last_watermark = EXCLUDED.last_watermark,\n       updated_at = CURRENT_TIMESTAMP\n     RETURNING table_name\n   )\n   SELECT COUNT(*) as rows_updated FROM update_result;",
                                                "type": "Expression"
                                            },
                                            "queryTimeout": "02:00:00"
                                        },
                                        "dataset": {
                                            "referenceName": "Canna_PostgreSQL_Collect_Tables",
                                            "type": "DatasetReference",
                                            "parameters": {
                                                "SchemaName": "collect",
                                                "TableName": "cc_customers"
                                            }
                                        }
                                    }
                                }
                            ]
                        }
                    }
                ],
                "policy": {
                    "elapsedTimeMetric": {}
                },
                "parameters": {
                    "SourceDatabase": {
                        "type": "string",
                        "defaultValue": "collect"
                    },
                    "SchemaName": {
                        "type": "string",
                        "defaultValue": "collect"
                    },
                    "TableName": {
                        "type": "string"
                    },
                    "WatermarkColumn": {
                        "type": "string",
                        "defaultValue": "tm"
                    },
                    "LastWatermark": {
                        "type": "string",
                        "defaultValue": "2000-01-01 00:00:00"
                    },
                    "RunDate": {
                        "type": "string"
                    }
                },
                "variables": {
                    "ValidationStatus": {
                        "type": "String"
                    },
                    "LoadStrategy": {
                        "type": "String",
                        "defaultValue": "INCREMENTAL"
                    },
                    "ParallelCopies": {
                        "type": "String",
                        "defaultValue": "8"
                    },
                    "DataIntegrationUnits": {
                        "type": "String",
                        "defaultValue": "16"
                    },
                    "WatermarkCol": {
                        "type": "String",
                        "defaultValue": "tm"
                    }
                },
                "folder": {
                    "name": "Archive"
                },
                "annotations": [],
                "lastPublishTime": "2025-09-18T14:21:00Z"
            },
            "dependsOn": [
                "[concat(variables('factoryId'), '/datasets/Canna_PostgreSQL_Collect_Tables')]",
                "[concat(variables('factoryId'), '/datasets/ADLS_JSON')]",
                "[concat(variables('factoryId'), '/linkedServices/Canna_Snowflake_Collect')]",
                "[concat(variables('factoryId'), '/datasets/Snowflake_Collect_Bronze')]",
                "[concat(variables('factoryId'), '/linkedServices/Canna_ADLS')]"
            ]
        },
        {
            "name": "[concat(parameters('factoryName'), '/Collect_Table_With_Validation_Incremental_JSON_TESTING')]",
            "type": "Microsoft.DataFactory/factories/pipelines",
            "apiVersion": "2018-06-01",
            "properties": {
                "activities": [
                    {
                        "name": "Get_Source_Row_Count",
                        "description": "Get Postgres SQL table row count ",
                        "type": "Lookup",
                        "dependsOn": [
                            {
                                "activity": "Set_Watermark_Column",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "source": {
                                "type": "PostgreSqlV2Source",
                                "query": {
                                    "value": "@if(equals(variables('WatermarkCol'), 'none'),\n  concat('SELECT COUNT(*) as row_count FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName),\n  if(equals(variables('LoadStrategy'), 'ROLLING_30DAY'),\n    concat('SELECT COUNT(*) as row_count FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName, ' WHERE ', variables('WatermarkCol'), ' >= CURRENT_DATE - INTERVAL ''30 days'''),\n    if(equals(variables('LoadStrategy'), 'FULL_RELOAD'),\n      concat('SELECT COUNT(*) as row_count FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName),\n      concat('SELECT COUNT(*) as row_count FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName, ' WHERE ', variables('WatermarkCol'), ' > ''', pipeline().parameters.LastWatermark, '''')\n    )\n  )\n)",
                                    "type": "Expression"
                                },
                                "queryTimeout": "02:00:00"
                            },
                            "dataset": {
                                "referenceName": "Canna_PostgreSQL_Collect_Tables",
                                "type": "DatasetReference",
                                "parameters": {
                                    "SchemaName": "@pipeline().parameters.SchemaName",
                                    "TableName": "@pipeline().parameters.TableName"
                                }
                            }
                        }
                    },
                    {
                        "name": "Copy_To_ADLS",
                        "description": "Copy raw Postgres data into ADLS",
                        "type": "Copy",
                        "dependsOn": [
                            {
                                "activity": "No_tm_Tables",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "source": {
                                "type": "PostgreSqlV2Source",
                                "query": {
                                    "value": "@if(equals(variables('WatermarkCol'), 'none'),\n  concat('SELECT * FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName),\n  if(equals(variables('LoadStrategy'), 'ROLLING_30DAY'),\n    concat('SELECT * FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName, ' WHERE ', variables('WatermarkCol'), ' >= CURRENT_DATE - INTERVAL ''30 days'''),\n    if(equals(variables('LoadStrategy'), 'FULL_RELOAD'),\n      concat('SELECT * FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName),\n      concat('SELECT * FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName, ' WHERE ', variables('WatermarkCol'), ' > ''', pipeline().parameters.LastWatermark, '''')\n    )\n  )\n)",
                                    "type": "Expression"
                                },
                                "queryTimeout": "02:00:00"
                            },
                            "sink": {
                                "type": "JsonSink",
                                "storeSettings": {
                                    "type": "AzureBlobFSWriteSettings"
                                },
                                "formatSettings": {
                                    "type": "JsonWriteSettings"
                                }
                            },
                            "enableStaging": false,
                            "parallelCopies": {
                                "value": "@int(variables('ParallelCopies'))",
                                "type": "Expression"
                            },
                            "enableSkipIncompatibleRow": false,
                            "validateDataConsistency": true,
                            "logSettings": {
                                "enableCopyActivityLog": true,
                                "copyActivityLogSettings": {
                                    "logLevel": "Info",
                                    "enableReliableLogging": false
                                },
                                "logLocationSettings": {
                                    "linkedServiceName": {
                                        "referenceName": "Canna_ADLS",
                                        "type": "LinkedServiceReference"
                                    },
                                    "path": "logs/copy-activity"
                                }
                            },
                            "dataIntegrationUnits": {
                                "value": "@int(variables('DataIntegrationUnits'))",
                                "type": "Expression"
                            }
                        },
                        "inputs": [
                            {
                                "referenceName": "Canna_PostgreSQL_Collect_Tables",
                                "type": "DatasetReference",
                                "parameters": {
                                    "SchemaName": "@pipeline().parameters.SchemaName",
                                    "TableName": "@pipeline().parameters.TableName"
                                }
                            }
                        ],
                        "outputs": [
                            {
                                "referenceName": "ADLS_JSON",
                                "type": "DatasetReference",
                                "parameters": {
                                    "Container": "raw",
                                    "Directory": {
                                        "value": "@concat(\n  pipeline().parameters.SourceDatabase, '/',\n  pipeline().parameters.TableName, '/',\n  pipeline().parameters.RunDate, '/',\n  pipeline().RunId         \n)\n",
                                        "type": "Expression"
                                    },
                                    "FileName": {
                                        "value": "@concat(pipeline().parameters.SchemaName, '_', pipeline().parameters.TableName, '_', formatDateTime(utcNow(), 'yyyyMMdd_HHmmss'), '_', variables('LoadStrategy'), '.json')",
                                        "type": "Expression"
                                    }
                                }
                            }
                        ]
                    },
                    {
                        "name": "Validate_ADLS_File",
                        "description": "Verify the JSON file was created successfully in ADLS",
                        "type": "GetMetadata",
                        "dependsOn": [
                            {
                                "activity": "Copy_To_ADLS",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "dataset": {
                                "referenceName": "ADLS_JSON",
                                "type": "DatasetReference",
                                "parameters": {
                                    "Container": "raw",
                                    "Directory": "@concat(pipeline().parameters.SourceDatabase, '/', formatDateTime(utcnow(), 'yyyy-MM-dd'))",
                                    "FileName": "@concat(pipeline().parameters.SchemaName, '_', pipeline().parameters.TableName, '_', formatDateTime(utcnow(), 'yyyyMMddHHmmss'), '.json')"
                                }
                            },
                            "fieldList": [
                                "exists",
                                "childItems"
                            ],
                            "storeSettings": {
                                "type": "AzureBlobFSReadSettings",
                                "recursive": true,
                                "enablePartitionDiscovery": false
                            },
                            "formatSettings": {
                                "type": "JsonReadSettings"
                            }
                        }
                    },
                    {
                        "name": "Load_To_Snowflake_Bronze",
                        "description": "Load ADLS data into Snowflake Bronze layer",
                        "type": "Script",
                        "dependsOn": [
                            {
                                "activity": "Delete_30_Day_Data",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "linkedServiceName": {
                            "referenceName": "Canna_Snowflake_Collect",
                            "type": "LinkedServiceReference"
                        },
                        "typeProperties": {
                            "scripts": [
                                {
                                    "type": "Query",
                                    "text": {
                                        "value": "@concat(\n  'ALTER SESSION SET TIMEZONE = ''UTC''; ',\n  'USE SCHEMA BRONZE; ',\n\n  'CREATE TABLE IF NOT EXISTS ', \n  if(endsWith(pipeline().parameters.TableName, '_t'), replace(pipeline().parameters.TableName, '_t', ''), pipeline().parameters.TableName), ' (',\n  '  data VARIANT,',\n  '  load_timestamp TIMESTAMP_NTZ DEFAULT CURRENT_TIMESTAMP()',\n  ');',\n\n  'COPY INTO ', \n  if(endsWith(pipeline().parameters.TableName, '_t'), replace(pipeline().parameters.TableName, '_t', ''), pipeline().parameters.TableName), ' (data) ',\n  'FROM @SOURCE_DB.BRONZE.ADLS_RAW_STAGE/',\n      pipeline().parameters.SourceDatabase, '/', pipeline().parameters.TableName, '/',\n      pipeline().parameters.RunDate, '/', pipeline().RunId, '/ ',\n  'PATTERN = ''', '.*', variables('LoadStrategy'), '.*', ''' ',\n  'FILE_FORMAT = (TYPE = JSON) ',\n  'FORCE = ', if(equals(variables('LoadStrategy'), 'FULL_RELOAD'), 'TRUE', 'FALSE'), ' ',\n  'ON_ERROR = ''CONTINUE'';',\n\n  'GRANT SELECT ON TABLE ', \n  if(endsWith(pipeline().parameters.TableName, '_t'), replace(pipeline().parameters.TableName, '_t', ''), pipeline().parameters.TableName), \n  ' TO ROLE SYSADMIN;',\n\n  'SELECT COUNT(*) AS rows_loaded, ''', variables('LoadStrategy'), ''' AS strategy_used ',\n  'FROM ', \n  if(endsWith(pipeline().parameters.TableName, '_t'), replace(pipeline().parameters.TableName, '_t', ''), pipeline().parameters.TableName), \n  ' WHERE data IS NOT NULL;'\n)",
                                        "type": "Expression"
                                    }
                                }
                            ],
                            "scriptBlockExecutionTimeout": "02:00:00"
                        }
                    },
                    {
                        "name": "Get_Snowflake_Row_Count",
                        "description": "Get loaded row count from Snowflake Bronze table",
                        "type": "Lookup",
                        "dependsOn": [
                            {
                                "activity": "Load_To_Snowflake_Bronze",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "source": {
                                "type": "SnowflakeV2Source",
                                "query": {
                                    "value": "SELECT COUNT(*) as snowflake_count \nFROM SOURCE_DB.BRONZE.@{if(endsWith(pipeline().parameters.TableName, '_t'), replace(pipeline().parameters.TableName, '_t', ''), pipeline().parameters.TableName)};",
                                    "type": "Expression"
                                },
                                "exportSettings": {
                                    "type": "SnowflakeExportCopyCommand"
                                }
                            },
                            "dataset": {
                                "referenceName": "Snowflake_Collect_Bronze",
                                "type": "DatasetReference",
                                "parameters": {}
                            }
                        }
                    },
                    {
                        "name": "Validate_Row_Count_Match",
                        "description": "Compare Postgres vs Snowflake row counts",
                        "type": "IfCondition",
                        "dependsOn": [
                            {
                                "activity": "Get_Snowflake_Row_Count",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "userProperties": [],
                        "typeProperties": {
                            "expression": {
                                "value": "@equals(string(activity('Get_Source_Row_Count').output.firstRow.row_count), string(activity('Get_Snowflake_Row_Count').output.firstRow.SNOWFLAKE_COUNT))",
                                "type": "Expression"
                            },
                            "ifFalseActivities": [
                                {
                                    "name": "Set_Validation_Error",
                                    "description": "Mark validation as failed due to row count mismatch",
                                    "type": "SetVariable",
                                    "dependsOn": [],
                                    "policy": {
                                        "secureOutput": false,
                                        "secureInput": false
                                    },
                                    "userProperties": [],
                                    "typeProperties": {
                                        "variableName": "ValidationStatus",
                                        "value": "ROW_COUNT_MISMATCH"
                                    }
                                }
                            ],
                            "ifTrueActivities": [
                                {
                                    "name": "Set_Validation_Status",
                                    "description": "Mark validation as successful",
                                    "type": "SetVariable",
                                    "dependsOn": [],
                                    "policy": {
                                        "secureOutput": false,
                                        "secureInput": false
                                    },
                                    "userProperties": [],
                                    "typeProperties": {
                                        "variableName": "ValidationStatus",
                                        "value": "SUCCESS"
                                    }
                                }
                            ]
                        }
                    },
                    {
                        "name": "Check_Null_Values",
                        "description": "Count null values in key columns",
                        "type": "Lookup",
                        "dependsOn": [
                            {
                                "activity": "Load_To_Snowflake_Bronze",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "source": {
                                "type": "SnowflakeV2Source",
                                "query": {
                                    "value": "SELECT \n    SUM(CASE WHEN data:id IS NULL THEN 1 ELSE 0 END) as null_ids,\n    SUM(CASE WHEN data:name IS NULL THEN 1 ELSE 0 END) as null_names\nFROM SOURCE_DB.BRONZE.@{if(endsWith(pipeline().parameters.TableName, '_t'), replace(pipeline().parameters.TableName, '_t', ''), pipeline().parameters.TableName)}",
                                    "type": "Expression"
                                },
                                "exportSettings": {
                                    "type": "SnowflakeExportCopyCommand"
                                }
                            },
                            "dataset": {
                                "referenceName": "Snowflake_Collect_Bronze",
                                "type": "DatasetReference",
                                "parameters": {}
                            }
                        }
                    },
                    {
                        "name": "Log_Pipeline_Summary",
                        "description": "Insert execution summary into UTILITY.PIPELINE_EXECUTION_LOG",
                        "type": "Script",
                        "dependsOn": [
                            {
                                "activity": "Validate_Row_Count_Match",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            },
                            {
                                "activity": "Check_Null_Values",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "linkedServiceName": {
                            "referenceName": "Canna_Snowflake_Collect",
                            "type": "LinkedServiceReference"
                        },
                        "typeProperties": {
                            "scripts": [
                                {
                                    "type": "Query",
                                    "text": {
                                        "value": "@concat(\n  'INSERT INTO SOURCE_DB.UTILITY.PIPELINE_EXECUTION_LOG VALUES (''',\n  pipeline().RunId, ''', ''',\n  pipeline().parameters.TableName, ''', ''',\n  formatDateTime(utcnow(), 'yyyy-MM-dd'), ''', ''',\n  utcnow(), ''', ',\n  if(empty(string(activity('Get_Source_Row_Count').output.firstRow.row_count)), '0', string(activity('Get_Source_Row_Count').output.firstRow.row_count)), ', ',\n  if(empty(string(activity('Get_Snowflake_Row_Count').output.firstRow.SNOWFLAKE_COUNT)), '0', string(activity('Get_Snowflake_Row_Count').output.firstRow.SNOWFLAKE_COUNT)), ', ',\n  if(equals(variables('ValidationStatus'), 'SUCCESS'), 'TRUE', 'FALSE'), ', ',\n  if(empty(string(activity('Check_Duplicates').output.firstRow.duplicate_count)), '0', string(activity('Check_Duplicates').output.firstRow.duplicate_count)), ', ',\n  if(empty(string(activity('Check_Null_Values').output.firstRow.NULL_IDS)), '0', string(activity('Check_Null_Values').output.firstRow.NULL_IDS)), ', ',\n  if(empty(string(activity('Check_Null_Values').output.firstRow.NULL_NAMES)), '0', string(activity('Check_Null_Values').output.firstRow.NULL_NAMES)), ', ''',\n  variables('ValidationStatus'), ''', ',\n  '0', \n  ');'\n)",
                                        "type": "Expression"
                                    }
                                }
                            ],
                            "scriptBlockExecutionTimeout": "02:00:00"
                        }
                    },
                    {
                        "name": "Check_Duplicates",
                        "description": "Check for duplicate rows in the table",
                        "type": "Lookup",
                        "dependsOn": [
                            {
                                "activity": "Get_Source_Row_Count",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "source": {
                                "type": "PostgreSqlV2Source",
                                "query": {
                                    "value": "@if(equals(variables('LoadStrategy'), 'ROLLING_30DAY'),\n  concat('SELECT (SELECT COUNT(*) FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName, ' WHERE ', variables('WatermarkCol'), ' >= CURRENT_DATE - INTERVAL ''30 days'') - (SELECT COUNT(*) FROM (SELECT DISTINCT * FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName, ' WHERE ', variables('WatermarkCol'), ' >= CURRENT_DATE - INTERVAL ''30 days'') t) as duplicate_count'),\n  concat('SELECT (SELECT COUNT(*) FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName, ') - (SELECT COUNT(*) FROM (SELECT DISTINCT * FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName, ') t) as duplicate_count')\n)",
                                    "type": "Expression"
                                },
                                "queryTimeout": "02:00:00"
                            },
                            "dataset": {
                                "referenceName": "Canna_PostgreSQL_Collect_Tables",
                                "type": "DatasetReference",
                                "parameters": {
                                    "SchemaName": "@pipeline().parameters.SchemaName",
                                    "TableName": "@pipeline().parameters.TableName"
                                }
                            }
                        }
                    },
                    {
                        "name": "Delete_30_Day_Data",
                        "type": "Script",
                        "dependsOn": [
                            {
                                "activity": "Validate_ADLS_File",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "linkedServiceName": {
                            "referenceName": "Canna_Snowflake_Collect",
                            "type": "LinkedServiceReference"
                        },
                        "typeProperties": {
                            "scripts": [
                                {
                                    "type": "Query",
                                    "text": {
                                        "value": "@concat(\n  'USE SCHEMA BRONZE; ',\n  'CREATE TABLE IF NOT EXISTS ', \n  if(endsWith(pipeline().parameters.TableName, '_t'), replace(pipeline().parameters.TableName, '_t', ''), pipeline().parameters.TableName), \n  ' (data VARIANT); ',\n  'ALTER SESSION SET TIMEZONE = ''UTC''; ',\n  if(equals(variables('LoadStrategy'), 'ROLLING_30DAY'),\n    concat('DELETE FROM ', \n      if(endsWith(pipeline().parameters.TableName, '_t'), replace(pipeline().parameters.TableName, '_t', ''), pipeline().parameters.TableName), \n      ' WHERE TO_DATE(CONVERT_TIMEZONE(''UTC'', TRY_TO_TIMESTAMP_TZ(data:\"', variables('WatermarkCol'), '\"::string))) >= DATEADD(day, -30, CURRENT_DATE()); '),\n    if(equals(variables('LoadStrategy'), 'FULL_RELOAD'),\n      concat('TRUNCATE TABLE ', \n        if(endsWith(pipeline().parameters.TableName, '_t'), replace(pipeline().parameters.TableName, '_t', ''), pipeline().parameters.TableName), \n        '; '),\n      'SELECT ''No cleanup needed for incremental strategy'' as status; '\n    )\n  ),\n  'SELECT ''', variables('LoadStrategy'), ''' as strategy_applied;'\n)",
                                        "type": "Expression"
                                    }
                                }
                            ],
                            "scriptBlockExecutionTimeout": "02:00:00"
                        }
                    },
                    {
                        "name": "Get_Table_Strategy",
                        "type": "Lookup",
                        "dependsOn": [],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "source": {
                                "type": "SnowflakeV2Source",
                                "query": {
                                    "value": "SELECT \n       COALESCE(load_strategy, 'INCREMENTAL') as load_strategy,\n       COALESCE(parallel_copies, 8) as parallel_copies,\n       COALESCE(data_integration_units, 16) as data_integration_units,\n       COALESCE(watermark_column, 'tm') as watermark_column\n   FROM SOURCE_DB.UTILITY.TABLE_STRATEGY_CONFIG \n   WHERE table_name = '@{pipeline().parameters.TableName}'\n   AND is_active = TRUE",
                                    "type": "Expression"
                                },
                                "exportSettings": {
                                    "type": "SnowflakeExportCopyCommand"
                                }
                            },
                            "dataset": {
                                "referenceName": "Snowflake_Collect_Bronze",
                                "type": "DatasetReference",
                                "parameters": {}
                            }
                        }
                    },
                    {
                        "name": "Set_Strategy_From_Config",
                        "type": "SetVariable",
                        "dependsOn": [
                            {
                                "activity": "Get_Table_Strategy",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "variableName": "LoadStrategy",
                            "value": {
                                "value": "@activity('Get_Table_Strategy').output.firstRow.load_strategy",
                                "type": "Expression"
                            }
                        }
                    },
                    {
                        "name": "Set_Parallel_Copies",
                        "type": "SetVariable",
                        "dependsOn": [
                            {
                                "activity": "Set_Strategy_From_Config",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "variableName": "ParallelCopies",
                            "value": {
                                "value": "@string(activity('Get_Table_Strategy').output.firstRow.parallel_copies)",
                                "type": "Expression"
                            }
                        }
                    },
                    {
                        "name": "Set_DIU",
                        "type": "SetVariable",
                        "dependsOn": [
                            {
                                "activity": "Set_Parallel_Copies",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "variableName": "DataIntegrationUnits",
                            "value": {
                                "value": "@string(activity('Get_Table_Strategy').output.firstRow.data_integration_units)",
                                "type": "Expression"
                            }
                        }
                    },
                    {
                        "name": "Set_Watermark_Column",
                        "type": "SetVariable",
                        "dependsOn": [
                            {
                                "activity": "Set_DIU",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "variableName": "WatermarkCol",
                            "value": {
                                "value": "@activity('Get_Table_Strategy').output.firstRow.watermark_column",
                                "type": "Expression"
                            }
                        }
                    },
                    {
                        "name": "No_tm_Tables",
                        "type": "IfCondition",
                        "dependsOn": [
                            {
                                "activity": "Check_Duplicates",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "userProperties": [],
                        "typeProperties": {
                            "expression": {
                                "value": "@not(equals(variables('WatermarkCol'), 'none'))",
                                "type": "Expression"
                            },
                            "ifTrueActivities": [
                                {
                                    "name": "Get_Max_Watermark",
                                    "type": "Lookup",
                                    "dependsOn": [],
                                    "policy": {
                                        "timeout": "0.12:00:00",
                                        "retry": 0,
                                        "retryIntervalInSeconds": 30,
                                        "secureOutput": false,
                                        "secureInput": false
                                    },
                                    "userProperties": [],
                                    "typeProperties": {
                                        "source": {
                                            "type": "PostgreSqlV2Source",
                                            "query": {
                                                "value": "@concat('SELECT MAX(', variables('WatermarkCol'), ')::timestamp as max_watermark FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName)\n",
                                                "type": "Expression"
                                            },
                                            "queryTimeout": "02:00:00"
                                        },
                                        "dataset": {
                                            "referenceName": "Canna_PostgreSQL_Collect_Tables",
                                            "type": "DatasetReference",
                                            "parameters": {
                                                "SchemaName": "collect",
                                                "TableName": "cc_customers"
                                            }
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    {
                        "name": "Update_tm_Tables",
                        "type": "IfCondition",
                        "dependsOn": [
                            {
                                "activity": "Log_Pipeline_Summary",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "userProperties": [],
                        "typeProperties": {
                            "expression": {
                                "value": "@not(equals(variables('WatermarkCol'), 'none'))",
                                "type": "Expression"
                            },
                            "ifTrueActivities": [
                                {
                                    "name": "Update_Watermark",
                                    "type": "Lookup",
                                    "dependsOn": [],
                                    "policy": {
                                        "timeout": "0.12:00:00",
                                        "retry": 0,
                                        "retryIntervalInSeconds": 30,
                                        "secureOutput": false,
                                        "secureInput": false
                                    },
                                    "userProperties": [],
                                    "typeProperties": {
                                        "source": {
                                            "type": "PostgreSqlV2Source",
                                            "query": {
                                                "value": "WITH update_result AS (\n     INSERT INTO collect.watermark_control (table_name, last_watermark, updated_at)\n     VALUES (\n       '@{pipeline().parameters.TableName}',\n       '@{activity('Get_Max_Watermark').output.firstRow.max_watermark}'::timestamp,\n       CURRENT_TIMESTAMP\n     )\n     ON CONFLICT (table_name) \n     DO UPDATE SET \n       last_watermark = EXCLUDED.last_watermark,\n       updated_at = CURRENT_TIMESTAMP\n     RETURNING table_name\n   )\n   SELECT COUNT(*) as rows_updated FROM update_result;",
                                                "type": "Expression"
                                            },
                                            "queryTimeout": "02:00:00"
                                        },
                                        "dataset": {
                                            "referenceName": "Canna_PostgreSQL_Collect_Tables",
                                            "type": "DatasetReference",
                                            "parameters": {
                                                "SchemaName": "collect",
                                                "TableName": "cc_customers"
                                            }
                                        }
                                    }
                                }
                            ]
                        }
                    }
                ],
                "policy": {
                    "elapsedTimeMetric": {}
                },
                "parameters": {
                    "SourceDatabase": {
                        "type": "string",
                        "defaultValue": "collect"
                    },
                    "SchemaName": {
                        "type": "string",
                        "defaultValue": "collect"
                    },
                    "TableName": {
                        "type": "string"
                    },
                    "WatermarkColumn": {
                        "type": "string",
                        "defaultValue": "tm"
                    },
                    "LastWatermark": {
                        "type": "string",
                        "defaultValue": "2000-01-01 00:00:00"
                    },
                    "RunDate": {
                        "type": "string"
                    }
                },
                "variables": {
                    "ValidationStatus": {
                        "type": "String"
                    },
                    "LoadStrategy": {
                        "type": "String",
                        "defaultValue": "INCREMENTAL"
                    },
                    "ParallelCopies": {
                        "type": "String",
                        "defaultValue": "8"
                    },
                    "DataIntegrationUnits": {
                        "type": "String",
                        "defaultValue": "16"
                    },
                    "WatermarkCol": {
                        "type": "String",
                        "defaultValue": "tm"
                    }
                },
                "folder": {
                    "name": "Archive"
                },
                "annotations": [],
                "lastPublishTime": "2025-09-18T14:21:00Z"
            },
            "dependsOn": [
                "[concat(variables('factoryId'), '/datasets/Canna_PostgreSQL_Collect_Tables')]",
                "[concat(variables('factoryId'), '/datasets/ADLS_JSON')]",
                "[concat(variables('factoryId'), '/linkedServices/Canna_Snowflake_Collect')]",
                "[concat(variables('factoryId'), '/datasets/Snowflake_Collect_Bronze')]",
                "[concat(variables('factoryId'), '/linkedServices/Canna_ADLS')]"
            ]
        },
        {
            "name": "[concat(parameters('factoryName'), '/Collect_Table_With_Validation_Incremental_JSON_TM')]",
            "type": "Microsoft.DataFactory/factories/pipelines",
            "apiVersion": "2018-06-01",
            "properties": {
                "activities": [
                    {
                        "name": "Get_Source_Row_Count",
                        "description": "Get Postgres SQL table row count ",
                        "type": "Lookup",
                        "dependsOn": [
                            {
                                "activity": "Set_Watermark_Column",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "source": {
                                "type": "PostgreSqlV2Source",
                                "query": {
                                    "value": "@if(equals(variables('WatermarkCol'), 'none'),\n  concat('SELECT COUNT(*) as row_count FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName),\n  if(equals(variables('LoadStrategy'), 'ROLLING_30DAY'),\n    concat('SELECT COUNT(*) as row_count FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName, ' WHERE ', variables('WatermarkCol'), ' >= CURRENT_DATE - INTERVAL ''30 days'''),\n    if(equals(variables('LoadStrategy'), 'FULL_RELOAD'),\n      concat('SELECT COUNT(*) as row_count FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName),\n      concat('SELECT COUNT(*) as row_count FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName, ' WHERE ', variables('WatermarkCol'), ' > ''', pipeline().parameters.LastWatermark, '''')\n    )\n  )\n)",
                                    "type": "Expression"
                                },
                                "queryTimeout": "02:00:00"
                            },
                            "dataset": {
                                "referenceName": "Canna_PostgreSQL_Collect_Tables",
                                "type": "DatasetReference",
                                "parameters": {
                                    "SchemaName": "@pipeline().parameters.SchemaName",
                                    "TableName": "@pipeline().parameters.TableName"
                                }
                            }
                        }
                    },
                    {
                        "name": "Copy_To_ADLS",
                        "description": "Copy raw Postgres data into ADLS",
                        "type": "Copy",
                        "dependsOn": [
                            {
                                "activity": "No_tm_Tables",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "source": {
                                "type": "PostgreSqlV2Source",
                                "query": {
                                    "value": "@if(equals(variables('WatermarkCol'), 'none'),\n  concat('SELECT * FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName),\n  if(equals(variables('LoadStrategy'), 'ROLLING_30DAY'),\n    concat('SELECT * FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName, ' WHERE ', variables('WatermarkCol'), ' >= CURRENT_DATE - INTERVAL ''30 days'''),\n    if(equals(variables('LoadStrategy'), 'FULL_RELOAD'),\n      concat('SELECT * FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName),\n      concat('SELECT * FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName, ' WHERE ', variables('WatermarkCol'), ' > ''', pipeline().parameters.LastWatermark, '''')\n    )\n  )\n)",
                                    "type": "Expression"
                                },
                                "queryTimeout": "02:00:00"
                            },
                            "sink": {
                                "type": "JsonSink",
                                "storeSettings": {
                                    "type": "AzureBlobFSWriteSettings"
                                },
                                "formatSettings": {
                                    "type": "JsonWriteSettings"
                                }
                            },
                            "enableStaging": false,
                            "parallelCopies": {
                                "value": "@int(variables('ParallelCopies'))",
                                "type": "Expression"
                            },
                            "enableSkipIncompatibleRow": false,
                            "validateDataConsistency": true,
                            "logSettings": {
                                "enableCopyActivityLog": true,
                                "copyActivityLogSettings": {
                                    "logLevel": "Info",
                                    "enableReliableLogging": false
                                },
                                "logLocationSettings": {
                                    "linkedServiceName": {
                                        "referenceName": "Canna_ADLS",
                                        "type": "LinkedServiceReference"
                                    },
                                    "path": "logs/copy-activity"
                                }
                            },
                            "dataIntegrationUnits": {
                                "value": "@int(variables('DataIntegrationUnits'))",
                                "type": "Expression"
                            }
                        },
                        "inputs": [
                            {
                                "referenceName": "Canna_PostgreSQL_Collect_Tables",
                                "type": "DatasetReference",
                                "parameters": {
                                    "SchemaName": "@pipeline().parameters.SchemaName",
                                    "TableName": "@pipeline().parameters.TableName"
                                }
                            }
                        ],
                        "outputs": [
                            {
                                "referenceName": "ADLS_JSON",
                                "type": "DatasetReference",
                                "parameters": {
                                    "Container": "raw",
                                    "Directory": {
                                        "value": "@concat(\n  pipeline().parameters.SourceDatabase, '/',\n  pipeline().parameters.TableName, '/',\n  pipeline().parameters.RunDate, '/',\n  pipeline().RunId         \n)\n",
                                        "type": "Expression"
                                    },
                                    "FileName": {
                                        "value": "@concat(pipeline().parameters.SchemaName, '_', pipeline().parameters.TableName, '_', formatDateTime(utcNow(), 'yyyyMMdd_HHmmss'), '_', variables('LoadStrategy'), '.json')",
                                        "type": "Expression"
                                    }
                                }
                            }
                        ]
                    },
                    {
                        "name": "Validate_ADLS_File",
                        "description": "Verify the JSON file was created successfully in ADLS",
                        "type": "GetMetadata",
                        "dependsOn": [
                            {
                                "activity": "Copy_To_ADLS",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "dataset": {
                                "referenceName": "ADLS_JSON",
                                "type": "DatasetReference",
                                "parameters": {
                                    "Container": "raw",
                                    "Directory": "@concat(pipeline().parameters.SourceDatabase, '/', formatDateTime(utcnow(), 'yyyy-MM-dd'))",
                                    "FileName": "@concat(pipeline().parameters.SchemaName, '_', pipeline().parameters.TableName, '_', formatDateTime(utcnow(), 'yyyyMMddHHmmss'), '.json')"
                                }
                            },
                            "fieldList": [
                                "exists",
                                "childItems"
                            ],
                            "storeSettings": {
                                "type": "AzureBlobFSReadSettings",
                                "recursive": true,
                                "enablePartitionDiscovery": false
                            },
                            "formatSettings": {
                                "type": "JsonReadSettings"
                            }
                        }
                    },
                    {
                        "name": "Load_To_Snowflake_Bronze",
                        "description": "Load ADLS data into Snowflake Bronze layer",
                        "type": "Script",
                        "dependsOn": [
                            {
                                "activity": "Delete_30_Day_Data",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "linkedServiceName": {
                            "referenceName": "Canna_Snowflake_Collect",
                            "type": "LinkedServiceReference"
                        },
                        "typeProperties": {
                            "scripts": [
                                {
                                    "type": "Query",
                                    "text": {
                                        "value": "@concat(\n  'ALTER SESSION SET TIMEZONE = ''UTC''; ',\n  'USE SCHEMA BRONZE; ',\n\n  'CREATE TABLE IF NOT EXISTS ', \n  if(endsWith(pipeline().parameters.TableName, '_t'), replace(pipeline().parameters.TableName, '_t', ''), pipeline().parameters.TableName), ' (',\n  '  data VARIANT,',\n  '  load_timestamp TIMESTAMP_NTZ DEFAULT CURRENT_TIMESTAMP()',\n  ');',\n\n  'COPY INTO ', \n  if(endsWith(pipeline().parameters.TableName, '_t'), replace(pipeline().parameters.TableName, '_t', ''), pipeline().parameters.TableName), ' (data) ',\n  'FROM @SOURCE_DB.BRONZE.ADLS_RAW_STAGE/',\n      pipeline().parameters.SourceDatabase, '/', pipeline().parameters.TableName, '/',\n      pipeline().parameters.RunDate, '/', pipeline().RunId, '/ ',\n  'PATTERN = ''', '.*', variables('LoadStrategy'), '.*', ''' ',\n  'FILE_FORMAT = (TYPE = JSON) ',\n  'FORCE = ', if(equals(variables('LoadStrategy'), 'FULL_RELOAD'), 'TRUE', 'FALSE'), ' ',\n  'ON_ERROR = ''CONTINUE'';',\n\n  'GRANT SELECT ON TABLE ', \n  if(endsWith(pipeline().parameters.TableName, '_t'), replace(pipeline().parameters.TableName, '_t', ''), pipeline().parameters.TableName), \n  ' TO ROLE SYSADMIN;',\n\n  'SELECT COUNT(*) AS rows_loaded, ''', variables('LoadStrategy'), ''' AS strategy_used ',\n  'FROM ', \n  if(endsWith(pipeline().parameters.TableName, '_t'), replace(pipeline().parameters.TableName, '_t', ''), pipeline().parameters.TableName), \n  ' WHERE data IS NOT NULL;'\n)",
                                        "type": "Expression"
                                    }
                                }
                            ],
                            "scriptBlockExecutionTimeout": "02:00:00"
                        }
                    },
                    {
                        "name": "Get_Snowflake_Row_Count",
                        "description": "Get loaded row count from Snowflake Bronze table",
                        "type": "Lookup",
                        "dependsOn": [
                            {
                                "activity": "Load_To_Snowflake_Bronze",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "source": {
                                "type": "SnowflakeV2Source",
                                "query": {
                                    "value": "SELECT COUNT(*) as snowflake_count \nFROM SOURCE_DB.BRONZE.@{if(endsWith(pipeline().parameters.TableName, '_t'), replace(pipeline().parameters.TableName, '_t', ''), pipeline().parameters.TableName)};",
                                    "type": "Expression"
                                },
                                "exportSettings": {
                                    "type": "SnowflakeExportCopyCommand"
                                }
                            },
                            "dataset": {
                                "referenceName": "Snowflake_Collect_Bronze",
                                "type": "DatasetReference",
                                "parameters": {}
                            }
                        }
                    },
                    {
                        "name": "Validate_Row_Count_Match",
                        "description": "Compare Postgres vs Snowflake row counts",
                        "type": "IfCondition",
                        "dependsOn": [
                            {
                                "activity": "Get_Snowflake_Row_Count",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "userProperties": [],
                        "typeProperties": {
                            "expression": {
                                "value": "@equals(string(activity('Get_Source_Row_Count').output.firstRow.row_count), string(activity('Get_Snowflake_Row_Count').output.firstRow.SNOWFLAKE_COUNT))",
                                "type": "Expression"
                            },
                            "ifFalseActivities": [
                                {
                                    "name": "Set_Validation_Error",
                                    "description": "Mark validation as failed due to row count mismatch",
                                    "type": "SetVariable",
                                    "dependsOn": [],
                                    "policy": {
                                        "secureOutput": false,
                                        "secureInput": false
                                    },
                                    "userProperties": [],
                                    "typeProperties": {
                                        "variableName": "ValidationStatus",
                                        "value": "ROW_COUNT_MISMATCH"
                                    }
                                }
                            ],
                            "ifTrueActivities": [
                                {
                                    "name": "Set_Validation_Status",
                                    "description": "Mark validation as successful",
                                    "type": "SetVariable",
                                    "dependsOn": [],
                                    "policy": {
                                        "secureOutput": false,
                                        "secureInput": false
                                    },
                                    "userProperties": [],
                                    "typeProperties": {
                                        "variableName": "ValidationStatus",
                                        "value": "SUCCESS"
                                    }
                                }
                            ]
                        }
                    },
                    {
                        "name": "Check_Null_Values",
                        "description": "Count null values in key columns",
                        "type": "Lookup",
                        "dependsOn": [
                            {
                                "activity": "Load_To_Snowflake_Bronze",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "source": {
                                "type": "SnowflakeV2Source",
                                "query": {
                                    "value": "SELECT \n    SUM(CASE WHEN data:id IS NULL THEN 1 ELSE 0 END) as null_ids,\n    SUM(CASE WHEN data:name IS NULL THEN 1 ELSE 0 END) as null_names\nFROM SOURCE_DB.BRONZE.@{if(endsWith(pipeline().parameters.TableName, '_t'), replace(pipeline().parameters.TableName, '_t', ''), pipeline().parameters.TableName)}",
                                    "type": "Expression"
                                },
                                "exportSettings": {
                                    "type": "SnowflakeExportCopyCommand"
                                }
                            },
                            "dataset": {
                                "referenceName": "Snowflake_Collect_Bronze",
                                "type": "DatasetReference",
                                "parameters": {}
                            }
                        }
                    },
                    {
                        "name": "Log_Pipeline_Summary",
                        "description": "Insert execution summary into UTILITY.PIPELINE_EXECUTION_LOG",
                        "type": "Script",
                        "dependsOn": [
                            {
                                "activity": "Validate_Row_Count_Match",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            },
                            {
                                "activity": "Check_Null_Values",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "linkedServiceName": {
                            "referenceName": "Canna_Snowflake_Collect",
                            "type": "LinkedServiceReference"
                        },
                        "typeProperties": {
                            "scripts": [
                                {
                                    "type": "Query",
                                    "text": {
                                        "value": "@concat(\n  'INSERT INTO SOURCE_DB.UTILITY.PIPELINE_EXECUTION_LOG VALUES (''',\n  pipeline().RunId, ''', ''',\n  pipeline().parameters.TableName, ''', ''',\n  formatDateTime(utcnow(), 'yyyy-MM-dd'), ''', ''',\n  utcnow(), ''', ',\n  if(empty(string(activity('Get_Source_Row_Count').output.firstRow.row_count)), '0', string(activity('Get_Source_Row_Count').output.firstRow.row_count)), ', ',\n  if(empty(string(activity('Get_Snowflake_Row_Count').output.firstRow.SNOWFLAKE_COUNT)), '0', string(activity('Get_Snowflake_Row_Count').output.firstRow.SNOWFLAKE_COUNT)), ', ',\n  if(equals(variables('ValidationStatus'), 'SUCCESS'), 'TRUE', 'FALSE'), ', ',\n  if(empty(string(activity('Check_Duplicates').output.firstRow.duplicate_count)), '0', string(activity('Check_Duplicates').output.firstRow.duplicate_count)), ', ',\n  if(empty(string(activity('Check_Null_Values').output.firstRow.NULL_IDS)), '0', string(activity('Check_Null_Values').output.firstRow.NULL_IDS)), ', ',\n  if(empty(string(activity('Check_Null_Values').output.firstRow.NULL_NAMES)), '0', string(activity('Check_Null_Values').output.firstRow.NULL_NAMES)), ', ''',\n  variables('ValidationStatus'), ''', ',\n  '0', \n  ');'\n)",
                                        "type": "Expression"
                                    }
                                }
                            ],
                            "scriptBlockExecutionTimeout": "02:00:00"
                        }
                    },
                    {
                        "name": "Check_Duplicates",
                        "description": "Check for duplicate rows in the table",
                        "type": "Lookup",
                        "dependsOn": [
                            {
                                "activity": "Get_Source_Row_Count",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "source": {
                                "type": "PostgreSqlV2Source",
                                "query": {
                                    "value": "@if(equals(variables('LoadStrategy'), 'ROLLING_30DAY'),\n  concat('SELECT (SELECT COUNT(*) FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName, ' WHERE ', variables('WatermarkCol'), ' >= CURRENT_DATE - INTERVAL ''30 days'') - (SELECT COUNT(*) FROM (SELECT DISTINCT * FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName, ' WHERE ', variables('WatermarkCol'), ' >= CURRENT_DATE - INTERVAL ''30 days'') t) as duplicate_count'),\n  concat('SELECT (SELECT COUNT(*) FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName, ') - (SELECT COUNT(*) FROM (SELECT DISTINCT * FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName, ') t) as duplicate_count')\n)",
                                    "type": "Expression"
                                },
                                "queryTimeout": "02:00:00"
                            },
                            "dataset": {
                                "referenceName": "Canna_PostgreSQL_Collect_Tables",
                                "type": "DatasetReference",
                                "parameters": {
                                    "SchemaName": "@pipeline().parameters.SchemaName",
                                    "TableName": "@pipeline().parameters.TableName"
                                }
                            }
                        }
                    },
                    {
                        "name": "Delete_30_Day_Data",
                        "type": "Script",
                        "dependsOn": [
                            {
                                "activity": "Validate_ADLS_File",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "linkedServiceName": {
                            "referenceName": "Canna_Snowflake_Collect",
                            "type": "LinkedServiceReference"
                        },
                        "typeProperties": {
                            "scripts": [
                                {
                                    "type": "Query",
                                    "text": {
                                        "value": "@concat(\n  'USE SCHEMA BRONZE; ',\n  'CREATE TABLE IF NOT EXISTS ', \n  if(endsWith(pipeline().parameters.TableName, '_t'), replace(pipeline().parameters.TableName, '_t', ''), pipeline().parameters.TableName), \n  ' (data VARIANT); ',\n  'ALTER SESSION SET TIMEZONE = ''UTC''; ',\n  if(equals(variables('LoadStrategy'), 'ROLLING_30DAY'),\n    concat('DELETE FROM ', \n      if(endsWith(pipeline().parameters.TableName, '_t'), replace(pipeline().parameters.TableName, '_t', ''), pipeline().parameters.TableName), \n      ' WHERE TO_DATE(CONVERT_TIMEZONE(''UTC'', TRY_TO_TIMESTAMP_TZ(data:\"', variables('WatermarkCol'), '\"::string))) >= DATEADD(day, -30, CURRENT_DATE()); '),\n    if(equals(variables('LoadStrategy'), 'FULL_RELOAD'),\n      concat('TRUNCATE TABLE ', \n        if(endsWith(pipeline().parameters.TableName, '_t'), replace(pipeline().parameters.TableName, '_t', ''), pipeline().parameters.TableName), \n        '; '),\n      'SELECT ''No cleanup needed for incremental strategy'' as status; '\n    )\n  ),\n  'SELECT ''', variables('LoadStrategy'), ''' as strategy_applied;'\n)",
                                        "type": "Expression"
                                    }
                                }
                            ],
                            "scriptBlockExecutionTimeout": "02:00:00"
                        }
                    },
                    {
                        "name": "Get_Table_Strategy",
                        "type": "Lookup",
                        "dependsOn": [],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "source": {
                                "type": "SnowflakeV2Source",
                                "query": {
                                    "value": "SELECT \n       COALESCE(load_strategy, 'INCREMENTAL') as load_strategy,\n       COALESCE(parallel_copies, 8) as parallel_copies,\n       COALESCE(data_integration_units, 16) as data_integration_units,\n       COALESCE(watermark_column, 'tm') as watermark_column\n   FROM SOURCE_DB.UTILITY.TABLE_STRATEGY_CONFIG \n   WHERE table_name = '@{pipeline().parameters.TableName}'\n   AND is_active = TRUE",
                                    "type": "Expression"
                                },
                                "exportSettings": {
                                    "type": "SnowflakeExportCopyCommand"
                                }
                            },
                            "dataset": {
                                "referenceName": "Snowflake_Collect_Bronze",
                                "type": "DatasetReference",
                                "parameters": {}
                            }
                        }
                    },
                    {
                        "name": "Set_Strategy_From_Config",
                        "type": "SetVariable",
                        "dependsOn": [
                            {
                                "activity": "Get_Table_Strategy",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "variableName": "LoadStrategy",
                            "value": {
                                "value": "@activity('Get_Table_Strategy').output.firstRow.load_strategy",
                                "type": "Expression"
                            }
                        }
                    },
                    {
                        "name": "Set_Parallel_Copies",
                        "type": "SetVariable",
                        "dependsOn": [
                            {
                                "activity": "Set_Strategy_From_Config",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "variableName": "ParallelCopies",
                            "value": {
                                "value": "@string(activity('Get_Table_Strategy').output.firstRow.parallel_copies)",
                                "type": "Expression"
                            }
                        }
                    },
                    {
                        "name": "Set_DIU",
                        "type": "SetVariable",
                        "dependsOn": [
                            {
                                "activity": "Set_Parallel_Copies",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "variableName": "DataIntegrationUnits",
                            "value": {
                                "value": "@string(activity('Get_Table_Strategy').output.firstRow.data_integration_units)",
                                "type": "Expression"
                            }
                        }
                    },
                    {
                        "name": "Set_Watermark_Column",
                        "type": "SetVariable",
                        "dependsOn": [
                            {
                                "activity": "Set_DIU",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "variableName": "WatermarkCol",
                            "value": {
                                "value": "@activity('Get_Table_Strategy').output.firstRow.watermark_column",
                                "type": "Expression"
                            }
                        }
                    },
                    {
                        "name": "No_tm_Tables",
                        "type": "IfCondition",
                        "dependsOn": [
                            {
                                "activity": "Check_Duplicates",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "userProperties": [],
                        "typeProperties": {
                            "expression": {
                                "value": "@not(equals(variables('WatermarkCol'), 'none'))",
                                "type": "Expression"
                            },
                            "ifTrueActivities": [
                                {
                                    "name": "Get_Max_Watermark",
                                    "type": "Lookup",
                                    "dependsOn": [],
                                    "policy": {
                                        "timeout": "0.12:00:00",
                                        "retry": 0,
                                        "retryIntervalInSeconds": 30,
                                        "secureOutput": false,
                                        "secureInput": false
                                    },
                                    "userProperties": [],
                                    "typeProperties": {
                                        "source": {
                                            "type": "PostgreSqlV2Source",
                                            "query": {
                                                "value": "@concat('SELECT MAX(', variables('WatermarkCol'), ')::timestamp as max_watermark FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName)\n",
                                                "type": "Expression"
                                            },
                                            "queryTimeout": "02:00:00"
                                        },
                                        "dataset": {
                                            "referenceName": "Canna_PostgreSQL_Collect_Tables",
                                            "type": "DatasetReference",
                                            "parameters": {
                                                "SchemaName": "collect",
                                                "TableName": "cc_customers"
                                            }
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    {
                        "name": "Update_tm_Tables",
                        "type": "IfCondition",
                        "dependsOn": [
                            {
                                "activity": "Log_Pipeline_Summary",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "userProperties": [],
                        "typeProperties": {
                            "expression": {
                                "value": "@not(equals(variables('WatermarkCol'), 'none'))",
                                "type": "Expression"
                            },
                            "ifTrueActivities": [
                                {
                                    "name": "Update_Watermark",
                                    "type": "Lookup",
                                    "dependsOn": [],
                                    "policy": {
                                        "timeout": "0.12:00:00",
                                        "retry": 0,
                                        "retryIntervalInSeconds": 30,
                                        "secureOutput": false,
                                        "secureInput": false
                                    },
                                    "userProperties": [],
                                    "typeProperties": {
                                        "source": {
                                            "type": "PostgreSqlV2Source",
                                            "query": {
                                                "value": "WITH update_result AS (\n     INSERT INTO collect.watermark_control (table_name, last_watermark, updated_at)\n     VALUES (\n       '@{pipeline().parameters.TableName}',\n       '@{activity('Get_Max_Watermark').output.firstRow.max_watermark}'::timestamp,\n       CURRENT_TIMESTAMP\n     )\n     ON CONFLICT (table_name) \n     DO UPDATE SET \n       last_watermark = EXCLUDED.last_watermark,\n       updated_at = CURRENT_TIMESTAMP\n     RETURNING table_name\n   )\n   SELECT COUNT(*) as rows_updated FROM update_result;",
                                                "type": "Expression"
                                            },
                                            "queryTimeout": "02:00:00"
                                        },
                                        "dataset": {
                                            "referenceName": "Canna_PostgreSQL_Collect_Tables",
                                            "type": "DatasetReference",
                                            "parameters": {
                                                "SchemaName": "collect",
                                                "TableName": "cc_customers"
                                            }
                                        }
                                    }
                                }
                            ]
                        }
                    }
                ],
                "policy": {
                    "elapsedTimeMetric": {}
                },
                "parameters": {
                    "SourceDatabase": {
                        "type": "string",
                        "defaultValue": "collect"
                    },
                    "SchemaName": {
                        "type": "string",
                        "defaultValue": "collect"
                    },
                    "TableName": {
                        "type": "string"
                    },
                    "WatermarkColumn": {
                        "type": "string",
                        "defaultValue": "tm"
                    },
                    "LastWatermark": {
                        "type": "string",
                        "defaultValue": "2000-01-01 00:00:00"
                    },
                    "RunDate": {
                        "type": "string"
                    }
                },
                "variables": {
                    "ValidationStatus": {
                        "type": "String"
                    },
                    "LoadStrategy": {
                        "type": "String",
                        "defaultValue": "INCREMENTAL"
                    },
                    "ParallelCopies": {
                        "type": "String",
                        "defaultValue": "8"
                    },
                    "DataIntegrationUnits": {
                        "type": "String",
                        "defaultValue": "16"
                    },
                    "WatermarkCol": {
                        "type": "String",
                        "defaultValue": "tm"
                    }
                },
                "folder": {
                    "name": "Archive"
                },
                "annotations": [],
                "lastPublishTime": "2025-09-18T14:21:00Z"
            },
            "dependsOn": [
                "[concat(variables('factoryId'), '/datasets/Canna_PostgreSQL_Collect_Tables')]",
                "[concat(variables('factoryId'), '/datasets/ADLS_JSON')]",
                "[concat(variables('factoryId'), '/linkedServices/Canna_Snowflake_Collect')]",
                "[concat(variables('factoryId'), '/datasets/Snowflake_Collect_Bronze')]",
                "[concat(variables('factoryId'), '/linkedServices/Canna_ADLS')]"
            ]
        },
        {
            "name": "[concat(parameters('factoryName'), '/Collect_Table_With_Validation_JSON')]",
            "type": "Microsoft.DataFactory/factories/pipelines",
            "apiVersion": "2018-06-01",
            "properties": {
                "activities": [
                    {
                        "name": "Get_Source_Row_Count",
                        "description": "Get Postgres SQL table row count ",
                        "type": "Lookup",
                        "dependsOn": [],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "source": {
                                "type": "PostgreSqlV2Source",
                                "query": {
                                    "value": "@concat('SELECT COUNT(*) as row_count FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName)",
                                    "type": "Expression"
                                },
                                "queryTimeout": "02:00:00"
                            },
                            "dataset": {
                                "referenceName": "Canna_PostgreSQL_Collect_Tables",
                                "type": "DatasetReference",
                                "parameters": {
                                    "SchemaName": "@pipeline().parameters.SchemaName",
                                    "TableName": "@pipeline().parameters.TableName"
                                }
                            }
                        }
                    },
                    {
                        "name": "Check_Duplicates",
                        "description": "Check for duplicate rows in the table",
                        "type": "Lookup",
                        "dependsOn": [
                            {
                                "activity": "Get_Source_Row_Count",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "source": {
                                "type": "PostgreSqlV2Source",
                                "query": {
                                    "value": "@concat('SELECT (SELECT COUNT(*) FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName, ') - (SELECT COUNT(*) FROM (SELECT DISTINCT * FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName, ') t) as duplicate_count')",
                                    "type": "Expression"
                                },
                                "queryTimeout": "02:00:00"
                            },
                            "dataset": {
                                "referenceName": "Canna_PostgreSQL_Collect_Tables",
                                "type": "DatasetReference",
                                "parameters": {
                                    "SchemaName": "@pipeline().parameters.SchemaName",
                                    "TableName": "@pipeline().parameters.TableName"
                                }
                            }
                        }
                    },
                    {
                        "name": "Copy_To_ADLS",
                        "description": "Copy raw Postgres data into ADLS",
                        "type": "Copy",
                        "dependsOn": [
                            {
                                "activity": "Check_Duplicates",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "source": {
                                "type": "PostgreSqlV2Source",
                                "queryTimeout": "02:00:00"
                            },
                            "sink": {
                                "type": "JsonSink",
                                "storeSettings": {
                                    "type": "AzureBlobFSWriteSettings"
                                },
                                "formatSettings": {
                                    "type": "JsonWriteSettings"
                                }
                            },
                            "enableStaging": false,
                            "parallelCopies": 32,
                            "enableSkipIncompatibleRow": false,
                            "validateDataConsistency": true,
                            "logSettings": {
                                "enableCopyActivityLog": true,
                                "copyActivityLogSettings": {
                                    "logLevel": "Info",
                                    "enableReliableLogging": false
                                },
                                "logLocationSettings": {
                                    "linkedServiceName": {
                                        "referenceName": "Canna_ADLS",
                                        "type": "LinkedServiceReference"
                                    },
                                    "path": "logs/copy-activity"
                                }
                            },
                            "dataIntegrationUnits": 32
                        },
                        "inputs": [
                            {
                                "referenceName": "Canna_PostgreSQL_Collect_Tables",
                                "type": "DatasetReference",
                                "parameters": {
                                    "SchemaName": "@pipeline().parameters.SchemaName",
                                    "TableName": "@pipeline().parameters.TableName"
                                }
                            }
                        ],
                        "outputs": [
                            {
                                "referenceName": "ADLS_JSON",
                                "type": "DatasetReference",
                                "parameters": {
                                    "Container": "raw",
                                    "Directory": {
                                        "value": "@concat(pipeline().parameters.SourceDatabase, '/', pipeline().parameters.TableName, '/', formatDateTime(utcnow(),'yyyy-MM-dd'))",
                                        "type": "Expression"
                                    },
                                    "FileName": {
                                        "value": "@concat(pipeline().parameters.SchemaName, '_', pipeline().parameters.TableName, '_latest.json')",
                                        "type": "Expression"
                                    }
                                }
                            }
                        ]
                    },
                    {
                        "name": "Validate_ADLS_File",
                        "description": "Verify the JSON file was created successfully in ADLS",
                        "type": "GetMetadata",
                        "dependsOn": [
                            {
                                "activity": "Copy_To_ADLS",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "dataset": {
                                "referenceName": "ADLS_JSON",
                                "type": "DatasetReference",
                                "parameters": {
                                    "Container": "raw",
                                    "Directory": "@concat(pipeline().parameters.SourceDatabase, '/', formatDateTime(utcnow(), 'yyyy-MM-dd'))",
                                    "FileName": "@concat(pipeline().parameters.SchemaName, '_', pipeline().parameters.TableName, '_', formatDateTime(utcnow(), 'yyyyMMddHHmmss'), '.json')"
                                }
                            },
                            "fieldList": [
                                "exists",
                                "childItems"
                            ],
                            "storeSettings": {
                                "type": "AzureBlobFSReadSettings",
                                "recursive": true,
                                "enablePartitionDiscovery": false
                            },
                            "formatSettings": {
                                "type": "JsonReadSettings"
                            }
                        }
                    },
                    {
                        "name": "Load_To_Snowflake_Bronze",
                        "description": "Load ADLS data into Snowflake Bronze layer",
                        "type": "Script",
                        "dependsOn": [
                            {
                                "activity": "Validate_ADLS_File",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "linkedServiceName": {
                            "referenceName": "Canna_Snowflake_Collect",
                            "type": "LinkedServiceReference"
                        },
                        "typeProperties": {
                            "scripts": [
                                {
                                    "type": "Query",
                                    "text": {
                                        "value": "USE SCHEMA BRONZE;\n\nCREATE OR REPLACE TABLE @{if(endsWith(pipeline().parameters.TableName, '_t'), replace(pipeline().parameters.TableName, '_t', ''), pipeline().parameters.TableName)} (data VARIANT);\n\nCOPY INTO @{if(endsWith(pipeline().parameters.TableName, '_t'), replace(pipeline().parameters.TableName, '_t', ''), pipeline().parameters.TableName)}\nFROM @SOURCE_DB.BRONZE.ADLS_RAW_STAGE/@{pipeline().parameters.SourceDatabase}/@{pipeline().parameters.TableName}/@{formatDateTime(utcnow(), 'yyyy-MM-dd')}/@{pipeline().parameters.SchemaName}_@{pipeline().parameters.TableName}_latest.json\nFILE_FORMAT = (TYPE = 'JSON');\n\nGRANT SELECT ON TABLE @{if(endsWith(pipeline().parameters.TableName, '_t'), replace(pipeline().parameters.TableName, '_t', ''), pipeline().parameters.TableName)} TO ROLE SYSADMIN;\n\nSELECT COUNT(*) as rows_loaded FROM @{if(endsWith(pipeline().parameters.TableName, '_t'), replace(pipeline().parameters.TableName, '_t', ''), pipeline().parameters.TableName)};",
                                        "type": "Expression"
                                    }
                                }
                            ],
                            "scriptBlockExecutionTimeout": "02:00:00"
                        }
                    },
                    {
                        "name": "Get_Snowflake_Row_Count",
                        "description": "Get loaded row count from Snowflake Bronze table",
                        "type": "Lookup",
                        "dependsOn": [
                            {
                                "activity": "Load_To_Snowflake_Bronze",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "source": {
                                "type": "SnowflakeV2Source",
                                "query": {
                                    "value": "SELECT COUNT(*) as snowflake_count \nFROM SOURCE_DB.BRONZE.@{if(endsWith(pipeline().parameters.TableName, '_t'), replace(pipeline().parameters.TableName, '_t', ''), pipeline().parameters.TableName)};",
                                    "type": "Expression"
                                },
                                "exportSettings": {
                                    "type": "SnowflakeExportCopyCommand"
                                }
                            },
                            "dataset": {
                                "referenceName": "Snowflake_Collect_Bronze",
                                "type": "DatasetReference",
                                "parameters": {}
                            }
                        }
                    },
                    {
                        "name": "Validate_Row_Count_Match",
                        "description": "Compare Postgres vs Snowflake row counts",
                        "type": "IfCondition",
                        "dependsOn": [
                            {
                                "activity": "Get_Snowflake_Row_Count",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "userProperties": [],
                        "typeProperties": {
                            "expression": {
                                "value": "@equals(string(activity('Get_Source_Row_Count').output.firstRow.row_count), string(activity('Get_Snowflake_Row_Count').output.firstRow.SNOWFLAKE_COUNT))",
                                "type": "Expression"
                            },
                            "ifFalseActivities": [
                                {
                                    "name": "Set_Validation_Error",
                                    "description": "Mark validation as failed due to row count mismatch",
                                    "type": "SetVariable",
                                    "dependsOn": [],
                                    "policy": {
                                        "secureOutput": false,
                                        "secureInput": false
                                    },
                                    "userProperties": [],
                                    "typeProperties": {
                                        "variableName": "ValidationStatus",
                                        "value": "ROW_COUNT_MISMATCH"
                                    }
                                }
                            ],
                            "ifTrueActivities": [
                                {
                                    "name": "Set_Validation_Status",
                                    "description": "Mark validation as successful",
                                    "type": "SetVariable",
                                    "dependsOn": [],
                                    "policy": {
                                        "secureOutput": false,
                                        "secureInput": false
                                    },
                                    "userProperties": [],
                                    "typeProperties": {
                                        "variableName": "ValidationStatus",
                                        "value": "SUCCESS"
                                    }
                                }
                            ]
                        }
                    },
                    {
                        "name": "Check_Null_Values",
                        "description": "Count null values in key columns",
                        "type": "Lookup",
                        "dependsOn": [
                            {
                                "activity": "Load_To_Snowflake_Bronze",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "source": {
                                "type": "SnowflakeV2Source",
                                "query": {
                                    "value": "SELECT \n    SUM(CASE WHEN data:id IS NULL THEN 1 ELSE 0 END) as null_ids,\n    SUM(CASE WHEN data:name IS NULL THEN 1 ELSE 0 END) as null_names\nFROM SOURCE_DB.BRONZE.@{if(endsWith(pipeline().parameters.TableName, '_t'), replace(pipeline().parameters.TableName, '_t', ''), pipeline().parameters.TableName)}",
                                    "type": "Expression"
                                },
                                "exportSettings": {
                                    "type": "SnowflakeExportCopyCommand"
                                }
                            },
                            "dataset": {
                                "referenceName": "Snowflake_Collect_Bronze",
                                "type": "DatasetReference",
                                "parameters": {}
                            }
                        }
                    },
                    {
                        "name": "Log_Pipeline_Summary",
                        "description": "Insert execution summary into UTILITY.PIPELINE_EXECUTION_LOG",
                        "type": "Script",
                        "dependsOn": [
                            {
                                "activity": "Validate_Row_Count_Match",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            },
                            {
                                "activity": "Check_Null_Values",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "linkedServiceName": {
                            "referenceName": "Canna_Snowflake_Collect",
                            "type": "LinkedServiceReference"
                        },
                        "typeProperties": {
                            "scripts": [
                                {
                                    "type": "Query",
                                    "text": {
                                        "value": "INSERT INTO SOURCE_DB.UTILITY.PIPELINE_EXECUTION_LOG\nVALUES (\n    '@{pipeline().RunId}',\n    '@{pipeline().parameters.TableName}',\n    '@{formatDateTime(utcnow(), 'yyyy-MM-dd')}',\n    '@{utcnow()}',\n    @{activity('Get_Source_Row_Count').output.firstRow.row_count},\n    @{int(activity('Get_Snowflake_Row_Count').output.firstRow.SNOWFLAKE_COUNT)},\n    @{equals(variables('ValidationStatus'), 'SUCCESS')},\n    @{activity('Check_Duplicates').output.firstRow.duplicate_count},\n    @{int(activity('Check_Null_Values').output.firstRow.NULL_IDS)},\n    @{int(activity('Check_Null_Values').output.firstRow.NULL_NAMES)},\n    '@{variables('ValidationStatus')}',\n    0\n);",
                                        "type": "Expression"
                                    }
                                }
                            ],
                            "scriptBlockExecutionTimeout": "02:00:00"
                        }
                    }
                ],
                "policy": {
                    "elapsedTimeMetric": {}
                },
                "parameters": {
                    "SourceDatabase": {
                        "type": "string",
                        "defaultValue": "collect"
                    },
                    "SchemaName": {
                        "type": "string"
                    },
                    "TableName": {
                        "type": "string"
                    }
                },
                "variables": {
                    "ValidationStatus": {
                        "type": "String"
                    }
                },
                "annotations": [],
                "lastPublishTime": "2025-09-18T14:21:00Z"
            },
            "dependsOn": [
                "[concat(variables('factoryId'), '/datasets/Canna_PostgreSQL_Collect_Tables')]",
                "[concat(variables('factoryId'), '/datasets/ADLS_JSON')]",
                "[concat(variables('factoryId'), '/linkedServices/Canna_Snowflake_Collect')]",
                "[concat(variables('factoryId'), '/datasets/Snowflake_Collect_Bronze')]",
                "[concat(variables('factoryId'), '/linkedServices/Canna_ADLS')]"
            ]
        },
        {
            "name": "[concat(parameters('factoryName'), '/Collect_Table_With_Validation_JSON_Incremental')]",
            "type": "Microsoft.DataFactory/factories/pipelines",
            "apiVersion": "2018-06-01",
            "properties": {
                "activities": [
                    {
                        "name": "Get_Source_Row_Count",
                        "description": "Get Postgres SQL table row count ",
                        "type": "Lookup",
                        "state": "Inactive",
                        "onInactiveMarkAs": "Succeeded",
                        "dependsOn": [
                            {
                                "activity": "Check_Table_Exists",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "source": {
                                "type": "PostgreSqlV2Source",
                                "query": {
                                    "value": "@concat('SELECT COUNT(*) as row_count FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName)",
                                    "type": "Expression"
                                },
                                "queryTimeout": "02:00:00"
                            },
                            "dataset": {
                                "referenceName": "Canna_PostgreSQL_Collect_Tables",
                                "type": "DatasetReference",
                                "parameters": {
                                    "SchemaName": "@pipeline().parameters.SchemaName",
                                    "TableName": "@pipeline().parameters.TableName"
                                }
                            }
                        }
                    },
                    {
                        "name": "Check_Duplicates",
                        "description": "Check for duplicate rows in the table",
                        "type": "Lookup",
                        "state": "Inactive",
                        "onInactiveMarkAs": "Succeeded",
                        "dependsOn": [
                            {
                                "activity": "Get_Source_Row_Count",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "source": {
                                "type": "PostgreSqlV2Source",
                                "query": {
                                    "value": "@concat('SELECT (SELECT COUNT(*) FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName, ') - (SELECT COUNT(*) FROM (SELECT DISTINCT * FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName, ') t) as duplicate_count')",
                                    "type": "Expression"
                                },
                                "queryTimeout": "02:00:00"
                            },
                            "dataset": {
                                "referenceName": "Canna_PostgreSQL_Collect_Tables",
                                "type": "DatasetReference",
                                "parameters": {
                                    "SchemaName": "@pipeline().parameters.SchemaName",
                                    "TableName": "@pipeline().parameters.TableName"
                                }
                            }
                        }
                    },
                    {
                        "name": "Copy_To_ADLS",
                        "description": "Copy raw Postgres data into ADLS",
                        "type": "Copy",
                        "state": "Inactive",
                        "onInactiveMarkAs": "Succeeded",
                        "dependsOn": [
                            {
                                "activity": "Check_Duplicates",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "source": {
                                "type": "PostgreSqlV2Source",
                                "query": {
                                    "value": "SELECT *,\nMD5(CONCAT(\n    COALESCE(nm::text, ''),\n    COALESCE(cat::text, ''),\n    COALESCE(brand::text, ''),\n    COALESCE(subcat::text, ''),\n    COALESCE(producer::text, ''),\n    COALESCE(supplier::text, ''),\n    COALESCE(descr_short::text, ''),\n    COALESCE(descr::text, ''),\n    COALESCE(size::text, ''),\n    COALESCE(size_pack::text, ''),\n    COALESCE(unit::text, ''),\n    COALESCE(barcode::text, ''),\n    COALESCE(sku::text, ''),\n    COALESCE(gtin::text, ''),\n    COALESCE(ipid::text, ''),\n    COALESCE(upc::text, ''),\n    COALESCE(country_code::text, ''),\n    COALESCE(state_code::text, ''),\n    COALESCE(eaches_case_txt::text, ''),\n    COALESCE(sell_price_case_txt::text, ''),\n    COALESCE(eaches_case::text, ''),\n    COALESCE(sell_price::text, '')\n)) as row_hash\nFROM collect.products_01_on",
                                    "type": "Expression"
                                },
                                "queryTimeout": "02:00:00"
                            },
                            "sink": {
                                "type": "JsonSink",
                                "storeSettings": {
                                    "type": "AzureBlobFSWriteSettings"
                                },
                                "formatSettings": {
                                    "type": "JsonWriteSettings"
                                }
                            },
                            "enableStaging": false,
                            "parallelCopies": 8,
                            "enableSkipIncompatibleRow": false,
                            "validateDataConsistency": true,
                            "logSettings": {
                                "enableCopyActivityLog": true,
                                "copyActivityLogSettings": {
                                    "logLevel": "Info",
                                    "enableReliableLogging": false
                                },
                                "logLocationSettings": {
                                    "linkedServiceName": {
                                        "referenceName": "Canna_ADLS",
                                        "type": "LinkedServiceReference"
                                    },
                                    "path": "logs/copy-activity"
                                }
                            },
                            "dataIntegrationUnits": 16
                        },
                        "inputs": [
                            {
                                "referenceName": "Canna_PostgreSQL_Collect_Tables",
                                "type": "DatasetReference",
                                "parameters": {
                                    "SchemaName": "@pipeline().parameters.SchemaName",
                                    "TableName": "@pipeline().parameters.TableName"
                                }
                            }
                        ],
                        "outputs": [
                            {
                                "referenceName": "ADLS_JSON",
                                "type": "DatasetReference",
                                "parameters": {
                                    "Container": "raw",
                                    "Directory": {
                                        "value": "@concat(pipeline().parameters.SourceDatabase, '/', pipeline().parameters.TableName, '/', formatDateTime(utcnow(),'yyyy-MM-dd'))",
                                        "type": "Expression"
                                    },
                                    "FileName": {
                                        "value": "@concat(pipeline().parameters.SchemaName, '_', pipeline().parameters.TableName, '_latest.json')",
                                        "type": "Expression"
                                    }
                                }
                            }
                        ]
                    },
                    {
                        "name": "Validate_ADLS_File",
                        "description": "Verify the JSON file was created successfully in ADLS",
                        "type": "GetMetadata",
                        "state": "Inactive",
                        "onInactiveMarkAs": "Succeeded",
                        "dependsOn": [
                            {
                                "activity": "Copy_To_ADLS",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "dataset": {
                                "referenceName": "ADLS_JSON",
                                "type": "DatasetReference",
                                "parameters": {
                                    "Container": "raw",
                                    "Directory": "@concat(pipeline().parameters.SourceDatabase, '/', formatDateTime(utcnow(), 'yyyy-MM-dd'))",
                                    "FileName": "@concat(pipeline().parameters.SchemaName, '_', pipeline().parameters.TableName, '_', formatDateTime(utcnow(), 'yyyyMMddHHmmss'), '.json')"
                                }
                            },
                            "fieldList": [
                                "exists",
                                "childItems"
                            ],
                            "storeSettings": {
                                "type": "AzureBlobFSReadSettings",
                                "recursive": true,
                                "enablePartitionDiscovery": false
                            },
                            "formatSettings": {
                                "type": "JsonReadSettings"
                            }
                        }
                    },
                    {
                        "name": "Load_To_Snowflake_Bronze",
                        "description": "Load ADLS data into Snowflake Bronze layer",
                        "type": "Script",
                        "state": "Inactive",
                        "onInactiveMarkAs": "Succeeded",
                        "dependsOn": [
                            {
                                "activity": "Validate_ADLS_File",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "linkedServiceName": {
                            "referenceName": "Canna_Snowflake_Collect",
                            "type": "LinkedServiceReference"
                        },
                        "typeProperties": {
                            "scripts": [
                                {
                                    "type": "Query",
                                    "text": {
                                        "value": "USE SCHEMA BRONZE;\n\n-- Create V2 table if it doesn't exist (won't touch the original)\nCREATE TABLE IF NOT EXISTS COLLECT_PRODUCTS_01_ON_V2 (\n    data VARIANT,\n    row_hash VARCHAR(500),\n    loaded_timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP()\n);\n\n-- Create staging table for current load\nCREATE OR REPLACE TEMPORARY TABLE STAGE_COLLECT_PRODUCTS_01_ON_V2 (\n    data VARIANT\n);\n\n-- Load new data from ADLS into staging\nCOPY INTO STAGE_COLLECT_PRODUCTS_01_ON_V2\nFROM @CANNACOLLECTIVE_COLLECT.BRONZE.ADLS_RAW_STAGE/collect/products_01_on/@{formatDateTime(utcnow(),'yyyy-MM-dd')}/collect_products_01_on_latest.json\nFILE_FORMAT = (TYPE = 'JSON');\n\n-- Create tracking table if not exists\nCREATE TABLE IF NOT EXISTS ETL_LOAD_TRACKING (\n    table_name VARCHAR(200) PRIMARY KEY,\n    last_load_timestamp TIMESTAMP,\n    last_row_count INTEGER,\n    load_method VARCHAR(50)\n);\n\n-- Perform incremental merge into V2 table\nMERGE INTO COLLECT_PRODUCTS_01_ON_V2 AS target\nUSING (\n    SELECT \n        data,\n        data:row_hash::VARCHAR as row_hash\n    FROM STAGE_COLLECT_PRODUCTS_01_ON_V2\n) AS source\nON target.data = source.data\nWHEN NOT MATCHED THEN\n    INSERT (data, row_hash, loaded_timestamp)\n    VALUES (source.data, source.row_hash, CURRENT_TIMESTAMP())\nWHEN MATCHED AND target.row_hash != source.row_hash THEN\n    UPDATE SET \n        data = source.data,\n        row_hash = source.row_hash,\n        loaded_timestamp = CURRENT_TIMESTAMP();\n\n-- Update tracking\nMERGE INTO ETL_LOAD_TRACKING AS track\nUSING (\n    SELECT \n        'COLLECT_PRODUCTS_01_ON_V2' as table_name,\n        CURRENT_TIMESTAMP() as last_load_timestamp,\n        COUNT(*) as last_row_count,\n        'INCREMENTAL_HASH' as load_method\n    FROM COLLECT_PRODUCTS_01_ON_V2\n) AS metrics\nON track.table_name = metrics.table_name\nWHEN MATCHED THEN UPDATE SET \n    last_load_timestamp = metrics.last_load_timestamp,\n    last_row_count = metrics.last_row_count\nWHEN NOT MATCHED THEN INSERT VALUES (\n    metrics.table_name,\n    metrics.last_load_timestamp,\n    metrics.last_row_count,\n    metrics.load_method\n);\n\n-- Return count for validation\nSELECT COUNT(*) as rows_loaded FROM COLLECT_PRODUCTS_01_ON_V2;",
                                        "type": "Expression"
                                    }
                                }
                            ],
                            "scriptBlockExecutionTimeout": "02:00:00"
                        }
                    },
                    {
                        "name": "Get_Snowflake_Row_Count",
                        "description": "Get loaded row count from Snowflake Bronze table",
                        "type": "Lookup",
                        "state": "Inactive",
                        "onInactiveMarkAs": "Succeeded",
                        "dependsOn": [
                            {
                                "activity": "Load_To_Snowflake_Bronze",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "source": {
                                "type": "SnowflakeV2Source",
                                "query": {
                                    "value": "SELECT COUNT(*) as snowflake_count FROM CANNACOLLECTIVE_COLLECT.BRONZE.@{pipeline().parameters.SchemaName}_@{pipeline().parameters.TableName};",
                                    "type": "Expression"
                                },
                                "exportSettings": {
                                    "type": "SnowflakeExportCopyCommand"
                                }
                            },
                            "dataset": {
                                "referenceName": "Snowflake_Collect_Bronze",
                                "type": "DatasetReference",
                                "parameters": {}
                            }
                        }
                    },
                    {
                        "name": "Validate_Row_Count_Match",
                        "description": "Compare Postgres vs Snowflake row counts",
                        "type": "IfCondition",
                        "state": "Inactive",
                        "onInactiveMarkAs": "Succeeded",
                        "dependsOn": [
                            {
                                "activity": "Get_Snowflake_Row_Count",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "userProperties": [],
                        "typeProperties": {
                            "expression": {
                                "value": "@equals(activity('Get_Source_Row_Count').output.firstRow.row_count, int(activity('Get_Snowflake_Row_Count').output.firstRow.SNOWFLAKE_COUNT))",
                                "type": "Expression"
                            },
                            "ifFalseActivities": [
                                {
                                    "name": "Set_Validation_Error",
                                    "description": "Mark validation as failed due to row count mismatch",
                                    "type": "SetVariable",
                                    "dependsOn": [],
                                    "policy": {
                                        "secureOutput": false,
                                        "secureInput": false
                                    },
                                    "userProperties": [],
                                    "typeProperties": {
                                        "variableName": "ValidationStatus",
                                        "value": "ROW_COUNT_MISMATCH"
                                    }
                                }
                            ],
                            "ifTrueActivities": [
                                {
                                    "name": "Set_Validation_Status",
                                    "description": "Mark validation as successful",
                                    "type": "SetVariable",
                                    "dependsOn": [],
                                    "policy": {
                                        "secureOutput": false,
                                        "secureInput": false
                                    },
                                    "userProperties": [],
                                    "typeProperties": {
                                        "variableName": "ValidationStatus",
                                        "value": "SUCCESS"
                                    }
                                }
                            ]
                        }
                    },
                    {
                        "name": "Check_Null_Values",
                        "description": "Count null values in key columns",
                        "type": "Lookup",
                        "state": "Inactive",
                        "onInactiveMarkAs": "Succeeded",
                        "dependsOn": [
                            {
                                "activity": "Load_To_Snowflake_Bronze",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "source": {
                                "type": "SnowflakeV2Source",
                                "query": {
                                    "value": "SELECT \n    SUM(CASE WHEN data:id IS NULL THEN 1 ELSE 0 END) as null_ids,\n    SUM(CASE WHEN data:name IS NULL THEN 1 ELSE 0 END) as null_names\nFROM CANNACOLLECTIVE_COLLECT.BRONZE.@{pipeline().parameters.SchemaName}_@{pipeline().parameters.TableName}",
                                    "type": "Expression"
                                },
                                "exportSettings": {
                                    "type": "SnowflakeExportCopyCommand"
                                }
                            },
                            "dataset": {
                                "referenceName": "Snowflake_Collect_Bronze",
                                "type": "DatasetReference",
                                "parameters": {}
                            }
                        }
                    },
                    {
                        "name": "Log_Pipeline_Summary",
                        "description": "Insert execution summary into UTILITY.PIPELINE_EXECUTION_LOG",
                        "type": "Script",
                        "state": "Inactive",
                        "onInactiveMarkAs": "Succeeded",
                        "dependsOn": [
                            {
                                "activity": "Validate_Row_Count_Match",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            },
                            {
                                "activity": "Check_Null_Values",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "linkedServiceName": {
                            "referenceName": "Canna_Snowflake_Collect",
                            "type": "LinkedServiceReference"
                        },
                        "typeProperties": {
                            "scripts": [
                                {
                                    "type": "Query",
                                    "text": {
                                        "value": "INSERT INTO CANNACOLLECTIVE_COLLECT.UTILITY.PIPELINE_EXECUTION_LOG\nVALUES (\n    '@{pipeline().RunId}',\n    '@{pipeline().parameters.TableName}',\n    '@{formatDateTime(utcnow(), 'yyyy-MM-dd')}',\n    '@{utcnow()}',\n    @{activity('Get_Source_Row_Count').output.firstRow.row_count},\n    @{int(activity('Get_Snowflake_Row_Count').output.firstRow.SNOWFLAKE_COUNT)},\n    @{equals(variables('ValidationStatus'), 'SUCCESS')},\n    @{activity('Check_Duplicates').output.firstRow.duplicate_count},\n    @{int(activity('Check_Null_Values').output.firstRow.NULL_IDS)},\n    @{int(activity('Check_Null_Values').output.firstRow.NULL_NAMES)},\n    '@{variables('ValidationStatus')}',\n    0\n);",
                                        "type": "Expression"
                                    }
                                }
                            ],
                            "scriptBlockExecutionTimeout": "02:00:00"
                        }
                    },
                    {
                        "name": "Check_Table_Exists",
                        "type": "Lookup",
                        "state": "Inactive",
                        "onInactiveMarkAs": "Succeeded",
                        "dependsOn": [],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "source": {
                                "type": "SnowflakeV2Source",
                                "query": {
                                    "value": "SELECT COUNT(*) as table_exists\nFROM INFORMATION_SCHEMA.TABLES \nWHERE TABLE_SCHEMA = 'BRONZE' \nAND TABLE_NAME = 'COLLECT_PRODUCTS_01_ON_V2'",
                                    "type": "Expression"
                                },
                                "exportSettings": {
                                    "type": "SnowflakeExportCopyCommand"
                                }
                            },
                            "dataset": {
                                "referenceName": "Snowflake_Collect_Bronze",
                                "type": "DatasetReference",
                                "parameters": {}
                            }
                        }
                    },
                    {
                        "name": "Init_Control_Table",
                        "type": "Script",
                        "dependsOn": [],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "linkedServiceName": {
                            "referenceName": "Canna_Snowflake_Collect",
                            "type": "LinkedServiceReference"
                        },
                        "typeProperties": {
                            "scripts": [
                                {
                                    "type": "Query",
                                    "text": "\nCREATE TABLE IF NOT EXISTS CANNACOLLECTIVE_COLLECT.UTILITY.WATERMARK_CONTROL (\n  source_db        STRING,\n  schema_name      STRING,\n  table_name       STRING,\n  watermark_column STRING,\n  last_watermark   TIMESTAMP_NTZ,\n  updated_at       TIMESTAMP_NTZ DEFAULT CURRENT_TIMESTAMP(),\n  CONSTRAINT PK_WM PRIMARY KEY (source_db, schema_name, table_name)\n);\n"
                                }
                            ],
                            "scriptBlockExecutionTimeout": "02:00:00"
                        }
                    },
                    {
                        "name": "Check_Column_Exists",
                        "type": "Lookup",
                        "dependsOn": [
                            {
                                "activity": "Init_Control_Table",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "source": {
                                "type": "PostgreSqlV2Source",
                                "query": {
                                    "value": "@concat(\n  'SELECT COUNT(*) AS col_count\n     FROM information_schema.columns\n    WHERE table_schema = ''', pipeline().parameters.SchemaName, '''\n      AND table_name   = ''', pipeline().parameters.TableName, '''\n      AND column_name  = ''', pipeline().parameters.DefaultWatermarkColumn, ''''\n)",
                                    "type": "Expression"
                                },
                                "queryTimeout": "02:00:00"
                            },
                            "dataset": {
                                "referenceName": "Canna_PostgreSQL_Collect_Tables",
                                "type": "DatasetReference",
                                "parameters": {
                                    "SchemaName": "collect",
                                    "TableName": "cc_customers"
                                }
                            }
                        }
                    },
                    {
                        "name": "HasWatermark",
                        "type": "IfCondition",
                        "dependsOn": [
                            {
                                "activity": "Check_Column_Exists",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "userProperties": [],
                        "typeProperties": {
                            "expression": {
                                "value": "@greater(int(activity('Check_Column_Exists').output.firstRow.col_count), 0)\n",
                                "type": "Expression"
                            },
                            "ifFalseActivities": [
                                {
                                    "name": "Copy_To_ADLS_Full",
                                    "type": "Copy",
                                    "dependsOn": [],
                                    "policy": {
                                        "timeout": "0.12:00:00",
                                        "retry": 0,
                                        "retryIntervalInSeconds": 30,
                                        "secureOutput": false,
                                        "secureInput": false
                                    },
                                    "userProperties": [],
                                    "typeProperties": {
                                        "source": {
                                            "type": "PostgreSqlV2Source",
                                            "query": {
                                                "value": "@concat('SELECT * FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName)\n",
                                                "type": "Expression"
                                            },
                                            "queryTimeout": "02:00:00"
                                        },
                                        "sink": {
                                            "type": "JsonSink",
                                            "storeSettings": {
                                                "type": "AzureBlobFSWriteSettings"
                                            },
                                            "formatSettings": {
                                                "type": "JsonWriteSettings"
                                            }
                                        },
                                        "enableStaging": false
                                    },
                                    "inputs": [
                                        {
                                            "referenceName": "Canna_PostgreSQL_Collect_Tables",
                                            "type": "DatasetReference",
                                            "parameters": {
                                                "SchemaName": "collect",
                                                "TableName": "cc_customers"
                                            }
                                        }
                                    ],
                                    "outputs": [
                                        {
                                            "referenceName": "ADLS_JSON",
                                            "type": "DatasetReference",
                                            "parameters": {
                                                "Container": "raw",
                                                "Directory": {
                                                    "value": "@concat(pipeline().parameters.SourceDatabase, '/', pipeline().parameters.TableName, '/', formatDateTime(utcnow(),'yyyy-MM-dd'), '/')\n",
                                                    "type": "Expression"
                                                },
                                                "FileName": {
                                                    "value": "@concat(pipeline().parameters.SchemaName, '_', pipeline().parameters.TableName, '_', formatDateTime(utcnow(),'yyyyMMddHHmmss'), '_full.json')\n",
                                                    "type": "Expression"
                                                }
                                            }
                                        }
                                    ]
                                },
                                {
                                    "name": "products_01_on",
                                    "type": "Script",
                                    "dependsOn": [
                                        {
                                            "activity": "Copy_To_ADLS_Full",
                                            "dependencyConditions": [
                                                "Succeeded"
                                            ]
                                        }
                                    ],
                                    "policy": {
                                        "timeout": "0.12:00:00",
                                        "retry": 0,
                                        "retryIntervalInSeconds": 30,
                                        "secureOutput": false,
                                        "secureInput": false
                                    },
                                    "userProperties": [],
                                    "linkedServiceName": {
                                        "referenceName": "Canna_Snowflake_Collect",
                                        "type": "LinkedServiceReference"
                                    },
                                    "typeProperties": {
                                        "scripts": [
                                            {
                                                "type": "Query",
                                                "text": {
                                                    "value": "USE DATABASE CANNACOLLECTIVE_COLLECT;\nUSE SCHEMA BRONZE;\n\n\nSET SCH = '@{pipeline().parameters.SchemaName}';\nSET TBL = '@{pipeline().parameters.TableName}';              -- products_01_on\nSET TGT = 'BRONZE.' || UPPER($SCH || '_' || $TBL || '@{pipeline().parameters.TargetSuffix}');\n\n\nCREATE TABLE IF NOT EXISTS IDENTIFIER($TGT) (\n  pk_hash STRING PRIMARY KEY,\n  row_hash STRING,\n  data VARIANT,\n  loaded_timestamp TIMESTAMP_NTZ DEFAULT CURRENT_TIMESTAMP()\n);\n\n-- 2) Stage current full file(s)\nCREATE OR REPLACE TEMPORARY TABLE STG (data VARIANT);\n\nCOPY INTO STG\nFROM @CANNACOLLECTIVE_COLLECT.BRONZE.ADLS_RAW_STAGE/@{pipeline().parameters.SourceDatabase}/@{pipeline().parameters.TableName}/@{formatDateTime(utcnow(),'yyyy-MM-dd')}/\nFILE_FORMAT = (TYPE = 'JSON')\nPATTERN = '.*_full\\.json$';\n\n\nMERGE INTO IDENTIFIER($TGT) t\nUSING (\n  SELECT\n    data,\n    /* business key: gtin -> upc -> barcode -> sku, plus country/state */\n    MD5(CONCAT_WS('|',\n      COALESCE(LOWER(TRIM(data:gtin::string)),''),\n      COALESCE(LOWER(TRIM(data:upc::string)),''),\n      COALESCE(LOWER(TRIM(data:barcode::string)),''),\n      COALESCE(LOWER(TRIM(data:sku::string)),''),\n      COALESCE(LOWER(TRIM(data:country_code::string)),''),\n      COALESCE(LOWER(TRIM(data:state_code::string)),'')\n    )) AS pk_hash,\n    /* change detector over important attributes */\n    MD5(CONCAT_WS('|',\n      COALESCE(LOWER(TRIM(data:nm::string)),''),\n      COALESCE(LOWER(TRIM(data:cat::string)),''),\n      COALESCE(LOWER(TRIM(data:subcat::string)),''),\n      COALESCE(LOWER(TRIM(data:brand::string)),''),\n      COALESCE(LOWER(TRIM(data:producer::string)),''),\n      COALESCE(LOWER(TRIM(data:supplier::string)),''),\n      COALESCE(LOWER(TRIM(data:descr_short::string)),''),\n      COALESCE(LOWER(TRIM(data:descr::string)),''),\n      COALESCE(LOWER(TRIM(data:size::string)),''),\n      COALESCE(LOWER(TRIM(data:size_pack::string)),''),\n      COALESCE(LOWER(TRIM(data:unit::string)),''),\n      COALESCE(LOWER(TRIM(data:barcode::string)),''),\n      COALESCE(LOWER(TRIM(data:sku::string)),''),\n      COALESCE(LOWER(TRIM(data:gtin::string)),''),\n      COALESCE(LOWER(TRIM(data:ipid::string)),''),\n      COALESCE(LOWER(TRIM(data:upc::string)),''),\n      COALESCE(LOWER(TRIM(data:country_code::string)),''),\n      COALESCE(LOWER(TRIM(data:state_code::string)),''),\n      COALESCE(LOWER(TRIM(data:each_case_txt::string)),''),\n      COALESCE(LOWER(TRIM(data:sell_price_case_txt::string)),''),\n      COALESCE(LOWER(TRIM(data:each_case::string)),''),\n      COALESCE(LOWER(TRIM(data:sell_price::string)),'')\n    )) AS row_hash\n  FROM STG\n) s\nON t.pk_hash = s.pk_hash\nWHEN NOT MATCHED THEN\n  INSERT (pk_hash, row_hash, data) VALUES (s.pk_hash, s.row_hash, s.data)\nWHEN MATCHED AND t.row_hash <> s.row_hash THEN\n  UPDATE SET data = s.data, row_hash = s.row_hash, loaded_timestamp = CURRENT_TIMESTAMP();\n\n-- 4) Return count for ADF validation/logging\nSELECT COUNT(*) AS rows_touched FROM IDENTIFIER($TGT);\n",
                                                    "type": "Expression"
                                                }
                                            }
                                        ],
                                        "scriptBlockExecutionTimeout": "02:00:00"
                                    }
                                }
                            ],
                            "ifTrueActivities": [
                                {
                                    "name": "Get_Watermark",
                                    "type": "Script",
                                    "state": "Inactive",
                                    "onInactiveMarkAs": "Succeeded",
                                    "dependsOn": [],
                                    "policy": {
                                        "timeout": "0.12:00:00",
                                        "retry": 0,
                                        "retryIntervalInSeconds": 30,
                                        "secureOutput": false,
                                        "secureInput": false
                                    },
                                    "userProperties": [],
                                    "linkedServiceName": {
                                        "referenceName": "Canna_Snowflake_Collect",
                                        "type": "LinkedServiceReference"
                                    },
                                    "typeProperties": {
                                        "scripts": [
                                            {
                                                "type": "Query",
                                                "text": {
                                                    "value": "SET src_db   = '@{pipeline().parameters.SourceDatabase}';\nSET sch      = '@{pipeline().parameters.SchemaName}';\nSET tbl      = '@{pipeline().parameters.TableName}';\nSET def_col  = '@{pipeline().parameters.DefaultWatermarkColumn}';\nSET fb_start = TO_TIMESTAMP_NTZ('@{pipeline().parameters.FallbackStart}');\n\nWITH wm AS (\n  SELECT watermark_column, last_watermark\n  FROM CANNACOLLECTIVE_COLLECT.UTILITY.WATERMARK_CONTROL\n  WHERE source_db = :src_db AND schema_name = :sch AND table_name = :tbl\n)\nSELECT\n  COALESCE((SELECT watermark_column FROM wm), :def_col)  AS watermark_column,\n  COALESCE((SELECT last_watermark FROM wm),   :fb_start) AS last_watermark;\n",
                                                    "type": "Expression"
                                                }
                                            }
                                        ],
                                        "scriptBlockExecutionTimeout": "02:00:00"
                                    }
                                },
                                {
                                    "name": "Get_Max_Watermark",
                                    "type": "Lookup",
                                    "state": "Inactive",
                                    "onInactiveMarkAs": "Succeeded",
                                    "dependsOn": [
                                        {
                                            "activity": "Get_Watermark",
                                            "dependencyConditions": [
                                                "Succeeded"
                                            ]
                                        }
                                    ],
                                    "policy": {
                                        "timeout": "0.12:00:00",
                                        "retry": 0,
                                        "retryIntervalInSeconds": 30,
                                        "secureOutput": false,
                                        "secureInput": false
                                    },
                                    "userProperties": [],
                                    "typeProperties": {
                                        "source": {
                                            "type": "PostgreSqlV2Source",
                                            "query": {
                                                "value": "@concat(\n 'SELECT COALESCE(MAX(', activity('Get_Watermark').output.firstRow.watermark_column,\n '), ''', string(activity('Get_Watermark').output.firstRow.last_watermark), ''') AS max_watermark ',\n 'FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName,\n ' WHERE ', activity('Get_Watermark').output.firstRow.watermark_column,\n ' > ''', string(activity('Get_Watermark').output.firstRow.last_watermark), ''''\n)\n",
                                                "type": "Expression"
                                            },
                                            "queryTimeout": "02:00:00"
                                        },
                                        "dataset": {
                                            "referenceName": "Canna_PostgreSQL_Collect_Tables",
                                            "type": "DatasetReference",
                                            "parameters": {
                                                "SchemaName": "collect",
                                                "TableName": "cc_customers"
                                            }
                                        }
                                    }
                                },
                                {
                                    "name": "Copy_To_ADLS_Watermark",
                                    "type": "Copy",
                                    "state": "Inactive",
                                    "onInactiveMarkAs": "Succeeded",
                                    "dependsOn": [
                                        {
                                            "activity": "Get_Max_Watermark",
                                            "dependencyConditions": [
                                                "Succeeded"
                                            ]
                                        }
                                    ],
                                    "policy": {
                                        "timeout": "0.12:00:00",
                                        "retry": 0,
                                        "retryIntervalInSeconds": 30,
                                        "secureOutput": false,
                                        "secureInput": false
                                    },
                                    "userProperties": [],
                                    "typeProperties": {
                                        "source": {
                                            "type": "PostgreSqlV2Source",
                                            "query": {
                                                "value": "@concat(\n 'SELECT * FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName,\n ' WHERE ', activity('Get_Watermark').output.firstRow.watermark_column,\n ' > ''', string(activity('Get_Watermark').output.firstRow.last_watermark), '''',\n ' AND ', activity('Get_Watermark').output.firstRow.watermark_column,\n ' <= ''', string(activity('Get_Max_Watermark').output.firstRow.max_watermark), ''''\n)\n",
                                                "type": "Expression"
                                            },
                                            "queryTimeout": "02:00:00"
                                        },
                                        "sink": {
                                            "type": "JsonSink",
                                            "storeSettings": {
                                                "type": "AzureBlobFSWriteSettings"
                                            },
                                            "formatSettings": {
                                                "type": "JsonWriteSettings"
                                            }
                                        },
                                        "enableStaging": false
                                    },
                                    "inputs": [
                                        {
                                            "referenceName": "Canna_PostgreSQL_Collect_Tables",
                                            "type": "DatasetReference",
                                            "parameters": {
                                                "SchemaName": "collect",
                                                "TableName": "cc_customers"
                                            }
                                        }
                                    ],
                                    "outputs": [
                                        {
                                            "referenceName": "ADLS_JSON",
                                            "type": "DatasetReference",
                                            "parameters": {
                                                "Container": "raw",
                                                "Directory": {
                                                    "value": "@concat(pipeline().parameters.SourceDatabase, '/', pipeline().parameters.TableName, '/', formatDateTime(utcnow(),'yyyy-MM-dd'), '/')\n",
                                                    "type": "Expression"
                                                },
                                                "FileName": {
                                                    "value": "@concat(pipeline().parameters.SchemaName, '_', pipeline().parameters.TableName, '_', formatDateTime(utcnow(),'yyyyMMddHHmmss'), '_inc.json')\n",
                                                    "type": "Expression"
                                                }
                                            }
                                        }
                                    ]
                                },
                                {
                                    "name": "Load_To_Snowflake_Bronze_Append",
                                    "type": "Script",
                                    "state": "Inactive",
                                    "onInactiveMarkAs": "Succeeded",
                                    "dependsOn": [
                                        {
                                            "activity": "Copy_To_ADLS_Watermark",
                                            "dependencyConditions": [
                                                "Succeeded"
                                            ]
                                        }
                                    ],
                                    "policy": {
                                        "timeout": "0.12:00:00",
                                        "retry": 0,
                                        "retryIntervalInSeconds": 30,
                                        "secureOutput": false,
                                        "secureInput": false
                                    },
                                    "userProperties": [],
                                    "linkedServiceName": {
                                        "referenceName": "Canna_Snowflake_Collect",
                                        "type": "LinkedServiceReference"
                                    },
                                    "typeProperties": {
                                        "scripts": [
                                            {
                                                "type": "Query",
                                                "text": {
                                                    "value": "SET sch      = '@{pipeline().parameters.SchemaName}';\nSET tbl      = '@{pipeline().parameters.TableName}';\nSET max_wm   = TO_TIMESTAMP_NTZ('@{activity('Get_Max_Watermark').output.firstRow.max_watermark}');\nSET utility   = 'UTILITY';\nSET target   = :utility || '.' || UPPER(:sch || '_' || :tbl || '@{pipeline().parameters.TargetSuffix}');\n\nBEGIN\n  EXECUTE IMMEDIATE\n    'CREATE TABLE IF NOT EXISTS ' || :target || ' ( ' ||\n    '  data VARIANT, ' ||\n    '  watermark_value TIMESTAMP_NTZ, ' ||\n    '  loaded_timestamp TIMESTAMP_NTZ DEFAULT CURRENT_TIMESTAMP() ' ||\n    ')';\n\n  CREATE OR REPLACE TEMPORARY TABLE STG (data VARIANT);\n\n  COPY INTO STG\n  FROM @CANNACOLLECTIVE_COLLECT.UTILITY.ADLS_RAW_STAGE/@{pipeline().parameters.SourceDatabase}/@{pipeline().parameters.TableName}/@{formatDateTime(utcnow(),'yyyy-MM-dd')}/\n  FILE_FORMAT = (TYPE='JSON')\n  PATTERN='.*_inc\\.json$';\n\n  EXECUTE IMMEDIATE\n    'INSERT INTO ' || :target || ' (data, watermark_value) ' ||\n    'SELECT data, ''' || TO_VARCHAR(:max_wm) || '''::TIMESTAMP_NTZ FROM STG';\n\n  EXECUTE IMMEDIATE\n    'SELECT COUNT(*) AS rows_loaded FROM ' || :target ||\n    ' WHERE watermark_value = ''' || TO_VARCHAR(:max_wm) || '''::TIMESTAMP_NTZ';\nEND;\n",
                                                    "type": "Expression"
                                                }
                                            }
                                        ],
                                        "scriptBlockExecutionTimeout": "02:00:00"
                                    }
                                },
                                {
                                    "name": "Update_Watermark",
                                    "type": "Script",
                                    "state": "Inactive",
                                    "onInactiveMarkAs": "Succeeded",
                                    "dependsOn": [
                                        {
                                            "activity": "Load_To_Snowflake_Bronze_Append",
                                            "dependencyConditions": [
                                                "Succeeded"
                                            ]
                                        }
                                    ],
                                    "policy": {
                                        "timeout": "0.12:00:00",
                                        "retry": 0,
                                        "retryIntervalInSeconds": 30,
                                        "secureOutput": false,
                                        "secureInput": false
                                    },
                                    "userProperties": [],
                                    "linkedServiceName": {
                                        "referenceName": "Canna_Snowflake_Collect",
                                        "type": "LinkedServiceReference"
                                    },
                                    "typeProperties": {
                                        "scripts": [
                                            {
                                                "type": "Query",
                                                "text": {
                                                    "value": "SET src_db = '@{pipeline().parameters.SourceDatabase}';\nSET sch    = '@{pipeline().parameters.SchemaName}';\nSET tbl    = '@{pipeline().parameters.TableName}';\nSET col    = '@{activity('Get_Watermark').output.firstRow.watermark_column}';\nSET max_wm = TO_TIMESTAMP_NTZ('@{activity('Get_Max_Watermark').output.firstRow.max_watermark}');\n\nMERGE INTO CANNACOLLECTIVE_COLLECT.UTILITY.WATERMARK_CONTROL t\nUSING (\n  SELECT :src_db AS source_db, :sch AS schema_name, :tbl AS table_name,\n         :col AS watermark_column, :max_wm::TIMESTAMP_NTZ AS last_watermark\n) s\nON t.source_db=s.source_db AND t.schema_name=s.schema_name AND t.table_name=s.table_name\nWHEN MATCHED THEN UPDATE SET t.watermark_column=s.watermark_column, t.last_watermark=s.last_watermark, t.updated_at=CURRENT_TIMESTAMP()\nWHEN NOT MATCHED THEN INSERT (source_db,schema_name,table_name,watermark_column,last_watermark)\nVALUES (s.source_db,s.schema_name,s.table_name,s.watermark_column,s.last_watermark);\n",
                                                    "type": "Expression"
                                                }
                                            }
                                        ],
                                        "scriptBlockExecutionTimeout": "02:00:00"
                                    }
                                }
                            ]
                        }
                    }
                ],
                "policy": {
                    "elapsedTimeMetric": {}
                },
                "parameters": {
                    "SourceDatabase": {
                        "type": "string",
                        "defaultValue": "collect"
                    },
                    "SchemaName": {
                        "type": "string",
                        "defaultValue": "collect"
                    },
                    "TableName": {
                        "type": "string",
                        "defaultValue": "products_01_on"
                    },
                    "DefaultWatermarkColumn": {
                        "type": "string",
                        "defaultValue": "tm"
                    },
                    "FallbackStart": {
                        "type": "string",
                        "defaultValue": "2000-01-01 00:00:00"
                    },
                    "TargetSuffix": {
                        "type": "string",
                        "defaultValue": "_V4"
                    }
                },
                "variables": {
                    "ValidationStatus": {
                        "type": "String"
                    },
                    "IsFirstLoad": {
                        "type": "String",
                        "defaultValue": "TRUE"
                    },
                    "TableExists": {
                        "type": "String"
                    },
                    "RunStamp": {
                        "type": "String",
                        "defaultValue": "@formatDateTime(utcNow(),'yyyyMMddHHmmss')"
                    }
                },
                "folder": {
                    "name": "Archive"
                },
                "annotations": [],
                "lastPublishTime": "2025-09-18T14:21:00Z"
            },
            "dependsOn": [
                "[concat(variables('factoryId'), '/datasets/Canna_PostgreSQL_Collect_Tables')]",
                "[concat(variables('factoryId'), '/datasets/ADLS_JSON')]",
                "[concat(variables('factoryId'), '/linkedServices/Canna_Snowflake_Collect')]",
                "[concat(variables('factoryId'), '/datasets/Snowflake_Collect_Bronze')]",
                "[concat(variables('factoryId'), '/linkedServices/Canna_ADLS')]"
            ]
        },
        {
            "name": "[concat(parameters('factoryName'), '/Collect_Table_With_Validation_JSON_LARGE_TABLE_SETTINGS')]",
            "type": "Microsoft.DataFactory/factories/pipelines",
            "apiVersion": "2018-06-01",
            "properties": {
                "activities": [
                    {
                        "name": "Get_Source_Row_Count",
                        "description": "Get Postgres SQL table row count ",
                        "type": "Lookup",
                        "dependsOn": [],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "source": {
                                "type": "PostgreSqlV2Source",
                                "query": {
                                    "value": "@if(or(or(equals(pipeline().parameters.TableName, 'cc_catalog_t'), equals(pipeline().parameters.TableName, 'cc_catalog_avail_t')), or(or(equals(pipeline().parameters.TableName, 'cc_io33_t'), equals(pipeline().parameters.TableName, 'cc_io_t')), equals(pipeline().parameters.TableName, 'cc_po33_t'))), concat('SELECT COUNT(*) as row_count FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName, ' WHERE tm >= CURRENT_DATE - INTERVAL ''3 years'''), concat('SELECT COUNT(*) as row_count FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName))",
                                    "type": "Expression"
                                },
                                "queryTimeout": "02:00:00"
                            },
                            "dataset": {
                                "referenceName": "Canna_PostgreSQL_Collect_Tables",
                                "type": "DatasetReference",
                                "parameters": {
                                    "SchemaName": "@pipeline().parameters.SchemaName",
                                    "TableName": "@pipeline().parameters.TableName"
                                }
                            }
                        }
                    },
                    {
                        "name": "Check_Duplicates",
                        "description": "Check for duplicate rows in the table",
                        "type": "Lookup",
                        "dependsOn": [
                            {
                                "activity": "Get_Source_Row_Count",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "source": {
                                "type": "PostgreSqlV2Source",
                                "query": {
                                    "value": "@if(or(or(equals(pipeline().parameters.TableName, 'cc_catalog_t'), equals(pipeline().parameters.TableName, 'cc_catalog_avail_t')), or(or(equals(pipeline().parameters.TableName, 'cc_io33_t'), equals(pipeline().parameters.TableName, 'cc_io_t')), equals(pipeline().parameters.TableName, 'cc_po33_t'))), concat('SELECT (SELECT COUNT(*) FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName, ' WHERE tm >= CURRENT_DATE - INTERVAL ''3 years'') - (SELECT COUNT(*) FROM (SELECT DISTINCT * FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName, ' WHERE tm >= CURRENT_DATE - INTERVAL ''3 years'') t) as duplicate_count'), concat('SELECT (SELECT COUNT(*) FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName, ') - (SELECT COUNT(*) FROM (SELECT DISTINCT * FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName, ') t) as duplicate_count'))",
                                    "type": "Expression"
                                },
                                "queryTimeout": "02:00:00"
                            },
                            "dataset": {
                                "referenceName": "Canna_PostgreSQL_Collect_Tables",
                                "type": "DatasetReference",
                                "parameters": {
                                    "SchemaName": "@pipeline().parameters.SchemaName",
                                    "TableName": "@pipeline().parameters.TableName"
                                }
                            }
                        }
                    },
                    {
                        "name": "Copy_To_ADLS",
                        "description": "Copy raw Postgres data into ADLS",
                        "type": "Copy",
                        "dependsOn": [
                            {
                                "activity": "Check_Duplicates",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "source": {
                                "type": "PostgreSqlV2Source",
                                "query": {
                                    "value": "@if(or(or(equals(pipeline().parameters.TableName, 'cc_catalog_t'), equals(pipeline().parameters.TableName, 'cc_catalog_avail_t')), or(or(equals(pipeline().parameters.TableName, 'cc_io33_t'), equals(pipeline().parameters.TableName, 'cc_io_t')), equals(pipeline().parameters.TableName, 'cc_po33_t'))), concat('SELECT * FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName, ' WHERE tm >= CURRENT_DATE - INTERVAL ''3 years'''), '')",
                                    "type": "Expression"
                                },
                                "queryTimeout": "12:00:00"
                            },
                            "sink": {
                                "type": "JsonSink",
                                "storeSettings": {
                                    "type": "AzureBlobFSWriteSettings"
                                },
                                "formatSettings": {
                                    "type": "JsonWriteSettings"
                                }
                            },
                            "enableStaging": false,
                            "parallelCopies": 32,
                            "enableSkipIncompatibleRow": false,
                            "validateDataConsistency": true,
                            "logSettings": {
                                "enableCopyActivityLog": true,
                                "copyActivityLogSettings": {
                                    "logLevel": "Info",
                                    "enableReliableLogging": false
                                },
                                "logLocationSettings": {
                                    "linkedServiceName": {
                                        "referenceName": "Canna_ADLS",
                                        "type": "LinkedServiceReference"
                                    },
                                    "path": "logs/copy-activity"
                                }
                            },
                            "dataIntegrationUnits": 32
                        },
                        "inputs": [
                            {
                                "referenceName": "Canna_PostgreSQL_Collect_Tables",
                                "type": "DatasetReference",
                                "parameters": {
                                    "SchemaName": "@pipeline().parameters.SchemaName",
                                    "TableName": "@pipeline().parameters.TableName"
                                }
                            }
                        ],
                        "outputs": [
                            {
                                "referenceName": "ADLS_JSON",
                                "type": "DatasetReference",
                                "parameters": {
                                    "Container": "raw",
                                    "Directory": {
                                        "value": "@concat(pipeline().parameters.SourceDatabase, '/', pipeline().parameters.TableName, '/', formatDateTime(utcnow(),'yyyy-MM-dd'))",
                                        "type": "Expression"
                                    },
                                    "FileName": {
                                        "value": "@concat(pipeline().parameters.SchemaName, '_', pipeline().parameters.TableName, '_latest.json')",
                                        "type": "Expression"
                                    }
                                }
                            }
                        ]
                    },
                    {
                        "name": "Validate_ADLS_File",
                        "description": "Verify the JSON file was created successfully in ADLS",
                        "type": "GetMetadata",
                        "dependsOn": [
                            {
                                "activity": "Copy_To_ADLS",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "dataset": {
                                "referenceName": "ADLS_JSON",
                                "type": "DatasetReference",
                                "parameters": {
                                    "Container": "raw",
                                    "Directory": "@concat(pipeline().parameters.SourceDatabase, '/', formatDateTime(utcnow(), 'yyyy-MM-dd'))",
                                    "FileName": "@concat(pipeline().parameters.SchemaName, '_', pipeline().parameters.TableName, '_', formatDateTime(utcnow(), 'yyyyMMddHHmmss'), '.json')"
                                }
                            },
                            "fieldList": [
                                "exists",
                                "childItems"
                            ],
                            "storeSettings": {
                                "type": "AzureBlobFSReadSettings",
                                "recursive": true,
                                "enablePartitionDiscovery": false
                            },
                            "formatSettings": {
                                "type": "JsonReadSettings"
                            }
                        }
                    },
                    {
                        "name": "Load_To_Snowflake_Bronze",
                        "description": "Load ADLS data into Snowflake Bronze layer",
                        "type": "Script",
                        "dependsOn": [
                            {
                                "activity": "Validate_ADLS_File",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "linkedServiceName": {
                            "referenceName": "Canna_Snowflake_Collect",
                            "type": "LinkedServiceReference"
                        },
                        "typeProperties": {
                            "scripts": [
                                {
                                    "type": "Query",
                                    "text": {
                                        "value": "USE SCHEMA BRONZE;\n\nCREATE OR REPLACE TABLE @{pipeline().parameters.SchemaName}_@{pipeline().parameters.TableName} (data VARIANT);\n\nCOPY INTO @{pipeline().parameters.SchemaName}_@{pipeline().parameters.TableName}\nFROM @CANNACOLLECTIVE_COLLECT.BRONZE.ADLS_RAW_STAGE/@{pipeline().parameters.SourceDatabase}/@{pipeline().parameters.TableName}/@{formatDateTime(utcnow(), 'yyyy-MM-dd')}/@{pipeline().parameters.SchemaName}_@{pipeline().parameters.TableName}_latest.json\nFILE_FORMAT = (TYPE = 'JSON');\n\nGRANT SELECT ON TABLE @{pipeline().parameters.SchemaName}_@{pipeline().parameters.TableName} TO ROLE SYSADMIN;\n\nSELECT COUNT(*) as rows_loaded FROM @{pipeline().parameters.SchemaName}_@{pipeline().parameters.TableName};",
                                        "type": "Expression"
                                    }
                                }
                            ],
                            "scriptBlockExecutionTimeout": "02:00:00"
                        }
                    },
                    {
                        "name": "Get_Snowflake_Row_Count",
                        "description": "Get loaded row count from Snowflake Bronze table",
                        "type": "Lookup",
                        "dependsOn": [
                            {
                                "activity": "Load_To_Snowflake_Bronze",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "source": {
                                "type": "SnowflakeV2Source",
                                "query": {
                                    "value": "SELECT COUNT(*) as snowflake_count FROM CANNACOLLECTIVE_COLLECT.BRONZE.@{pipeline().parameters.SchemaName}_@{pipeline().parameters.TableName};",
                                    "type": "Expression"
                                },
                                "exportSettings": {
                                    "type": "SnowflakeExportCopyCommand"
                                }
                            },
                            "dataset": {
                                "referenceName": "Snowflake_Collect_Bronze",
                                "type": "DatasetReference",
                                "parameters": {}
                            }
                        }
                    },
                    {
                        "name": "Validate_Row_Count_Match",
                        "description": "Compare Postgres vs Snowflake row counts",
                        "type": "IfCondition",
                        "dependsOn": [
                            {
                                "activity": "Get_Snowflake_Row_Count",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "userProperties": [],
                        "typeProperties": {
                            "expression": {
                                "value": "@equals(activity('Get_Source_Row_Count').output.firstRow.row_count, int(activity('Get_Snowflake_Row_Count').output.firstRow.SNOWFLAKE_COUNT))",
                                "type": "Expression"
                            },
                            "ifFalseActivities": [
                                {
                                    "name": "Set_Validation_Error",
                                    "description": "Mark validation as failed due to row count mismatch",
                                    "type": "SetVariable",
                                    "dependsOn": [],
                                    "policy": {
                                        "secureOutput": false,
                                        "secureInput": false
                                    },
                                    "userProperties": [],
                                    "typeProperties": {
                                        "variableName": "ValidationStatus",
                                        "value": "ROW_COUNT_MISMATCH"
                                    }
                                }
                            ],
                            "ifTrueActivities": [
                                {
                                    "name": "Set_Validation_Status",
                                    "description": "Mark validation as successful",
                                    "type": "SetVariable",
                                    "dependsOn": [],
                                    "policy": {
                                        "secureOutput": false,
                                        "secureInput": false
                                    },
                                    "userProperties": [],
                                    "typeProperties": {
                                        "variableName": "ValidationStatus",
                                        "value": "SUCCESS"
                                    }
                                }
                            ]
                        }
                    },
                    {
                        "name": "Check_Null_Values",
                        "description": "Count null values in key columns",
                        "type": "Lookup",
                        "dependsOn": [
                            {
                                "activity": "Load_To_Snowflake_Bronze",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "source": {
                                "type": "SnowflakeV2Source",
                                "query": {
                                    "value": "SELECT \n    SUM(CASE WHEN data:id IS NULL THEN 1 ELSE 0 END) as null_ids,\n    SUM(CASE WHEN data:name IS NULL THEN 1 ELSE 0 END) as null_names\nFROM CANNACOLLECTIVE_COLLECT.BRONZE.@{pipeline().parameters.SchemaName}_@{pipeline().parameters.TableName}",
                                    "type": "Expression"
                                },
                                "exportSettings": {
                                    "type": "SnowflakeExportCopyCommand"
                                }
                            },
                            "dataset": {
                                "referenceName": "Snowflake_Collect_Bronze",
                                "type": "DatasetReference",
                                "parameters": {}
                            }
                        }
                    },
                    {
                        "name": "Log_Pipeline_Summary",
                        "description": "Insert execution summary into UTILITY.PIPELINE_EXECUTION_LOG",
                        "type": "Script",
                        "dependsOn": [
                            {
                                "activity": "Validate_Row_Count_Match",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            },
                            {
                                "activity": "Check_Null_Values",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "linkedServiceName": {
                            "referenceName": "Canna_Snowflake_Collect",
                            "type": "LinkedServiceReference"
                        },
                        "typeProperties": {
                            "scripts": [
                                {
                                    "type": "Query",
                                    "text": {
                                        "value": "INSERT INTO CANNACOLLECTIVE_COLLECT.UTILITY.PIPELINE_EXECUTION_LOG\nVALUES (\n    '@{pipeline().RunId}',\n    '@{pipeline().parameters.TableName}',\n    '@{formatDateTime(utcnow(), 'yyyy-MM-dd')}',\n    '@{utcnow()}',\n    @{activity('Get_Source_Row_Count').output.firstRow.row_count},\n    @{int(activity('Get_Snowflake_Row_Count').output.firstRow.SNOWFLAKE_COUNT)},\n    @{equals(variables('ValidationStatus'), 'SUCCESS')},\n    @{activity('Check_Duplicates').output.firstRow.duplicate_count},\n    @{int(activity('Check_Null_Values').output.firstRow.NULL_IDS)},\n    @{int(activity('Check_Null_Values').output.firstRow.NULL_NAMES)},\n    '@{variables('ValidationStatus')}',\n    0\n);",
                                        "type": "Expression"
                                    }
                                }
                            ],
                            "scriptBlockExecutionTimeout": "02:00:00"
                        }
                    }
                ],
                "policy": {
                    "elapsedTimeMetric": {}
                },
                "parameters": {
                    "SourceDatabase": {
                        "type": "string",
                        "defaultValue": "collect"
                    },
                    "SchemaName": {
                        "type": "string"
                    },
                    "TableName": {
                        "type": "string"
                    }
                },
                "variables": {
                    "ValidationStatus": {
                        "type": "String"
                    }
                },
                "folder": {
                    "name": "Archive"
                },
                "annotations": [],
                "lastPublishTime": "2025-09-18T14:21:00Z"
            },
            "dependsOn": [
                "[concat(variables('factoryId'), '/datasets/Canna_PostgreSQL_Collect_Tables')]",
                "[concat(variables('factoryId'), '/datasets/ADLS_JSON')]",
                "[concat(variables('factoryId'), '/linkedServices/Canna_Snowflake_Collect')]",
                "[concat(variables('factoryId'), '/datasets/Snowflake_Collect_Bronze')]",
                "[concat(variables('factoryId'), '/linkedServices/Canna_ADLS')]"
            ]
        },
        {
            "name": "[concat(parameters('factoryName'), '/Collect_Table_With_Validation__Incremental_JSON_V4')]",
            "type": "Microsoft.DataFactory/factories/pipelines",
            "apiVersion": "2018-06-01",
            "properties": {
                "activities": [
                    {
                        "name": "Get_Source_Row_Count",
                        "description": "Get Postgres SQL table row count ",
                        "type": "Lookup",
                        "dependsOn": [
                            {
                                "activity": "Set_Watermark_Column",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "source": {
                                "type": "PostgreSqlV2Source",
                                "query": {
                                    "value": "@if(equals(variables('WatermarkCol'), 'none'),\n  concat('SELECT COUNT(*) as row_count FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName),\n  if(equals(variables('LoadStrategy'), 'ROLLING_30DAY'),\n    concat('SELECT COUNT(*) as row_count FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName, ' WHERE ', variables('WatermarkCol'), ' >= CURRENT_DATE - INTERVAL ''30 days'''),\n    if(equals(variables('LoadStrategy'), 'FULL_RELOAD'),\n      concat('SELECT COUNT(*) as row_count FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName),\n      concat('SELECT COUNT(*) as row_count FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName, ' WHERE ', variables('WatermarkCol'), ' > ''', pipeline().parameters.LastWatermark, '''')\n    )\n  )\n)",
                                    "type": "Expression"
                                },
                                "queryTimeout": "02:00:00"
                            },
                            "dataset": {
                                "referenceName": "Canna_PostgreSQL_Collect_Tables",
                                "type": "DatasetReference",
                                "parameters": {
                                    "SchemaName": "@pipeline().parameters.SchemaName",
                                    "TableName": "@pipeline().parameters.TableName"
                                }
                            }
                        }
                    },
                    {
                        "name": "Copy_To_ADLS",
                        "description": "Copy raw Postgres data into ADLS",
                        "type": "Copy",
                        "dependsOn": [
                            {
                                "activity": "No_tm_Tables",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "source": {
                                "type": "PostgreSqlV2Source",
                                "query": {
                                    "value": "@if(equals(variables('WatermarkCol'), 'none'),\n  concat('SELECT * FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName),\n  if(equals(variables('LoadStrategy'), 'ROLLING_30DAY'),\n    concat('SELECT * FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName, ' WHERE ', variables('WatermarkCol'), ' >= CURRENT_DATE - INTERVAL ''30 days'''),\n    if(equals(variables('LoadStrategy'), 'FULL_RELOAD'),\n      concat('SELECT * FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName),\n      concat('SELECT * FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName, ' WHERE ', variables('WatermarkCol'), ' > ''', pipeline().parameters.LastWatermark, '''')\n    )\n  )\n)",
                                    "type": "Expression"
                                },
                                "queryTimeout": "02:00:00"
                            },
                            "sink": {
                                "type": "JsonSink",
                                "storeSettings": {
                                    "type": "AzureBlobFSWriteSettings"
                                },
                                "formatSettings": {
                                    "type": "JsonWriteSettings"
                                }
                            },
                            "enableStaging": false,
                            "parallelCopies": {
                                "value": "@int(variables('ParallelCopies'))",
                                "type": "Expression"
                            },
                            "enableSkipIncompatibleRow": false,
                            "validateDataConsistency": true,
                            "logSettings": {
                                "enableCopyActivityLog": true,
                                "copyActivityLogSettings": {
                                    "logLevel": "Info",
                                    "enableReliableLogging": false
                                },
                                "logLocationSettings": {
                                    "linkedServiceName": {
                                        "referenceName": "Canna_ADLS",
                                        "type": "LinkedServiceReference"
                                    },
                                    "path": "logs/copy-activity"
                                }
                            },
                            "dataIntegrationUnits": {
                                "value": "@int(variables('DataIntegrationUnits'))",
                                "type": "Expression"
                            }
                        },
                        "inputs": [
                            {
                                "referenceName": "Canna_PostgreSQL_Collect_Tables",
                                "type": "DatasetReference",
                                "parameters": {
                                    "SchemaName": "@pipeline().parameters.SchemaName",
                                    "TableName": "@pipeline().parameters.TableName"
                                }
                            }
                        ],
                        "outputs": [
                            {
                                "referenceName": "ADLS_JSON",
                                "type": "DatasetReference",
                                "parameters": {
                                    "Container": "raw",
                                    "Directory": {
                                        "value": "@concat(\n  pipeline().parameters.SourceDatabase, '/',\n  pipeline().parameters.TableName, '/',\n  pipeline().parameters.RunDate, '/',\n  pipeline().RunId         \n)\n",
                                        "type": "Expression"
                                    },
                                    "FileName": {
                                        "value": "@concat(pipeline().parameters.SchemaName, '_', pipeline().parameters.TableName, '_', formatDateTime(utcNow(), 'yyyyMMdd_HHmmss'), '_', variables('LoadStrategy'), '.json')",
                                        "type": "Expression"
                                    }
                                }
                            }
                        ]
                    },
                    {
                        "name": "Validate_ADLS_File",
                        "description": "Verify the JSON file was created successfully in ADLS",
                        "type": "GetMetadata",
                        "dependsOn": [
                            {
                                "activity": "Copy_To_ADLS",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "dataset": {
                                "referenceName": "ADLS_JSON",
                                "type": "DatasetReference",
                                "parameters": {
                                    "Container": "raw",
                                    "Directory": "@concat(pipeline().parameters.SourceDatabase, '/', formatDateTime(utcnow(), 'yyyy-MM-dd'))",
                                    "FileName": "@concat(pipeline().parameters.SchemaName, '_', pipeline().parameters.TableName, '_', formatDateTime(utcnow(), 'yyyyMMddHHmmss'), '.json')"
                                }
                            },
                            "fieldList": [
                                "exists",
                                "childItems"
                            ],
                            "storeSettings": {
                                "type": "AzureBlobFSReadSettings",
                                "recursive": true,
                                "enablePartitionDiscovery": false
                            },
                            "formatSettings": {
                                "type": "JsonReadSettings"
                            }
                        }
                    },
                    {
                        "name": "Load_To_Snowflake_Bronze",
                        "description": "Load ADLS data into Snowflake Bronze layer",
                        "type": "Script",
                        "dependsOn": [
                            {
                                "activity": "Delete_30_Day_Data",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "linkedServiceName": {
                            "referenceName": "Canna_Snowflake_Collect",
                            "type": "LinkedServiceReference"
                        },
                        "typeProperties": {
                            "scripts": [
                                {
                                    "type": "Query",
                                    "text": {
                                        "value": "@concat(\n  'ALTER SESSION SET TIMEZONE = ''UTC''; ',\n  'USE SCHEMA BRONZE; ',\n\n  'CREATE TABLE IF NOT EXISTS ', \n  if(endsWith(pipeline().parameters.TableName, '_t'), replace(pipeline().parameters.TableName, '_t', ''), pipeline().parameters.TableName), ' (',\n  '  data VARIANT,',\n  '  load_timestamp TIMESTAMP_NTZ DEFAULT CURRENT_TIMESTAMP()',\n  ');',\n\n  'COPY INTO ', \n  if(endsWith(pipeline().parameters.TableName, '_t'), replace(pipeline().parameters.TableName, '_t', ''), pipeline().parameters.TableName), ' (data) ',\n  'FROM @SOURCE_DB.BRONZE.ADLS_RAW_STAGE/',\n      pipeline().parameters.SourceDatabase, '/', pipeline().parameters.TableName, '/',\n      pipeline().parameters.RunDate, '/', pipeline().RunId, '/ ',\n  'PATTERN = ''', '.*', variables('LoadStrategy'), '.*', ''' ',\n  'FILE_FORMAT = (TYPE = JSON) ',\n  'FORCE = ', if(equals(variables('LoadStrategy'), 'FULL_RELOAD'), 'TRUE', 'FALSE'), ' ',\n  'ON_ERROR = ''CONTINUE'';',\n\n  'GRANT SELECT ON TABLE ', \n  if(endsWith(pipeline().parameters.TableName, '_t'), replace(pipeline().parameters.TableName, '_t', ''), pipeline().parameters.TableName), \n  ' TO ROLE SYSADMIN;',\n\n  'SELECT COUNT(*) AS rows_loaded, ''', variables('LoadStrategy'), ''' AS strategy_used ',\n  'FROM ', \n  if(endsWith(pipeline().parameters.TableName, '_t'), replace(pipeline().parameters.TableName, '_t', ''), pipeline().parameters.TableName), \n  ' WHERE data IS NOT NULL;'\n)",
                                        "type": "Expression"
                                    }
                                }
                            ],
                            "scriptBlockExecutionTimeout": "02:00:00"
                        }
                    },
                    {
                        "name": "Get_Snowflake_Row_Count",
                        "description": "Get loaded row count from Snowflake Bronze table",
                        "type": "Lookup",
                        "dependsOn": [
                            {
                                "activity": "Load_To_Snowflake_Bronze",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "source": {
                                "type": "SnowflakeV2Source",
                                "query": {
                                    "value": "SELECT COUNT(*) as snowflake_count \nFROM SOURCE_DB.BRONZE.@{if(endsWith(pipeline().parameters.TableName, '_t'), replace(pipeline().parameters.TableName, '_t', ''), pipeline().parameters.TableName)};",
                                    "type": "Expression"
                                },
                                "exportSettings": {
                                    "type": "SnowflakeExportCopyCommand"
                                }
                            },
                            "dataset": {
                                "referenceName": "Snowflake_Collect_Bronze",
                                "type": "DatasetReference",
                                "parameters": {}
                            }
                        }
                    },
                    {
                        "name": "Validate_Row_Count_Match",
                        "description": "Compare Postgres vs Snowflake row counts",
                        "type": "IfCondition",
                        "dependsOn": [
                            {
                                "activity": "Get_Snowflake_Row_Count",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "userProperties": [],
                        "typeProperties": {
                            "expression": {
                                "value": "@equals(string(activity('Get_Source_Row_Count').output.firstRow.row_count), string(activity('Get_Snowflake_Row_Count').output.firstRow.SNOWFLAKE_COUNT))",
                                "type": "Expression"
                            },
                            "ifFalseActivities": [
                                {
                                    "name": "Set_Validation_Error",
                                    "description": "Mark validation as failed due to row count mismatch",
                                    "type": "SetVariable",
                                    "dependsOn": [],
                                    "policy": {
                                        "secureOutput": false,
                                        "secureInput": false
                                    },
                                    "userProperties": [],
                                    "typeProperties": {
                                        "variableName": "ValidationStatus",
                                        "value": "ROW_COUNT_MISMATCH"
                                    }
                                }
                            ],
                            "ifTrueActivities": [
                                {
                                    "name": "Set_Validation_Status",
                                    "description": "Mark validation as successful",
                                    "type": "SetVariable",
                                    "dependsOn": [],
                                    "policy": {
                                        "secureOutput": false,
                                        "secureInput": false
                                    },
                                    "userProperties": [],
                                    "typeProperties": {
                                        "variableName": "ValidationStatus",
                                        "value": "SUCCESS"
                                    }
                                }
                            ]
                        }
                    },
                    {
                        "name": "Check_Null_Values",
                        "description": "Count null values in key columns",
                        "type": "Lookup",
                        "dependsOn": [
                            {
                                "activity": "Load_To_Snowflake_Bronze",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "source": {
                                "type": "SnowflakeV2Source",
                                "query": {
                                    "value": "SELECT \n    SUM(CASE WHEN data:id IS NULL THEN 1 ELSE 0 END) as null_ids,\n    SUM(CASE WHEN data:name IS NULL THEN 1 ELSE 0 END) as null_names\nFROM SOURCE_DB.BRONZE.@{if(endsWith(pipeline().parameters.TableName, '_t'), replace(pipeline().parameters.TableName, '_t', ''), pipeline().parameters.TableName)}",
                                    "type": "Expression"
                                },
                                "exportSettings": {
                                    "type": "SnowflakeExportCopyCommand"
                                }
                            },
                            "dataset": {
                                "referenceName": "Snowflake_Collect_Bronze",
                                "type": "DatasetReference",
                                "parameters": {}
                            }
                        }
                    },
                    {
                        "name": "Log_Pipeline_Summary",
                        "description": "Insert execution summary into UTILITY.PIPELINE_EXECUTION_LOG",
                        "type": "Script",
                        "dependsOn": [
                            {
                                "activity": "Validate_Row_Count_Match",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            },
                            {
                                "activity": "Check_Null_Values",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "linkedServiceName": {
                            "referenceName": "Canna_Snowflake_Collect",
                            "type": "LinkedServiceReference"
                        },
                        "typeProperties": {
                            "scripts": [
                                {
                                    "type": "Query",
                                    "text": {
                                        "value": "@concat(\n  'INSERT INTO SOURCE_DB.UTILITY.PIPELINE_EXECUTION_LOG VALUES (''',\n  pipeline().RunId, ''', ''',\n  pipeline().parameters.TableName, ''', ''',\n  formatDateTime(utcnow(), 'yyyy-MM-dd'), ''', ''',\n  utcnow(), ''', ',\n  coalesce(string(activity('Get_Source_Row_Count').output.firstRow.row_count), '0'), ', ',\n  coalesce(string(activity('Get_Snowflake_Row_Count').output.firstRow.SNOWFLAKE_COUNT), '0'), ', ',\n  if(equals(variables('ValidationStatus'), 'SUCCESS'), 'TRUE', 'FALSE'), ', ',\n  coalesce(string(activity('Check_Duplicates').output.firstRow.duplicate_count), '0'), ', ',\n  coalesce(string(activity('Check_Null_Values').output.firstRow.NULL_IDS), '0'), ', ',\n  coalesce(string(activity('Check_Null_Values').output.firstRow.NULL_NAMES), '0'), ', ''',\n  variables('ValidationStatus'), ''', ',\n  '0', \n  ');'\n)",
                                        "type": "Expression"
                                    }
                                }
                            ],
                            "scriptBlockExecutionTimeout": "02:00:00"
                        }
                    },
                    {
                        "name": "Check_Duplicates",
                        "description": "Check for duplicate rows in the table",
                        "type": "Lookup",
                        "dependsOn": [
                            {
                                "activity": "Get_Source_Row_Count",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "source": {
                                "type": "PostgreSqlV2Source",
                                "query": {
                                    "value": "@if(equals(variables('LoadStrategy'), 'ROLLING_30DAY'),\n  concat('SELECT (SELECT COUNT(*) FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName, ' WHERE ', variables('WatermarkCol'), ' >= CURRENT_DATE - INTERVAL ''30 days'') - (SELECT COUNT(*) FROM (SELECT DISTINCT * FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName, ' WHERE ', variables('WatermarkCol'), ' >= CURRENT_DATE - INTERVAL ''30 days'') t) as duplicate_count'),\n  concat('SELECT (SELECT COUNT(*) FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName, ') - (SELECT COUNT(*) FROM (SELECT DISTINCT * FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName, ') t) as duplicate_count')\n)",
                                    "type": "Expression"
                                },
                                "queryTimeout": "02:00:00"
                            },
                            "dataset": {
                                "referenceName": "Canna_PostgreSQL_Collect_Tables",
                                "type": "DatasetReference",
                                "parameters": {
                                    "SchemaName": "@pipeline().parameters.SchemaName",
                                    "TableName": "@pipeline().parameters.TableName"
                                }
                            }
                        }
                    },
                    {
                        "name": "Delete_30_Day_Data",
                        "type": "Script",
                        "dependsOn": [
                            {
                                "activity": "Validate_ADLS_File",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "linkedServiceName": {
                            "referenceName": "Canna_Snowflake_Collect",
                            "type": "LinkedServiceReference"
                        },
                        "typeProperties": {
                            "scripts": [
                                {
                                    "type": "Query",
                                    "text": {
                                        "value": "@concat(\n  'USE SCHEMA BRONZE; ',\n  'CREATE TABLE IF NOT EXISTS ', \n  if(endsWith(pipeline().parameters.TableName, '_t'), replace(pipeline().parameters.TableName, '_t', ''), pipeline().parameters.TableName), \n  ' (data VARIANT); ',\n  'ALTER SESSION SET TIMEZONE = ''UTC''; ',\n  if(equals(variables('LoadStrategy'), 'ROLLING_30DAY'),\n    concat('DELETE FROM ', \n      if(endsWith(pipeline().parameters.TableName, '_t'), replace(pipeline().parameters.TableName, '_t', ''), pipeline().parameters.TableName), \n      ' WHERE TO_DATE(CONVERT_TIMEZONE(''UTC'', TRY_TO_TIMESTAMP_TZ(data:\"', variables('WatermarkCol'), '\"::string))) >= DATEADD(day, -30, CURRENT_DATE()); '),\n    if(equals(variables('LoadStrategy'), 'FULL_RELOAD'),\n      concat('TRUNCATE TABLE ', \n        if(endsWith(pipeline().parameters.TableName, '_t'), replace(pipeline().parameters.TableName, '_t', ''), pipeline().parameters.TableName), \n        '; '),\n      'SELECT ''No cleanup needed for incremental strategy'' as status; '\n    )\n  ),\n  'SELECT ''', variables('LoadStrategy'), ''' as strategy_applied;'\n)",
                                        "type": "Expression"
                                    }
                                }
                            ],
                            "scriptBlockExecutionTimeout": "02:00:00"
                        }
                    },
                    {
                        "name": "Get_Table_Strategy",
                        "type": "Lookup",
                        "dependsOn": [],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "source": {
                                "type": "SnowflakeV2Source",
                                "query": {
                                    "value": "SELECT \n       COALESCE(load_strategy, 'INCREMENTAL') as load_strategy,\n       COALESCE(parallel_copies, 8) as parallel_copies,\n       COALESCE(data_integration_units, 16) as data_integration_units,\n       COALESCE(watermark_column, 'tm') as watermark_column\n   FROM SOURCE_DB.UTILITY.TABLE_STRATEGY_CONFIG \n   WHERE table_name = '@{pipeline().parameters.TableName}'\n   AND is_active = TRUE",
                                    "type": "Expression"
                                },
                                "exportSettings": {
                                    "type": "SnowflakeExportCopyCommand"
                                }
                            },
                            "dataset": {
                                "referenceName": "Snowflake_Collect_Bronze",
                                "type": "DatasetReference",
                                "parameters": {}
                            }
                        }
                    },
                    {
                        "name": "Set_Strategy_From_Config",
                        "type": "SetVariable",
                        "dependsOn": [
                            {
                                "activity": "Get_Table_Strategy",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "variableName": "LoadStrategy",
                            "value": {
                                "value": "@activity('Get_Table_Strategy').output.firstRow.load_strategy",
                                "type": "Expression"
                            }
                        }
                    },
                    {
                        "name": "Set_Parallel_Copies",
                        "type": "SetVariable",
                        "dependsOn": [
                            {
                                "activity": "Set_Strategy_From_Config",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "variableName": "ParallelCopies",
                            "value": {
                                "value": "@string(activity('Get_Table_Strategy').output.firstRow.parallel_copies)",
                                "type": "Expression"
                            }
                        }
                    },
                    {
                        "name": "Set_DIU",
                        "type": "SetVariable",
                        "dependsOn": [
                            {
                                "activity": "Set_Parallel_Copies",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "variableName": "DataIntegrationUnits",
                            "value": {
                                "value": "@string(activity('Get_Table_Strategy').output.firstRow.data_integration_units)",
                                "type": "Expression"
                            }
                        }
                    },
                    {
                        "name": "Set_Watermark_Column",
                        "type": "SetVariable",
                        "dependsOn": [
                            {
                                "activity": "Set_DIU",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "variableName": "WatermarkCol",
                            "value": {
                                "value": "@activity('Get_Table_Strategy').output.firstRow.watermark_column",
                                "type": "Expression"
                            }
                        }
                    },
                    {
                        "name": "No_tm_Tables",
                        "type": "IfCondition",
                        "dependsOn": [
                            {
                                "activity": "Check_Duplicates",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "userProperties": [],
                        "typeProperties": {
                            "expression": {
                                "value": "@not(equals(variables('WatermarkCol'), 'none'))",
                                "type": "Expression"
                            },
                            "ifTrueActivities": [
                                {
                                    "name": "Get_Max_Watermark",
                                    "type": "Lookup",
                                    "dependsOn": [],
                                    "policy": {
                                        "timeout": "0.12:00:00",
                                        "retry": 0,
                                        "retryIntervalInSeconds": 30,
                                        "secureOutput": false,
                                        "secureInput": false
                                    },
                                    "userProperties": [],
                                    "typeProperties": {
                                        "source": {
                                            "type": "PostgreSqlV2Source",
                                            "query": {
                                                "value": "@concat('SELECT MAX(', variables('WatermarkCol'), ')::timestamp as max_watermark FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName)\n",
                                                "type": "Expression"
                                            },
                                            "queryTimeout": "02:00:00"
                                        },
                                        "dataset": {
                                            "referenceName": "Canna_PostgreSQL_Collect_Tables",
                                            "type": "DatasetReference",
                                            "parameters": {
                                                "SchemaName": "collect",
                                                "TableName": "cc_customers"
                                            }
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    {
                        "name": "Update_tm_Tables",
                        "type": "IfCondition",
                        "dependsOn": [
                            {
                                "activity": "Log_Pipeline_Summary",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "userProperties": [],
                        "typeProperties": {
                            "expression": {
                                "value": "@not(equals(variables('WatermarkCol'), 'none'))",
                                "type": "Expression"
                            },
                            "ifTrueActivities": [
                                {
                                    "name": "Update_Watermark",
                                    "type": "Lookup",
                                    "dependsOn": [],
                                    "policy": {
                                        "timeout": "0.12:00:00",
                                        "retry": 0,
                                        "retryIntervalInSeconds": 30,
                                        "secureOutput": false,
                                        "secureInput": false
                                    },
                                    "userProperties": [],
                                    "typeProperties": {
                                        "source": {
                                            "type": "PostgreSqlV2Source",
                                            "query": {
                                                "value": "WITH update_result AS (\n     INSERT INTO collect.watermark_control (table_name, last_watermark, updated_at)\n     VALUES (\n       '@{pipeline().parameters.TableName}',\n       '@{activity('Get_Max_Watermark').output.firstRow.max_watermark}'::timestamp,\n       CURRENT_TIMESTAMP\n     )\n     ON CONFLICT (table_name) \n     DO UPDATE SET \n       last_watermark = EXCLUDED.last_watermark,\n       updated_at = CURRENT_TIMESTAMP\n     RETURNING table_name\n   )\n   SELECT COUNT(*) as rows_updated FROM update_result;",
                                                "type": "Expression"
                                            },
                                            "queryTimeout": "02:00:00"
                                        },
                                        "dataset": {
                                            "referenceName": "Canna_PostgreSQL_Collect_Tables",
                                            "type": "DatasetReference",
                                            "parameters": {
                                                "SchemaName": "collect",
                                                "TableName": "cc_customers"
                                            }
                                        }
                                    }
                                }
                            ]
                        }
                    }
                ],
                "policy": {
                    "elapsedTimeMetric": {}
                },
                "parameters": {
                    "SourceDatabase": {
                        "type": "string",
                        "defaultValue": "collect"
                    },
                    "SchemaName": {
                        "type": "string",
                        "defaultValue": "collect"
                    },
                    "TableName": {
                        "type": "string"
                    },
                    "WatermarkColumn": {
                        "type": "string",
                        "defaultValue": "tm"
                    },
                    "LastWatermark": {
                        "type": "string",
                        "defaultValue": "2000-01-01 00:00:00"
                    },
                    "RunDate": {
                        "type": "string"
                    }
                },
                "variables": {
                    "ValidationStatus": {
                        "type": "String"
                    },
                    "LoadStrategy": {
                        "type": "String",
                        "defaultValue": "INCREMENTAL"
                    },
                    "ParallelCopies": {
                        "type": "String",
                        "defaultValue": "8"
                    },
                    "DataIntegrationUnits": {
                        "type": "String",
                        "defaultValue": "16"
                    },
                    "WatermarkCol": {
                        "type": "String",
                        "defaultValue": "tm"
                    }
                },
                "folder": {
                    "name": "Archive"
                },
                "annotations": [],
                "lastPublishTime": "2025-09-18T14:21:00Z"
            },
            "dependsOn": [
                "[concat(variables('factoryId'), '/datasets/Canna_PostgreSQL_Collect_Tables')]",
                "[concat(variables('factoryId'), '/datasets/ADLS_JSON')]",
                "[concat(variables('factoryId'), '/linkedServices/Canna_Snowflake_Collect')]",
                "[concat(variables('factoryId'), '/datasets/Snowflake_Collect_Bronze')]",
                "[concat(variables('factoryId'), '/linkedServices/Canna_ADLS')]"
            ]
        },
        {
            "name": "[concat(parameters('factoryName'), '/Collect_Table_With_Validation__Incremental_JSON_V4_Test')]",
            "type": "Microsoft.DataFactory/factories/pipelines",
            "apiVersion": "2018-06-01",
            "properties": {
                "activities": [
                    {
                        "name": "Get_Source_Row_Count",
                        "description": "Get Postgres SQL table row count ",
                        "type": "Lookup",
                        "dependsOn": [
                            {
                                "activity": "Set_Watermark_Column",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "source": {
                                "type": "PostgreSqlV2Source",
                                "query": {
                                    "value": "@if(equals(variables('WatermarkCol'), 'none'),\n  concat('SELECT COUNT(*) as row_count FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName),\n  if(equals(variables('LoadStrategy'), 'ROLLING_30DAY'),\n    concat('SELECT COUNT(*) as row_count FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName, ' WHERE ', variables('WatermarkCol'), ' >= CURRENT_DATE - INTERVAL ''30 days'''),\n    if(equals(variables('LoadStrategy'), 'FULL_RELOAD'),\n      concat('SELECT COUNT(*) as row_count FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName),\n      concat('SELECT COUNT(*) as row_count FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName, ' WHERE ', variables('WatermarkCol'), ' > ''', pipeline().parameters.LastWatermark, '''')\n    )\n  )\n)",
                                    "type": "Expression"
                                },
                                "queryTimeout": "02:00:00"
                            },
                            "dataset": {
                                "referenceName": "Canna_PostgreSQL_Collect_Tables",
                                "type": "DatasetReference",
                                "parameters": {
                                    "SchemaName": "@pipeline().parameters.SchemaName",
                                    "TableName": "@pipeline().parameters.TableName"
                                }
                            }
                        }
                    },
                    {
                        "name": "Copy_To_ADLS",
                        "description": "Copy raw Postgres data into ADLS",
                        "type": "Copy",
                        "dependsOn": [
                            {
                                "activity": "No_tm_Tables",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "source": {
                                "type": "PostgreSqlV2Source",
                                "query": {
                                    "value": "@if(equals(variables('WatermarkCol'), 'none'),\n  concat('SELECT * FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName),\n  if(equals(variables('LoadStrategy'), 'ROLLING_30DAY'),\n    concat('SELECT * FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName, ' WHERE ', variables('WatermarkCol'), ' >= CURRENT_DATE - INTERVAL ''30 days'''),\n    if(equals(variables('LoadStrategy'), 'FULL_RELOAD'),\n      concat('SELECT * FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName),\n      concat('SELECT * FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName, ' WHERE ', variables('WatermarkCol'), ' > ''', pipeline().parameters.LastWatermark, '''')\n    )\n  )\n)",
                                    "type": "Expression"
                                },
                                "queryTimeout": "02:00:00"
                            },
                            "sink": {
                                "type": "JsonSink",
                                "storeSettings": {
                                    "type": "AzureBlobFSWriteSettings"
                                },
                                "formatSettings": {
                                    "type": "JsonWriteSettings"
                                }
                            },
                            "enableStaging": false,
                            "parallelCopies": {
                                "value": "@int(variables('ParallelCopies'))",
                                "type": "Expression"
                            },
                            "enableSkipIncompatibleRow": false,
                            "validateDataConsistency": true,
                            "logSettings": {
                                "enableCopyActivityLog": true,
                                "copyActivityLogSettings": {
                                    "logLevel": "Info",
                                    "enableReliableLogging": false
                                },
                                "logLocationSettings": {
                                    "linkedServiceName": {
                                        "referenceName": "Canna_ADLS",
                                        "type": "LinkedServiceReference"
                                    },
                                    "path": "logs/copy-activity"
                                }
                            },
                            "dataIntegrationUnits": {
                                "value": "@int(variables('DataIntegrationUnits'))",
                                "type": "Expression"
                            }
                        },
                        "inputs": [
                            {
                                "referenceName": "Canna_PostgreSQL_Collect_Tables",
                                "type": "DatasetReference",
                                "parameters": {
                                    "SchemaName": "@pipeline().parameters.SchemaName",
                                    "TableName": "@pipeline().parameters.TableName"
                                }
                            }
                        ],
                        "outputs": [
                            {
                                "referenceName": "ADLS_JSON",
                                "type": "DatasetReference",
                                "parameters": {
                                    "Container": "raw",
                                    "Directory": {
                                        "value": "@concat(\n  pipeline().parameters.SourceDatabase, '/',\n  pipeline().parameters.TableName, '/',\n  pipeline().parameters.RunDate, '/',\n  pipeline().RunId         \n)\n",
                                        "type": "Expression"
                                    },
                                    "FileName": {
                                        "value": "@concat(pipeline().parameters.SchemaName, '_', pipeline().parameters.TableName, '_', formatDateTime(utcNow(), 'yyyyMMdd_HHmmss'), '_', variables('LoadStrategy'), '.json')",
                                        "type": "Expression"
                                    }
                                }
                            }
                        ]
                    },
                    {
                        "name": "Validate_ADLS_File",
                        "description": "Verify the JSON file was created successfully in ADLS",
                        "type": "GetMetadata",
                        "dependsOn": [
                            {
                                "activity": "Copy_To_ADLS",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "dataset": {
                                "referenceName": "ADLS_JSON",
                                "type": "DatasetReference",
                                "parameters": {
                                    "Container": "raw",
                                    "Directory": "@concat(pipeline().parameters.SourceDatabase, '/', formatDateTime(utcnow(), 'yyyy-MM-dd'))",
                                    "FileName": "@concat(pipeline().parameters.SchemaName, '_', pipeline().parameters.TableName, '_', formatDateTime(utcnow(), 'yyyyMMddHHmmss'), '.json')"
                                }
                            },
                            "fieldList": [
                                "exists",
                                "childItems"
                            ],
                            "storeSettings": {
                                "type": "AzureBlobFSReadSettings",
                                "recursive": true,
                                "enablePartitionDiscovery": false
                            },
                            "formatSettings": {
                                "type": "JsonReadSettings"
                            }
                        }
                    },
                    {
                        "name": "Load_To_Snowflake_Bronze",
                        "description": "Load ADLS data into Snowflake Bronze layer",
                        "type": "Script",
                        "dependsOn": [
                            {
                                "activity": "Delete_30_Day_Data",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "linkedServiceName": {
                            "referenceName": "Canna_Snowflake_Collect",
                            "type": "LinkedServiceReference"
                        },
                        "typeProperties": {
                            "scripts": [
                                {
                                    "type": "Query",
                                    "text": {
                                        "value": "@concat(\n  'ALTER SESSION SET TIMEZONE = ''UTC''; ',\n  'USE SCHEMA BRONZE; ',\n\n  'CREATE TABLE IF NOT EXISTS ', \n  if(endsWith(pipeline().parameters.TableName, '_t'), replace(pipeline().parameters.TableName, '_t', ''), pipeline().parameters.TableName), ' (',\n  '  data VARIANT,',\n  '  load_timestamp TIMESTAMP_NTZ DEFAULT CURRENT_TIMESTAMP()',\n  ');',\n\n  'COPY INTO ', \n  if(endsWith(pipeline().parameters.TableName, '_t'), replace(pipeline().parameters.TableName, '_t', ''), pipeline().parameters.TableName), ' (data) ',\n  'FROM @SOURCE_DB.BRONZE.ADLS_RAW_STAGE/',\n      pipeline().parameters.SourceDatabase, '/', pipeline().parameters.TableName, '/',\n      pipeline().parameters.RunDate, '/', pipeline().RunId, '/ ',\n  'PATTERN = ''', '.*', variables('LoadStrategy'), '.*', ''' ',\n  'FILE_FORMAT = (TYPE = JSON) ',\n  'FORCE = ', if(equals(variables('LoadStrategy'), 'FULL_RELOAD'), 'TRUE', 'FALSE'), ' ',\n  'ON_ERROR = ''CONTINUE'';',\n\n  'GRANT SELECT ON TABLE ', \n  if(endsWith(pipeline().parameters.TableName, '_t'), replace(pipeline().parameters.TableName, '_t', ''), pipeline().parameters.TableName), \n  ' TO ROLE SYSADMIN;',\n\n  'SELECT COUNT(*) AS rows_loaded, ''', variables('LoadStrategy'), ''' AS strategy_used ',\n  'FROM ', \n  if(endsWith(pipeline().parameters.TableName, '_t'), replace(pipeline().parameters.TableName, '_t', ''), pipeline().parameters.TableName), \n  ' WHERE data IS NOT NULL;'\n)",
                                        "type": "Expression"
                                    }
                                }
                            ],
                            "scriptBlockExecutionTimeout": "02:00:00"
                        }
                    },
                    {
                        "name": "Get_Snowflake_Row_Count",
                        "description": "Get loaded row count from Snowflake Bronze table",
                        "type": "Lookup",
                        "dependsOn": [
                            {
                                "activity": "Load_To_Snowflake_Bronze",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "source": {
                                "type": "SnowflakeV2Source",
                                "query": {
                                    "value": "SELECT COUNT(*) as snowflake_count \nFROM SOURCE_DB.BRONZE.@{if(endsWith(pipeline().parameters.TableName, '_t'), replace(pipeline().parameters.TableName, '_t', ''), pipeline().parameters.TableName)};",
                                    "type": "Expression"
                                },
                                "exportSettings": {
                                    "type": "SnowflakeExportCopyCommand"
                                }
                            },
                            "dataset": {
                                "referenceName": "Snowflake_Collect_Bronze",
                                "type": "DatasetReference",
                                "parameters": {}
                            }
                        }
                    },
                    {
                        "name": "Validate_Row_Count_Match",
                        "description": "Compare Postgres vs Snowflake row counts",
                        "type": "IfCondition",
                        "dependsOn": [
                            {
                                "activity": "Get_Snowflake_Row_Count",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "userProperties": [],
                        "typeProperties": {
                            "expression": {
                                "value": "@equals(string(activity('Get_Source_Row_Count').output.firstRow.row_count), string(activity('Get_Snowflake_Row_Count').output.firstRow.SNOWFLAKE_COUNT))",
                                "type": "Expression"
                            },
                            "ifFalseActivities": [
                                {
                                    "name": "Set_Validation_Error",
                                    "description": "Mark validation as failed due to row count mismatch",
                                    "type": "SetVariable",
                                    "dependsOn": [],
                                    "policy": {
                                        "secureOutput": false,
                                        "secureInput": false
                                    },
                                    "userProperties": [],
                                    "typeProperties": {
                                        "variableName": "ValidationStatus",
                                        "value": "ROW_COUNT_MISMATCH"
                                    }
                                }
                            ],
                            "ifTrueActivities": [
                                {
                                    "name": "Set_Validation_Status",
                                    "description": "Mark validation as successful",
                                    "type": "SetVariable",
                                    "dependsOn": [],
                                    "policy": {
                                        "secureOutput": false,
                                        "secureInput": false
                                    },
                                    "userProperties": [],
                                    "typeProperties": {
                                        "variableName": "ValidationStatus",
                                        "value": "SUCCESS"
                                    }
                                }
                            ]
                        }
                    },
                    {
                        "name": "Check_Null_Values",
                        "description": "Count null values in key columns",
                        "type": "Lookup",
                        "dependsOn": [
                            {
                                "activity": "Load_To_Snowflake_Bronze",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "source": {
                                "type": "SnowflakeV2Source",
                                "query": {
                                    "value": "SELECT \n    SUM(CASE WHEN data:id IS NULL THEN 1 ELSE 0 END) as null_ids,\n    SUM(CASE WHEN data:name IS NULL THEN 1 ELSE 0 END) as null_names\nFROM SOURCE_DB.BRONZE.@{if(endsWith(pipeline().parameters.TableName, '_t'), replace(pipeline().parameters.TableName, '_t', ''), pipeline().parameters.TableName)}",
                                    "type": "Expression"
                                },
                                "exportSettings": {
                                    "type": "SnowflakeExportCopyCommand"
                                }
                            },
                            "dataset": {
                                "referenceName": "Snowflake_Collect_Bronze",
                                "type": "DatasetReference",
                                "parameters": {}
                            }
                        }
                    },
                    {
                        "name": "Log_Pipeline_Summary",
                        "description": "Insert execution summary into UTILITY.PIPELINE_EXECUTION_LOG",
                        "type": "Script",
                        "dependsOn": [
                            {
                                "activity": "Validate_Row_Count_Match",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            },
                            {
                                "activity": "Check_Null_Values",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "linkedServiceName": {
                            "referenceName": "Canna_Snowflake_Collect",
                            "type": "LinkedServiceReference"
                        },
                        "typeProperties": {
                            "scripts": [
                                {
                                    "type": "Query",
                                    "text": {
                                        "value": "@concat(\n  'INSERT INTO SOURCE_DB.UTILITY.PIPELINE_EXECUTION_LOG VALUES (''',\n  pipeline().RunId, ''', ''',\n  pipeline().parameters.TableName, ''', ''',\n  formatDateTime(utcnow(), 'yyyy-MM-dd'), ''', ''',\n  utcnow(), ''', ',\n  if(empty(string(activity('Get_Source_Row_Count').output.firstRow.row_count)), '0', string(activity('Get_Source_Row_Count').output.firstRow.row_count)), ', ',\n  if(empty(string(activity('Get_Snowflake_Row_Count').output.firstRow.SNOWFLAKE_COUNT)), '0', string(activity('Get_Snowflake_Row_Count').output.firstRow.SNOWFLAKE_COUNT)), ', ',\n  if(equals(variables('ValidationStatus'), 'SUCCESS'), 'TRUE', 'FALSE'), ', ',\n  if(empty(string(activity('Check_Duplicates').output.firstRow.duplicate_count)), '0', string(activity('Check_Duplicates').output.firstRow.duplicate_count)), ', ',\n  if(empty(string(activity('Check_Null_Values').output.firstRow.NULL_IDS)), '0', string(activity('Check_Null_Values').output.firstRow.NULL_IDS)), ', ',\n  if(empty(string(activity('Check_Null_Values').output.firstRow.NULL_NAMES)), '0', string(activity('Check_Null_Values').output.firstRow.NULL_NAMES)), ', ''',\n  variables('ValidationStatus'), ''', ',\n  '0', \n  ');'\n)",
                                        "type": "Expression"
                                    }
                                }
                            ],
                            "scriptBlockExecutionTimeout": "02:00:00"
                        }
                    },
                    {
                        "name": "Check_Duplicates",
                        "description": "Check for duplicate rows in the table",
                        "type": "Lookup",
                        "dependsOn": [
                            {
                                "activity": "Get_Source_Row_Count",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "source": {
                                "type": "PostgreSqlV2Source",
                                "query": {
                                    "value": "@if(equals(variables('LoadStrategy'), 'ROLLING_30DAY'),\n  concat('SELECT (SELECT COUNT(*) FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName, ' WHERE ', variables('WatermarkCol'), ' >= CURRENT_DATE - INTERVAL ''30 days'') - (SELECT COUNT(*) FROM (SELECT DISTINCT * FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName, ' WHERE ', variables('WatermarkCol'), ' >= CURRENT_DATE - INTERVAL ''30 days'') t) as duplicate_count'),\n  concat('SELECT (SELECT COUNT(*) FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName, ') - (SELECT COUNT(*) FROM (SELECT DISTINCT * FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName, ') t) as duplicate_count')\n)",
                                    "type": "Expression"
                                },
                                "queryTimeout": "02:00:00"
                            },
                            "dataset": {
                                "referenceName": "Canna_PostgreSQL_Collect_Tables",
                                "type": "DatasetReference",
                                "parameters": {
                                    "SchemaName": "@pipeline().parameters.SchemaName",
                                    "TableName": "@pipeline().parameters.TableName"
                                }
                            }
                        }
                    },
                    {
                        "name": "Delete_30_Day_Data",
                        "type": "Script",
                        "dependsOn": [
                            {
                                "activity": "Validate_ADLS_File",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "linkedServiceName": {
                            "referenceName": "Canna_Snowflake_Collect",
                            "type": "LinkedServiceReference"
                        },
                        "typeProperties": {
                            "scripts": [
                                {
                                    "type": "Query",
                                    "text": {
                                        "value": "@concat(\n  'USE SCHEMA BRONZE; ',\n  'CREATE TABLE IF NOT EXISTS ', \n  if(endsWith(pipeline().parameters.TableName, '_t'), replace(pipeline().parameters.TableName, '_t', ''), pipeline().parameters.TableName), \n  ' (data VARIANT); ',\n  'ALTER SESSION SET TIMEZONE = ''UTC''; ',\n  if(equals(variables('LoadStrategy'), 'ROLLING_30DAY'),\n    concat('DELETE FROM ', \n      if(endsWith(pipeline().parameters.TableName, '_t'), replace(pipeline().parameters.TableName, '_t', ''), pipeline().parameters.TableName), \n      ' WHERE TO_DATE(CONVERT_TIMEZONE(''UTC'', TRY_TO_TIMESTAMP_TZ(data:\"', variables('WatermarkCol'), '\"::string))) >= DATEADD(day, -30, CURRENT_DATE()); '),\n    if(equals(variables('LoadStrategy'), 'FULL_RELOAD'),\n      concat('TRUNCATE TABLE ', \n        if(endsWith(pipeline().parameters.TableName, '_t'), replace(pipeline().parameters.TableName, '_t', ''), pipeline().parameters.TableName), \n        '; '),\n      'SELECT ''No cleanup needed for incremental strategy'' as status; '\n    )\n  ),\n  'SELECT ''', variables('LoadStrategy'), ''' as strategy_applied;'\n)",
                                        "type": "Expression"
                                    }
                                }
                            ],
                            "scriptBlockExecutionTimeout": "02:00:00"
                        }
                    },
                    {
                        "name": "Get_Table_Strategy",
                        "type": "Lookup",
                        "dependsOn": [],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "source": {
                                "type": "SnowflakeV2Source",
                                "query": {
                                    "value": "SELECT \n       COALESCE(load_strategy, 'INCREMENTAL') as load_strategy,\n       COALESCE(parallel_copies, 8) as parallel_copies,\n       COALESCE(data_integration_units, 16) as data_integration_units,\n       COALESCE(watermark_column, 'tm') as watermark_column\n   FROM SOURCE_DB.UTILITY.TABLE_STRATEGY_CONFIG \n   WHERE table_name = '@{pipeline().parameters.TableName}'\n   AND is_active = TRUE",
                                    "type": "Expression"
                                },
                                "exportSettings": {
                                    "type": "SnowflakeExportCopyCommand"
                                }
                            },
                            "dataset": {
                                "referenceName": "Snowflake_Collect_Bronze",
                                "type": "DatasetReference",
                                "parameters": {}
                            }
                        }
                    },
                    {
                        "name": "Set_Strategy_From_Config",
                        "type": "SetVariable",
                        "dependsOn": [
                            {
                                "activity": "Get_Table_Strategy",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "variableName": "LoadStrategy",
                            "value": {
                                "value": "@activity('Get_Table_Strategy').output.firstRow.load_strategy",
                                "type": "Expression"
                            }
                        }
                    },
                    {
                        "name": "Set_Parallel_Copies",
                        "type": "SetVariable",
                        "dependsOn": [
                            {
                                "activity": "Set_Strategy_From_Config",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "variableName": "ParallelCopies",
                            "value": {
                                "value": "@string(activity('Get_Table_Strategy').output.firstRow.parallel_copies)",
                                "type": "Expression"
                            }
                        }
                    },
                    {
                        "name": "Set_DIU",
                        "type": "SetVariable",
                        "dependsOn": [
                            {
                                "activity": "Set_Parallel_Copies",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "variableName": "DataIntegrationUnits",
                            "value": {
                                "value": "@string(activity('Get_Table_Strategy').output.firstRow.data_integration_units)",
                                "type": "Expression"
                            }
                        }
                    },
                    {
                        "name": "Set_Watermark_Column",
                        "type": "SetVariable",
                        "dependsOn": [
                            {
                                "activity": "Set_DIU",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "variableName": "WatermarkCol",
                            "value": {
                                "value": "@activity('Get_Table_Strategy').output.firstRow.watermark_column",
                                "type": "Expression"
                            }
                        }
                    },
                    {
                        "name": "No_tm_Tables",
                        "type": "IfCondition",
                        "dependsOn": [
                            {
                                "activity": "Check_Duplicates",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "userProperties": [],
                        "typeProperties": {
                            "expression": {
                                "value": "@not(equals(variables('WatermarkCol'), 'none'))",
                                "type": "Expression"
                            },
                            "ifTrueActivities": [
                                {
                                    "name": "Get_Max_Watermark",
                                    "type": "Lookup",
                                    "dependsOn": [],
                                    "policy": {
                                        "timeout": "0.12:00:00",
                                        "retry": 0,
                                        "retryIntervalInSeconds": 30,
                                        "secureOutput": false,
                                        "secureInput": false
                                    },
                                    "userProperties": [],
                                    "typeProperties": {
                                        "source": {
                                            "type": "PostgreSqlV2Source",
                                            "query": {
                                                "value": "@concat('SELECT MAX(', variables('WatermarkCol'), ')::timestamp as max_watermark FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName)\n",
                                                "type": "Expression"
                                            },
                                            "queryTimeout": "02:00:00"
                                        },
                                        "dataset": {
                                            "referenceName": "Canna_PostgreSQL_Collect_Tables",
                                            "type": "DatasetReference",
                                            "parameters": {
                                                "SchemaName": "collect",
                                                "TableName": "cc_customers"
                                            }
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    {
                        "name": "Update_tm_Tables",
                        "type": "IfCondition",
                        "dependsOn": [
                            {
                                "activity": "Log_Pipeline_Summary",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "userProperties": [],
                        "typeProperties": {
                            "expression": {
                                "value": "@not(equals(variables('WatermarkCol'), 'none'))",
                                "type": "Expression"
                            },
                            "ifTrueActivities": [
                                {
                                    "name": "Update_Watermark",
                                    "type": "Lookup",
                                    "dependsOn": [],
                                    "policy": {
                                        "timeout": "0.12:00:00",
                                        "retry": 0,
                                        "retryIntervalInSeconds": 30,
                                        "secureOutput": false,
                                        "secureInput": false
                                    },
                                    "userProperties": [],
                                    "typeProperties": {
                                        "source": {
                                            "type": "PostgreSqlV2Source",
                                            "query": {
                                                "value": "WITH update_result AS (\n     INSERT INTO collect.watermark_control (table_name, last_watermark, updated_at)\n     VALUES (\n       '@{pipeline().parameters.TableName}',\n       '@{activity('Get_Max_Watermark').output.firstRow.max_watermark}'::timestamp,\n       CURRENT_TIMESTAMP\n     )\n     ON CONFLICT (table_name) \n     DO UPDATE SET \n       last_watermark = EXCLUDED.last_watermark,\n       updated_at = CURRENT_TIMESTAMP\n     RETURNING table_name\n   )\n   SELECT COUNT(*) as rows_updated FROM update_result;",
                                                "type": "Expression"
                                            },
                                            "queryTimeout": "02:00:00"
                                        },
                                        "dataset": {
                                            "referenceName": "Canna_PostgreSQL_Collect_Tables",
                                            "type": "DatasetReference",
                                            "parameters": {
                                                "SchemaName": "collect",
                                                "TableName": "cc_customers"
                                            }
                                        }
                                    }
                                }
                            ]
                        }
                    }
                ],
                "policy": {
                    "elapsedTimeMetric": {}
                },
                "parameters": {
                    "SourceDatabase": {
                        "type": "string",
                        "defaultValue": "collect"
                    },
                    "SchemaName": {
                        "type": "string",
                        "defaultValue": "collect"
                    },
                    "TableName": {
                        "type": "string"
                    },
                    "WatermarkColumn": {
                        "type": "string",
                        "defaultValue": "tm"
                    },
                    "LastWatermark": {
                        "type": "string",
                        "defaultValue": "2000-01-01 00:00:00"
                    },
                    "RunDate": {
                        "type": "string"
                    }
                },
                "variables": {
                    "ValidationStatus": {
                        "type": "String"
                    },
                    "LoadStrategy": {
                        "type": "String",
                        "defaultValue": "INCREMENTAL"
                    },
                    "ParallelCopies": {
                        "type": "String",
                        "defaultValue": "8"
                    },
                    "DataIntegrationUnits": {
                        "type": "String",
                        "defaultValue": "16"
                    },
                    "WatermarkCol": {
                        "type": "String",
                        "defaultValue": "tm"
                    }
                },
                "folder": {
                    "name": "Archive"
                },
                "annotations": [],
                "lastPublishTime": "2025-09-18T14:21:00Z"
            },
            "dependsOn": [
                "[concat(variables('factoryId'), '/datasets/Canna_PostgreSQL_Collect_Tables')]",
                "[concat(variables('factoryId'), '/datasets/ADLS_JSON')]",
                "[concat(variables('factoryId'), '/linkedServices/Canna_Snowflake_Collect')]",
                "[concat(variables('factoryId'), '/datasets/Snowflake_Collect_Bronze')]",
                "[concat(variables('factoryId'), '/linkedServices/Canna_ADLS')]"
            ]
        },
        {
            "name": "[concat(parameters('factoryName'), '/Copy_Table_With_Validation_Parquet')]",
            "type": "Microsoft.DataFactory/factories/pipelines",
            "apiVersion": "2018-06-01",
            "properties": {
                "activities": [
                    {
                        "name": "Get_Source_Row_Count",
                        "description": "Get Postgres SQL row count ",
                        "type": "Lookup",
                        "dependsOn": [],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "source": {
                                "type": "PostgreSqlV2Source",
                                "query": {
                                    "value": "@concat('SELECT COUNT(*) as row_count FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName)",
                                    "type": "Expression"
                                },
                                "queryTimeout": "02:00:00"
                            },
                            "dataset": {
                                "referenceName": "Canna_PostgreSQL_Collect_Tables",
                                "type": "DatasetReference",
                                "parameters": {
                                    "SchemaName": "@pipeline().parameters.SchemaName",
                                    "TableName": "@pipeline().parameters.TableName"
                                }
                            }
                        }
                    },
                    {
                        "name": "Check_Duplicates",
                        "type": "Lookup",
                        "dependsOn": [
                            {
                                "activity": "Get_Source_Row_Count",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "source": {
                                "type": "PostgreSqlV2Source",
                                "query": {
                                    "value": "@concat('SELECT (SELECT COUNT(*) FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName, ') - (SELECT COUNT(*) FROM (SELECT DISTINCT * FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName, ') t) as duplicate_count')",
                                    "type": "Expression"
                                },
                                "queryTimeout": "02:00:00"
                            },
                            "dataset": {
                                "referenceName": "Canna_PostgreSQL_Collect_Tables",
                                "type": "DatasetReference",
                                "parameters": {
                                    "SchemaName": "@pipeline().parameters.SchemaName",
                                    "TableName": "@pipeline().parameters.TableName"
                                }
                            }
                        }
                    },
                    {
                        "name": "Copy_To_ADLS",
                        "description": "Copy raw  Postgres data into ADLS",
                        "type": "Copy",
                        "dependsOn": [
                            {
                                "activity": "Check_Duplicates",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "source": {
                                "type": "PostgreSqlV2Source",
                                "queryTimeout": "02:00:00"
                            },
                            "sink": {
                                "type": "ParquetSink",
                                "storeSettings": {
                                    "type": "AzureBlobFSWriteSettings"
                                },
                                "formatSettings": {
                                    "type": "ParquetWriteSettings"
                                }
                            },
                            "enableStaging": false,
                            "enableSkipIncompatibleRow": true,
                            "validateDataConsistency": true,
                            "logSettings": {
                                "enableCopyActivityLog": true,
                                "copyActivityLogSettings": {
                                    "logLevel": "Info",
                                    "enableReliableLogging": false
                                },
                                "logLocationSettings": {
                                    "linkedServiceName": {
                                        "referenceName": "Canna_ADLS",
                                        "type": "LinkedServiceReference"
                                    },
                                    "path": "logs/copy-activity"
                                }
                            },
                            "translator": {
                                "type": "TabularTranslator",
                                "typeConversion": true,
                                "typeConversionSettings": {
                                    "allowDataTruncation": true,
                                    "treatBooleanAsNumber": false
                                }
                            }
                        },
                        "inputs": [
                            {
                                "referenceName": "Canna_PostgreSQL_Collect_Tables",
                                "type": "DatasetReference",
                                "parameters": {
                                    "SchemaName": "@pipeline().parameters.SchemaName",
                                    "TableName": "@pipeline().parameters.TableName"
                                }
                            }
                        ],
                        "outputs": [
                            {
                                "referenceName": "ADLS_Parquet",
                                "type": "DatasetReference",
                                "parameters": {
                                    "Container": "raw",
                                    "Directory": "@concat(pipeline().parameters.SourceDatabase, '/', formatDateTime(utcnow(),'yyyy-MM-dd'))",
                                    "FileName": "@concat(pipeline().parameters.SchemaName, '_', pipeline().parameters.TableName, '_', formatDateTime(utcnow(), 'yyyyMMddHHmmss'), '.parquet')"
                                }
                            }
                        ]
                    }
                ],
                "policy": {
                    "elapsedTimeMetric": {}
                },
                "parameters": {
                    "SourceDatabase": {
                        "type": "string",
                        "defaultValue": "collect"
                    },
                    "SchemaName": {
                        "type": "string"
                    },
                    "TableName": {
                        "type": "string"
                    }
                },
                "folder": {
                    "name": "Archive"
                },
                "annotations": [],
                "lastPublishTime": "2025-09-17T15:46:33Z"
            },
            "dependsOn": [
                "[concat(variables('factoryId'), '/datasets/Canna_PostgreSQL_Collect_Tables')]",
                "[concat(variables('factoryId'), '/datasets/ADLS_Parquet')]",
                "[concat(variables('factoryId'), '/linkedServices/Canna_ADLS')]"
            ]
        },
        {
            "name": "[concat(parameters('factoryName'), '/Rpt_Pipeline_JSON')]",
            "type": "Microsoft.DataFactory/factories/pipelines",
            "apiVersion": "2018-06-01",
            "properties": {
                "activities": [
                    {
                        "name": "Set_Pipeline_Start_Time",
                        "description": "Set the start time of when the pipeline runs",
                        "type": "SetVariable",
                        "dependsOn": [],
                        "policy": {
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "variableName": "PipelineStartTime",
                            "value": {
                                "value": "@utcnow()",
                                "type": "Expression"
                            }
                        }
                    },
                    {
                        "name": "Get_Rpt_Tables",
                        "description": "Get all tables in rpt database",
                        "type": "Lookup",
                        "dependsOn": [
                            {
                                "activity": "Set_Pipeline_Start_Time",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "source": {
                                "type": "PostgreSqlV2Source",
                                "query": "SELECT \n    schemaname,\n    tablename\nFROM pg_tables \nWHERE schemaname = 'rpt'\n    AND tablename LIKE 'cc_%'\nORDER BY tablename;",
                                "queryTimeout": "02:00:00"
                            },
                            "dataset": {
                                "referenceName": "Canna_PostgreSQL_Rpt_Tables",
                                "type": "DatasetReference",
                                "parameters": {
                                    "SchemaName": "@pipeline().parameters.SchemaName",
                                    "TableName": "@pipeline().parameters.TableName"
                                }
                            },
                            "firstRowOnly": false
                        }
                    },
                    {
                        "name": "ForEach_Rpt_Table",
                        "description": "Processes individual tables with full validation pipeline",
                        "type": "ForEach",
                        "dependsOn": [
                            {
                                "activity": "Get_Rpt_Tables",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "userProperties": [],
                        "typeProperties": {
                            "items": {
                                "value": "@activity('Get_Rpt_Tables').output.value",
                                "type": "Expression"
                            },
                            "isSequential": false,
                            "batchCount": 1,
                            "activities": [
                                {
                                    "name": "Execute_Table_Validation_Pipeline",
                                    "type": "ExecutePipeline",
                                    "dependsOn": [],
                                    "policy": {
                                        "secureInput": false
                                    },
                                    "userProperties": [],
                                    "typeProperties": {
                                        "pipeline": {
                                            "referenceName": "Rpt_Table_With_Validation_JSON",
                                            "type": "PipelineReference"
                                        },
                                        "waitOnCompletion": true,
                                        "parameters": {
                                            "SourceDatabase": "rpt",
                                            "SchemaName": {
                                                "value": "@item().schemaname",
                                                "type": "Expression"
                                            },
                                            "TableName": {
                                                "value": "@item().tablename",
                                                "type": "Expression"
                                            }
                                        }
                                    }
                                }
                            ]
                        }
                    }
                ],
                "policy": {
                    "elapsedTimeMetric": {}
                },
                "parameters": {
                    "SchemaName": {
                        "type": "string"
                    },
                    "TableName": {
                        "type": "string"
                    }
                },
                "variables": {
                    "PipelineStartTime": {
                        "type": "String"
                    },
                    "ValidationErrors": {
                        "type": "String"
                    },
                    "ProcessedTables": {
                        "type": "String"
                    }
                },
                "annotations": [],
                "lastPublishTime": "2025-09-18T14:27:22Z"
            },
            "dependsOn": [
                "[concat(variables('factoryId'), '/datasets/Canna_PostgreSQL_Rpt_Tables')]",
                "[concat(variables('factoryId'), '/pipelines/Rpt_Table_With_Validation_JSON')]"
            ]
        },
        {
            "name": "[concat(parameters('factoryName'), '/Rpt_Table_With_Validation_JSON')]",
            "type": "Microsoft.DataFactory/factories/pipelines",
            "apiVersion": "2018-06-01",
            "properties": {
                "activities": [
                    {
                        "name": "Get_Source_Row_Count",
                        "description": "Get Postgres SQL table row count ",
                        "type": "Lookup",
                        "dependsOn": [],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "source": {
                                "type": "PostgreSqlV2Source",
                                "query": {
                                    "value": "@concat('SELECT COUNT(*) as row_count FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName)",
                                    "type": "Expression"
                                },
                                "queryTimeout": "02:00:00"
                            },
                            "dataset": {
                                "referenceName": "Canna_PostgreSQL_Rpt_Tables",
                                "type": "DatasetReference",
                                "parameters": {
                                    "SchemaName": "@pipeline().parameters.SchemaName",
                                    "TableName": "@pipeline().parameters.TableName"
                                }
                            }
                        }
                    },
                    {
                        "name": "Check_Duplicates",
                        "description": "Check for duplicate rows in the table",
                        "type": "Lookup",
                        "dependsOn": [
                            {
                                "activity": "Get_Source_Row_Count",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "source": {
                                "type": "PostgreSqlV2Source",
                                "query": {
                                    "value": "@concat('SELECT (SELECT COUNT(*) FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName, ') - (SELECT COUNT(*) FROM (SELECT DISTINCT * FROM ', pipeline().parameters.SchemaName, '.', pipeline().parameters.TableName, ') t) as duplicate_count')",
                                    "type": "Expression"
                                },
                                "queryTimeout": "02:00:00"
                            },
                            "dataset": {
                                "referenceName": "Canna_PostgreSQL_Rpt_Tables",
                                "type": "DatasetReference",
                                "parameters": {
                                    "SchemaName": "@pipeline().parameters.SchemaName",
                                    "TableName": "@pipeline().parameters.TableName"
                                }
                            }
                        }
                    },
                    {
                        "name": "Validate_ADLS_File",
                        "description": "Verify the JSON file was created successfully in ADLS",
                        "type": "GetMetadata",
                        "dependsOn": [
                            {
                                "activity": "Copy_To_ADLS",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "dataset": {
                                "referenceName": "ADLS_JSON",
                                "type": "DatasetReference",
                                "parameters": {
                                    "Container": "raw",
                                    "Directory": "@concat(pipeline().parameters.SourceDatabase, '/', formatDateTime(utcnow(), 'yyyy-MM-dd'))",
                                    "FileName": "@concat(pipeline().parameters.SchemaName, '_', pipeline().parameters.TableName, '_', formatDateTime(utcnow(), 'yyyyMMddHHmmss'), '.json')"
                                }
                            },
                            "fieldList": [
                                "exists",
                                "childItems"
                            ],
                            "storeSettings": {
                                "type": "AzureBlobFSReadSettings",
                                "recursive": true,
                                "enablePartitionDiscovery": false
                            },
                            "formatSettings": {
                                "type": "JsonReadSettings"
                            }
                        }
                    },
                    {
                        "name": "Load_To_Snowflake_Bronze",
                        "description": "Load ADLS data into Snowflake Bronze layer",
                        "type": "Script",
                        "dependsOn": [
                            {
                                "activity": "Validate_ADLS_File",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "linkedServiceName": {
                            "referenceName": "Canna_Snowflake_Rpt",
                            "type": "LinkedServiceReference"
                        },
                        "typeProperties": {
                            "scripts": [
                                {
                                    "type": "Query",
                                    "text": {
                                        "value": "USE SCHEMA BRONZE;\n\nCREATE OR REPLACE TABLE @{pipeline().parameters.SchemaName}_@{pipeline().parameters.TableName} (data VARIANT);\n\nCOPY INTO @{pipeline().parameters.SchemaName}_@{pipeline().parameters.TableName}\nFROM @CANNACOLLECTIVE_RPT.BRONZE.ADLS_RAW_STAGE/@{pipeline().parameters.SourceDatabase}/@{pipeline().parameters.TableName}/@{formatDateTime(utcnow(), 'yyyy-MM-dd')}/@{pipeline().parameters.SchemaName}_@{pipeline().parameters.TableName}_latest.json\nFILE_FORMAT = (TYPE = 'JSON');\n\nGRANT SELECT ON TABLE @{pipeline().parameters.SchemaName}_@{pipeline().parameters.TableName} TO ROLE SYSADMIN;\n\nSELECT COUNT(*) as rows_loaded FROM @{pipeline().parameters.SchemaName}_@{pipeline().parameters.TableName};",
                                        "type": "Expression"
                                    }
                                }
                            ],
                            "scriptBlockExecutionTimeout": "02:00:00"
                        }
                    },
                    {
                        "name": "Get_Snowflake_Row_Count",
                        "description": "Get loaded row count from Snowflake Bronze table",
                        "type": "Lookup",
                        "dependsOn": [
                            {
                                "activity": "Load_To_Snowflake_Bronze",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "source": {
                                "type": "SnowflakeV2Source",
                                "query": {
                                    "value": "SELECT COUNT(*) as snowflake_count FROM CANNACOLLECTIVE_RPT.BRONZE.@{pipeline().parameters.SchemaName}_@{pipeline().parameters.TableName};",
                                    "type": "Expression"
                                },
                                "exportSettings": {
                                    "type": "SnowflakeExportCopyCommand"
                                }
                            },
                            "dataset": {
                                "referenceName": "Snowflake_Rpt_Bronze",
                                "type": "DatasetReference",
                                "parameters": {}
                            }
                        }
                    },
                    {
                        "name": "Validate_Row_Count_Match",
                        "description": "Compare Postgres vs Snowflake row counts",
                        "type": "IfCondition",
                        "dependsOn": [
                            {
                                "activity": "Get_Snowflake_Row_Count",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "userProperties": [],
                        "typeProperties": {
                            "expression": {
                                "value": "@equals(activity('Get_Source_Row_Count').output.firstRow.row_count, int(activity('Get_Snowflake_Row_Count').output.firstRow.SNOWFLAKE_COUNT))",
                                "type": "Expression"
                            },
                            "ifFalseActivities": [
                                {
                                    "name": "Set_Validation_Error",
                                    "description": "Mark validation as failed due to row count mismatch",
                                    "type": "SetVariable",
                                    "dependsOn": [],
                                    "policy": {
                                        "secureOutput": false,
                                        "secureInput": false
                                    },
                                    "userProperties": [],
                                    "typeProperties": {
                                        "variableName": "ValidationStatus",
                                        "value": "ROW_COUNT_MISMATCH"
                                    }
                                }
                            ],
                            "ifTrueActivities": [
                                {
                                    "name": "Set_Validation_Status",
                                    "description": "Mark validation as successful",
                                    "type": "SetVariable",
                                    "dependsOn": [],
                                    "policy": {
                                        "secureOutput": false,
                                        "secureInput": false
                                    },
                                    "userProperties": [],
                                    "typeProperties": {
                                        "variableName": "ValidationStatus",
                                        "value": "SUCCESS"
                                    }
                                }
                            ]
                        }
                    },
                    {
                        "name": "Check_Null_Values",
                        "description": "Count null values in key columns",
                        "type": "Lookup",
                        "dependsOn": [
                            {
                                "activity": "Load_To_Snowflake_Bronze",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "source": {
                                "type": "SnowflakeV2Source",
                                "query": {
                                    "value": "SELECT \n    SUM(CASE WHEN data:id IS NULL THEN 1 ELSE 0 END) as null_ids,\n    SUM(CASE WHEN data:name IS NULL THEN 1 ELSE 0 END) as null_names\nFROM CANNACOLLECTIVE_RPT.BRONZE.@{pipeline().parameters.SchemaName}_@{pipeline().parameters.TableName}",
                                    "type": "Expression"
                                },
                                "exportSettings": {
                                    "type": "SnowflakeExportCopyCommand"
                                }
                            },
                            "dataset": {
                                "referenceName": "Snowflake_Rpt_Bronze",
                                "type": "DatasetReference",
                                "parameters": {}
                            }
                        }
                    },
                    {
                        "name": "Log_Pipeline_Summary",
                        "description": "Insert execution summary into UTILITY.PIPELINE_EXECUTION_LOG",
                        "type": "Script",
                        "dependsOn": [
                            {
                                "activity": "Validate_Row_Count_Match",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            },
                            {
                                "activity": "Check_Null_Values",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "linkedServiceName": {
                            "referenceName": "Canna_Snowflake_Rpt",
                            "type": "LinkedServiceReference"
                        },
                        "typeProperties": {
                            "scripts": [
                                {
                                    "type": "Query",
                                    "text": {
                                        "value": "INSERT INTO CANNACOLLECTIVE_RPT.UTILITY.PIPELINE_EXECUTION_LOG\nVALUES (\n    '@{pipeline().RunId}',\n    '@{pipeline().parameters.TableName}',\n    '@{formatDateTime(utcnow(), 'yyyy-MM-dd')}',\n    '@{utcnow()}',\n    @{activity('Get_Source_Row_Count').output.firstRow.row_count},\n    @{coalesce(activity('Get_Snowflake_Row_Count').output.firstRow.SNOWFLAKE_COUNT, 0)},\n    @{equals(variables('ValidationStatus'), 'SUCCESS')},\n    @{activity('Check_Duplicates').output.firstRow.duplicate_count},\n    @{coalesce(activity('Check_Null_Values').output.firstRow.NULL_IDS, 0)},\n    @{coalesce(activity('Check_Null_Values').output.firstRow.NULL_NAMES, 0)},\n    '@{variables('ValidationStatus')}',\n    0\n);",
                                        "type": "Expression"
                                    }
                                }
                            ],
                            "scriptBlockExecutionTimeout": "02:00:00"
                        }
                    },
                    {
                        "name": "Copy_To_ADLS",
                        "description": "Copy raw Postgres data into ADLS",
                        "type": "Copy",
                        "dependsOn": [
                            {
                                "activity": "Check_Duplicates",
                                "dependencyConditions": [
                                    "Succeeded"
                                ]
                            }
                        ],
                        "policy": {
                            "timeout": "0.12:00:00",
                            "retry": 0,
                            "retryIntervalInSeconds": 30,
                            "secureOutput": false,
                            "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                            "source": {
                                "type": "PostgreSqlV2Source",
                                "queryTimeout": "02:00:00"
                            },
                            "sink": {
                                "type": "JsonSink",
                                "storeSettings": {
                                    "type": "AzureBlobFSWriteSettings"
                                },
                                "formatSettings": {
                                    "type": "JsonWriteSettings"
                                }
                            },
                            "enableStaging": false,
                            "parallelCopies": 16,
                            "enableSkipIncompatibleRow": false,
                            "validateDataConsistency": true,
                            "logSettings": {
                                "enableCopyActivityLog": true,
                                "copyActivityLogSettings": {
                                    "logLevel": "Info",
                                    "enableReliableLogging": false
                                },
                                "logLocationSettings": {
                                    "linkedServiceName": {
                                        "referenceName": "Canna_ADLS",
                                        "type": "LinkedServiceReference"
                                    },
                                    "path": "logs/copy-activity"
                                }
                            },
                            "dataIntegrationUnits": 16
                        },
                        "inputs": [
                            {
                                "referenceName": "Canna_PostgreSQL_Rpt_Tables",
                                "type": "DatasetReference",
                                "parameters": {
                                    "SchemaName": "@pipeline().parameters.SchemaName",
                                    "TableName": "@pipeline().parameters.TableName"
                                }
                            }
                        ],
                        "outputs": [
                            {
                                "referenceName": "ADLS_JSON",
                                "type": "DatasetReference",
                                "parameters": {
                                    "Container": "raw",
                                    "Directory": {
                                        "value": "@concat(pipeline().parameters.SourceDatabase, '/', pipeline().parameters.TableName, '/', formatDateTime(utcnow(),'yyyy-MM-dd'))",
                                        "type": "Expression"
                                    },
                                    "FileName": {
                                        "value": "@concat(pipeline().parameters.SchemaName, '_', pipeline().parameters.TableName, '_latest.json')",
                                        "type": "Expression"
                                    }
                                }
                            }
                        ]
                    }
                ],
                "policy": {
                    "elapsedTimeMetric": {}
                },
                "parameters": {
                    "SourceDatabase": {
                        "type": "string",
                        "defaultValue": "rpt"
                    },
                    "SchemaName": {
                        "type": "string"
                    },
                    "TableName": {
                        "type": "string"
                    }
                },
                "variables": {
                    "ValidationStatus": {
                        "type": "String"
                    }
                },
                "annotations": [],
                "lastPublishTime": "2025-09-18T14:21:00Z"
            },
            "dependsOn": [
                "[concat(variables('factoryId'), '/datasets/Canna_PostgreSQL_Rpt_Tables')]",
                "[concat(variables('factoryId'), '/datasets/ADLS_JSON')]",
                "[concat(variables('factoryId'), '/linkedServices/Canna_Snowflake_Rpt')]",
                "[concat(variables('factoryId'), '/datasets/Snowflake_Rpt_Bronze')]",
                "[concat(variables('factoryId'), '/linkedServices/Canna_ADLS')]"
            ]
        },
        {
            "name": "[concat(parameters('factoryName'), '/ADLS_JSON')]",
            "type": "Microsoft.DataFactory/factories/datasets",
            "apiVersion": "2018-06-01",
            "properties": {
                "linkedServiceName": {
                    "referenceName": "Canna_ADLS",
                    "type": "LinkedServiceReference"
                },
                "parameters": {
                    "Container": {
                        "type": "string",
                        "defaultValue": "raw"
                    },
                    "Directory": {
                        "type": "string",
                        "defaultValue": "@concat(pipeline().parameters.SourceDatabase, '/', formatDateTime(utcnow(),'yyyy-MM-dd'))"
                    },
                    "FileName": {
                        "type": "string",
                        "defaultValue": "@concat(pipeline().parameters.SchemaName, '_', pipeline().parameters.TableName, '_', formatDateTime(utcnow(), 'yyyyMMddHHmmss'), '.json')"
                    }
                },
                "annotations": [],
                "type": "Json",
                "typeProperties": {
                    "location": {
                        "type": "AzureBlobFSLocation",
                        "fileName": {
                            "value": "@dataset().FileName",
                            "type": "Expression"
                        },
                        "folderPath": {
                            "value": "@dataset().Directory",
                            "type": "Expression"
                        },
                        "fileSystem": {
                            "value": "@dataset().Container",
                            "type": "Expression"
                        }
                    }
                },
                "schema": {}
            },
            "dependsOn": [
                "[concat(variables('factoryId'), '/linkedServices/Canna_ADLS')]"
            ]
        },
        {
            "name": "[concat(parameters('factoryName'), '/ADLS_Parquet')]",
            "type": "Microsoft.DataFactory/factories/datasets",
            "apiVersion": "2018-06-01",
            "properties": {
                "linkedServiceName": {
                    "referenceName": "Canna_ADLS",
                    "type": "LinkedServiceReference"
                },
                "parameters": {
                    "Container": {
                        "type": "string",
                        "defaultValue": "raw"
                    },
                    "Directory": {
                        "type": "string",
                        "defaultValue": "@concat(pipeline().parameters.SourceDatabase, '/', formatDateTime(utcnow(),'yyyy-MM-dd'))"
                    },
                    "FileName": {
                        "type": "string",
                        "defaultValue": "@concat(pipeline().parameters.SchemaName, '_', pipeline().parameters.TableName, '_', formatDateTime(utcnow(), 'yyyyMMddHHmmss'), '.parquet')"
                    }
                },
                "annotations": [],
                "type": "Parquet",
                "typeProperties": {
                    "location": {
                        "type": "AzureBlobFSLocation",
                        "fileName": {
                            "value": "@dataset().FileName",
                            "type": "Expression"
                        },
                        "folderPath": {
                            "value": "@dataset().Directory",
                            "type": "Expression"
                        },
                        "fileSystem": {
                            "value": "@dataset().Container",
                            "type": "Expression"
                        }
                    },
                    "compressionCodec": "snappy"
                },
                "schema": []
            },
            "dependsOn": [
                "[concat(variables('factoryId'), '/linkedServices/Canna_ADLS')]"
            ]
        },
        {
            "name": "[concat(parameters('factoryName'), '/Canna_PostgreSQL_Collect_Tables')]",
            "type": "Microsoft.DataFactory/factories/datasets",
            "apiVersion": "2018-06-01",
            "properties": {
                "linkedServiceName": {
                    "referenceName": "Canna_PostgreSQL_Collect",
                    "type": "LinkedServiceReference"
                },
                "parameters": {
                    "SchemaName": {
                        "type": "String",
                        "defaultValue": "collect"
                    },
                    "TableName": {
                        "type": "String",
                        "defaultValue": "cc_customers"
                    }
                },
                "annotations": [],
                "type": "PostgreSqlV2Table",
                "schema": [],
                "typeProperties": {
                    "schema": {
                        "value": "@dataset().SchemaName",
                        "type": "Expression"
                    },
                    "table": {
                        "value": "@dataset().TableName",
                        "type": "Expression"
                    }
                }
            },
            "dependsOn": [
                "[concat(variables('factoryId'), '/linkedServices/Canna_PostgreSQL_Collect')]"
            ]
        },
        {
            "name": "[concat(parameters('factoryName'), '/Canna_PostgreSQL_Rpt_Tables')]",
            "type": "Microsoft.DataFactory/factories/datasets",
            "apiVersion": "2018-06-01",
            "properties": {
                "linkedServiceName": {
                    "referenceName": "Canna_PostgreSQL_Rpt",
                    "type": "LinkedServiceReference"
                },
                "parameters": {
                    "SchemaName": {
                        "type": "String",
                        "defaultValue": "rpt"
                    },
                    "TableName": {
                        "type": "String",
                        "defaultValue": "cc_customers"
                    }
                },
                "annotations": [],
                "type": "PostgreSqlV2Table",
                "schema": [],
                "typeProperties": {
                    "schema": {
                        "value": "@dataset().SchemaName",
                        "type": "Expression"
                    },
                    "table": {
                        "value": "@dataset().TableName",
                        "type": "Expression"
                    }
                }
            },
            "dependsOn": [
                "[concat(variables('factoryId'), '/linkedServices/Canna_PostgreSQL_Rpt')]"
            ]
        },
        {
            "name": "[concat(parameters('factoryName'), '/Snowflake_Collect_Bronze')]",
            "type": "Microsoft.DataFactory/factories/datasets",
            "apiVersion": "2018-06-01",
            "properties": {
                "linkedServiceName": {
                    "referenceName": "Canna_Snowflake_Collect",
                    "type": "LinkedServiceReference"
                },
                "annotations": [],
                "type": "SnowflakeV2Table",
                "schema": [],
                "typeProperties": {
                    "schema": "BRONZE",
                    "table": {
                        "value": "@concat(pipeline().parameters.SchemaName, '_', pipeline().parameters.TableName)",
                        "type": "Expression"
                    }
                }
            },
            "dependsOn": [
                "[concat(variables('factoryId'), '/linkedServices/Canna_Snowflake_Collect')]"
            ]
        },
        {
            "name": "[concat(parameters('factoryName'), '/Snowflake_Rpt_Bronze')]",
            "type": "Microsoft.DataFactory/factories/datasets",
            "apiVersion": "2018-06-01",
            "properties": {
                "linkedServiceName": {
                    "referenceName": "Canna_Snowflake_Rpt",
                    "type": "LinkedServiceReference"
                },
                "annotations": [],
                "type": "SnowflakeV2Table",
                "schema": [],
                "typeProperties": {
                    "schema": "BRONZE",
                    "table": {
                        "value": "@concat(pipeline().parameters.SchemaName, '_', pipeline().parameters.TableName)",
                        "type": "Expression"
                    }
                }
            },
            "dependsOn": [
                "[concat(variables('factoryId'), '/linkedServices/Canna_Snowflake_Rpt')]"
            ]
        },
        {
            "name": "[concat(parameters('factoryName'), '/Canna_ADLS')]",
            "type": "Microsoft.DataFactory/factories/linkedServices",
            "apiVersion": "2018-06-01",
            "properties": {
                "annotations": [],
                "type": "AzureBlobFS",
                "typeProperties": {
                    "url": "[parameters('Canna_ADLS_properties_typeProperties_url')]",
                    "accountKey": {
                        "type": "SecureString",
                        "value": "[parameters('Canna_ADLS_accountKey')]"
                    }
                }
            },
            "dependsOn": []
        },
        {
            "name": "[concat(parameters('factoryName'), '/Canna_PostgreSQL_Collect')]",
            "type": "Microsoft.DataFactory/factories/linkedServices",
            "apiVersion": "2018-06-01",
            "properties": {
                "annotations": [],
                "type": "PostgreSqlV2",
                "typeProperties": {
                    "server": "[parameters('Canna_PostgreSQL_Collect_properties_typeProperties_server')]",
                    "port": 5432,
                    "database": "[parameters('Canna_PostgreSQL_Collect_properties_typeProperties_database')]",
                    "username": "[parameters('Canna_PostgreSQL_Collect_properties_typeProperties_username')]",
                    "password": {
                        "type": "SecureString",
                        "value": "[parameters('Canna_PostgreSQL_Collect_password')]"
                    },
                    "sslMode": 2,
                    "authenticationType": "Basic"
                },
                "connectVia": {
                    "referenceName": "Canna-SHIR",
                    "type": "IntegrationRuntimeReference"
                }
            },
            "dependsOn": [
                "[concat(variables('factoryId'), '/integrationRuntimes/Canna-SHIR')]"
            ]
        },
        {
            "name": "[concat(parameters('factoryName'), '/Canna_PostgreSQL_Rpt')]",
            "type": "Microsoft.DataFactory/factories/linkedServices",
            "apiVersion": "2018-06-01",
            "properties": {
                "annotations": [],
                "type": "PostgreSqlV2",
                "typeProperties": {
                    "server": "[parameters('Canna_PostgreSQL_Rpt_properties_typeProperties_server')]",
                    "port": 5432,
                    "database": "[parameters('Canna_PostgreSQL_Rpt_properties_typeProperties_database')]",
                    "username": "[parameters('Canna_PostgreSQL_Rpt_properties_typeProperties_username')]",
                    "password": {
                        "type": "SecureString",
                        "value": "[parameters('Canna_PostgreSQL_Rpt_password')]"
                    },
                    "sslMode": 2,
                    "authenticationType": "Basic"
                },
                "connectVia": {
                    "referenceName": "Canna-SHIR",
                    "type": "IntegrationRuntimeReference"
                }
            },
            "dependsOn": [
                "[concat(variables('factoryId'), '/integrationRuntimes/Canna-SHIR')]"
            ]
        },
        {
            "name": "[concat(parameters('factoryName'), '/Canna_Snowflake_Collect')]",
            "type": "Microsoft.DataFactory/factories/linkedServices",
            "apiVersion": "2018-06-01",
            "properties": {
                "annotations": [],
                "type": "SnowflakeV2",
                "typeProperties": {
                    "authenticationType": "Basic",
                    "accountIdentifier": "KNRSBRS-WE28929",
                    "user": "ADF_SERVICE_ACCOUNT",
                    "database": "[parameters('Canna_Snowflake_Collect_properties_typeProperties_database')]",
                    "warehouse": "LOAD_WH",
                    "role": "[parameters('Canna_Snowflake_Collect_properties_typeProperties_role')]",
                    "host": "[parameters('Canna_Snowflake_Collect_properties_typeProperties_host')]",
                    "password": {
                        "type": "SecureString",
                        "value": "[parameters('Canna_Snowflake_Collect_password')]"
                    }
                },
                "version": "1.1"
            },
            "dependsOn": []
        },
        {
            "name": "[concat(parameters('factoryName'), '/Canna_Snowflake_Rpt')]",
            "type": "Microsoft.DataFactory/factories/linkedServices",
            "apiVersion": "2018-06-01",
            "properties": {
                "annotations": [],
                "type": "SnowflakeV2",
                "typeProperties": {
                    "authenticationType": "Basic",
                    "accountIdentifier": "KNRSBRS-WE28929",
                    "user": "ADF_SERVICE_ACCOUNT",
                    "database": "[parameters('Canna_Snowflake_Rpt_properties_typeProperties_database')]",
                    "warehouse": "LOAD_WH",
                    "role": "[parameters('Canna_Snowflake_Rpt_properties_typeProperties_role')]",
                    "host": "[parameters('Canna_Snowflake_Rpt_properties_typeProperties_host')]",
                    "password": {
                        "type": "SecureString",
                        "value": "[parameters('Canna_Snowflake_Rpt_password')]"
                    }
                },
                "version": "1.1"
            },
            "dependsOn": []
        },
        {
            "name": "[concat(parameters('factoryName'), '/Canna-SHIR')]",
            "type": "Microsoft.DataFactory/factories/integrationRuntimes",
            "apiVersion": "2018-06-01",
            "properties": {
                "type": "SelfHosted",
                "description": "SHIR for Canna PostgreSQL connection",
                "typeProperties": {}
            },
            "dependsOn": []
        }
    ]
}